{"file_contents":{"server/vite.ts":{"content":"import express, { type Express } from \"express\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport { createServer as createViteServer, createLogger } from \"vite\";\nimport { type Server } from \"http\";\nimport viteConfig from \"../vite.config\";\nimport { nanoid } from \"nanoid\";\n\nconst viteLogger = createLogger();\n\nexport function log(message: string, source = \"express\") {\n  const formattedTime = new Date().toLocaleTimeString(\"en-US\", {\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    second: \"2-digit\",\n    hour12: true,\n  });\n\n  console.log(`${formattedTime} [${source}] ${message}`);\n}\n\nexport async function setupVite(app: Express, server: Server) {\n  const serverOptions = {\n    middlewareMode: true,\n    hmr: { server },\n    allowedHosts: true as const,\n  };\n\n  const vite = await createViteServer({\n    ...viteConfig,\n    configFile: false,\n    customLogger: {\n      ...viteLogger,\n      error: (msg, options) => {\n        viteLogger.error(msg, options);\n        process.exit(1);\n      },\n    },\n    server: serverOptions,\n    appType: \"custom\",\n  });\n\n  app.use(vite.middlewares);\n  app.use(\"*\", async (req, res, next) => {\n    const url = req.originalUrl;\n\n    try {\n      const clientTemplate = path.resolve(\n        import.meta.dirname,\n        \"..\",\n        \"client\",\n        \"index.html\",\n      );\n\n      // always reload the index.html file from disk incase it changes\n      let template = await fs.promises.readFile(clientTemplate, \"utf-8\");\n      template = template.replace(\n        `src=\"/src/main.tsx\"`,\n        `src=\"/src/main.tsx?v=${nanoid()}\"`,\n      );\n      const page = await vite.transformIndexHtml(url, template);\n      res.status(200).set({ \"Content-Type\": \"text/html\" }).end(page);\n    } catch (e) {\n      vite.ssrFixStacktrace(e as Error);\n      next(e);\n    }\n  });\n}\n\nexport function serveStatic(app: Express) {\n  const distPath = path.resolve(import.meta.dirname, \"public\");\n\n  if (!fs.existsSync(distPath)) {\n    throw new Error(\n      `Could not find the build directory: ${distPath}, make sure to build the client first`,\n    );\n  }\n\n  app.use(express.static(distPath));\n\n  // fall through to index.html if the file doesn't exist\n  app.use(\"*\", (_req, res) => {\n    res.sendFile(path.resolve(distPath, \"index.html\"));\n  });\n}\n","size_bytes":2263},"client/src/pages/settings.tsx":{"content":"import { Card, CardContent, CardDescription, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport { Button } from \"@/components/ui/button\";\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { CheckCircle, Copy, XCircle } from \"lucide-react\";\nimport { useState, useEffect } from \"react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { apiRequest, queryClient } from \"@/lib/queryClient\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport type { Settings } from \"@shared/schema\";\n\nexport default function SettingsPage() {\n  const { toast } = useToast();\n  const { data: settings } = useQuery<Settings>({\n    queryKey: [\"/api/settings\"],\n  });\n\n  const [apiEndpoint, setApiEndpoint] = useState(\"\");\n  const [apiKey, setApiKey] = useState(\"\");\n  const [model, setModel] = useState(\"gpt-4\");\n  const [maxTokens, setMaxTokens] = useState(\"4096\");\n  const [temperature, setTemperature] = useState(\"0.7\");\n  const [githubToken, setGithubToken] = useState(\"\");\n  const [webhookSecret, setWebhookSecret] = useState(\"\");\n  const [autoApprove, setAutoApprove] = useState(false);\n\n  const webhookUrl = `${window.location.origin}/api/webhook`;\n\n  useEffect(() => {\n    if (settings) {\n      setApiEndpoint(settings.ai.apiEndpoint);\n      setApiKey(settings.ai.apiKey === \"***\" ? \"\" : settings.ai.apiKey);\n      setModel(settings.ai.model);\n      setMaxTokens(settings.ai.maxTokens.toString());\n      setTemperature(settings.ai.temperature.toString());\n      setGithubToken(settings.github.token === \"***\" ? \"\" : settings.github.token);\n      setWebhookSecret(settings.github.webhookSecret || \"\");\n      setAutoApprove(settings.autoApprove);\n    }\n  }, [settings]);\n\n  const handleSaveAISettings = async () => {\n    try {\n      const updatedSettings: Settings = {\n        ai: {\n          apiEndpoint,\n          apiKey: apiKey || settings?.ai.apiKey || \"\",\n          model,\n          maxTokens: parseInt(maxTokens),\n          temperature: parseFloat(temperature),\n        },\n        github: settings?.github || { token: \"\" },\n        autoApprove,\n      };\n\n      await apiRequest(\"POST\", \"/api/settings\", updatedSettings);\n\n      queryClient.invalidateQueries({ queryKey: [\"/api/settings\"] });\n      \n      toast({\n        title: \"Settings saved\",\n        description: \"AI configuration has been updated successfully\",\n      });\n    } catch (error: any) {\n      toast({\n        title: \"Error\",\n        description: error.message,\n        variant: \"destructive\",\n      });\n    }\n  };\n\n  const handleSaveGitHubSettings = async () => {\n    try {\n      const updatedSettings: Settings = {\n        ai: settings?.ai || {\n          apiEndpoint: \"https://api.openai.com/v1\",\n          apiKey: \"\",\n          model: \"gpt-4\",\n          maxTokens: 4096,\n          temperature: 0.7,\n        },\n        github: {\n          token: githubToken || settings?.github.token || \"\",\n          webhookSecret: webhookSecret || undefined,\n        },\n        autoApprove,\n      };\n\n      await apiRequest(\"POST\", \"/api/settings\", updatedSettings);\n\n      queryClient.invalidateQueries({ queryKey: [\"/api/settings\"] });\n      \n      toast({\n        title: \"Settings saved\",\n        description: \"GitHub configuration has been updated successfully\",\n      });\n    } catch (error: any) {\n      toast({\n        title: \"Error\",\n        description: error.message,\n        variant: \"destructive\",\n      });\n    }\n  };\n\n  const copyWebhookUrl = () => {\n    navigator.clipboard.writeText(webhookUrl);\n    toast({\n      title: \"Copied!\",\n      description: \"Webhook URL copied to clipboard\",\n    });\n  };\n\n  const hasGitHubToken = settings?.github.token && settings.github.token !== \"\";\n\n  return (\n    <div className=\"space-y-6 max-w-4xl\">\n      <div>\n        <h1 className=\"text-2xl font-semibold\" data-testid=\"text-page-title\">\n          Settings\n        </h1>\n        <p className=\"text-sm text-muted-foreground mt-1\">\n          Configure AI models, GitHub integration, and webhook endpoints\n        </p>\n      </div>\n\n      <Card>\n        <CardHeader>\n          <CardTitle>OpenAI-Compatible API Configuration</CardTitle>\n          <CardDescription>\n            Connect to OpenAI, Anthropic, Mistral, Ollama, or any custom API endpoint\n          </CardDescription>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"api-endpoint\">API Endpoint URL</Label>\n            <Input\n              id=\"api-endpoint\"\n              type=\"url\"\n              value={apiEndpoint}\n              onChange={(e) => setApiEndpoint(e.target.value)}\n              placeholder=\"https://api.openai.com/v1\"\n              data-testid=\"input-api-endpoint\"\n            />\n            <p className=\"text-xs text-muted-foreground\">\n              Examples: OpenAI (https://api.openai.com/v1), Ollama (http://localhost:11434/v1), \n              Anthropic (https://api.anthropic.com/v1), Custom endpoint\n            </p>\n          </div>\n\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"api-key\">API Key</Label>\n            <Input\n              id=\"api-key\"\n              type=\"password\"\n              value={apiKey}\n              onChange={(e) => setApiKey(e.target.value)}\n              placeholder={apiKey ? \"***\" : \"sk-...\"}\n              data-testid=\"input-api-key\"\n            />\n            <p className=\"text-xs text-muted-foreground\">\n              Your API key is stored securely on the server\n            </p>\n          </div>\n\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"model\">Model</Label>\n            <Select value={model} onValueChange={setModel}>\n              <SelectTrigger id=\"model\" data-testid=\"select-model\">\n                <SelectValue />\n              </SelectTrigger>\n              <SelectContent>\n                <SelectItem value=\"gpt-4\">GPT-4</SelectItem>\n                <SelectItem value=\"gpt-4-turbo\">GPT-4 Turbo</SelectItem>\n                <SelectItem value=\"gpt-3.5-turbo\">GPT-3.5 Turbo</SelectItem>\n                <SelectItem value=\"claude-3-opus\">Claude 3 Opus</SelectItem>\n                <SelectItem value=\"claude-3-sonnet\">Claude 3 Sonnet</SelectItem>\n                <SelectItem value=\"mistral-large\">Mistral Large</SelectItem>\n                <SelectItem value=\"llama-3-70b\">Llama 3 70B (Ollama)</SelectItem>\n                <SelectItem value=\"custom\">Custom Model</SelectItem>\n              </SelectContent>\n            </Select>\n          </div>\n\n          <div className=\"grid grid-cols-2 gap-4\">\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"max-tokens\">Max Tokens</Label>\n              <Input\n                id=\"max-tokens\"\n                type=\"number\"\n                value={maxTokens}\n                onChange={(e) => setMaxTokens(e.target.value)}\n                data-testid=\"input-max-tokens\"\n              />\n            </div>\n\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"temperature\">Temperature</Label>\n              <Input\n                id=\"temperature\"\n                type=\"number\"\n                step=\"0.1\"\n                min=\"0\"\n                max=\"2\"\n                value={temperature}\n                onChange={(e) => setTemperature(e.target.value)}\n                data-testid=\"input-temperature\"\n              />\n            </div>\n          </div>\n\n          <Button \n            onClick={handleSaveAISettings}\n            data-testid=\"button-save-ai-settings\"\n          >\n            Save AI Settings\n          </Button>\n        </CardContent>\n      </Card>\n\n      <Card>\n        <CardHeader>\n          <CardTitle>GitHub Integration</CardTitle>\n          <CardDescription>\n            Connect your GitHub account to enable repository access\n          </CardDescription>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <div className=\"flex items-center justify-between\">\n            <div className=\"space-y-1\">\n              <div className=\"font-medium\">Connection Status</div>\n              <div className=\"text-sm text-muted-foreground\">\n                {hasGitHubToken ? \"Connected\" : \"Not connected\"}\n              </div>\n            </div>\n            {hasGitHubToken ? (\n              <Badge variant=\"secondary\" className=\"gap-1\">\n                <CheckCircle className=\"h-3 w-3 text-chart-2\" />\n                Connected\n              </Badge>\n            ) : (\n              <Badge variant=\"destructive\" className=\"gap-1\">\n                <XCircle className=\"h-3 w-3\" />\n                Disconnected\n              </Badge>\n            )}\n          </div>\n\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"github-token\">Personal Access Token</Label>\n            <Input\n              id=\"github-token\"\n              type=\"password\"\n              value={githubToken}\n              onChange={(e) => setGithubToken(e.target.value)}\n              placeholder={hasGitHubToken ? \"***\" : \"ghp_...\"}\n              data-testid=\"input-github-token\"\n            />\n            <p className=\"text-xs text-muted-foreground\">\n              Required scopes: repo, workflow, read:org\n            </p>\n          </div>\n\n          <Button \n            onClick={handleSaveGitHubSettings}\n            data-testid=\"button-save-github-settings\"\n          >\n            Save GitHub Settings\n          </Button>\n        </CardContent>\n      </Card>\n\n      <Card>\n        <CardHeader>\n          <CardTitle>Webhook Configuration</CardTitle>\n          <CardDescription>\n            Configure GitHub webhooks to receive repository events\n          </CardDescription>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <div className=\"space-y-2\">\n            <Label>Webhook URL</Label>\n            <div className=\"flex gap-2\">\n              <Input\n                value={webhookUrl}\n                readOnly\n                className=\"font-mono text-sm\"\n                data-testid=\"input-webhook-url\"\n              />\n              <Button\n                variant=\"outline\"\n                size=\"icon\"\n                onClick={copyWebhookUrl}\n                data-testid=\"button-copy-webhook\"\n              >\n                <Copy className=\"h-4 w-4\" />\n              </Button>\n            </div>\n            <p className=\"text-xs text-muted-foreground\">\n              Add this URL to your GitHub repository webhook settings\n            </p>\n          </div>\n\n          <div className=\"space-y-2\">\n            <Label>Events</Label>\n            <div className=\"flex flex-wrap gap-2\">\n              <Badge variant=\"secondary\">Pull Requests</Badge>\n              <Badge variant=\"secondary\">Issues</Badge>\n              <Badge variant=\"secondary\">Push</Badge>\n              <Badge variant=\"secondary\">Comments</Badge>\n              <Badge variant=\"secondary\">Workflow Runs</Badge>\n            </div>\n          </div>\n\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"webhook-secret\">Webhook Secret (Optional)</Label>\n            <Input\n              id=\"webhook-secret\"\n              type=\"password\"\n              value={webhookSecret}\n              onChange={(e) => setWebhookSecret(e.target.value)}\n              placeholder=\"Enter webhook secret...\"\n              data-testid=\"input-webhook-secret\"\n            />\n            <p className=\"text-xs text-muted-foreground\">\n              Used to verify webhook payloads from GitHub\n            </p>\n          </div>\n        </CardContent>\n      </Card>\n\n      <Card>\n        <CardHeader>\n          <CardTitle>Advanced Settings</CardTitle>\n          <CardDescription>\n            Configure advanced AI agent behavior\n          </CardDescription>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <div className=\"flex items-center justify-between\">\n            <div className=\"space-y-1\">\n              <div className=\"font-medium\">Auto-approve changes</div>\n              <div className=\"text-sm text-muted-foreground\">\n                Automatically approve and commit AI-generated code changes\n              </div>\n            </div>\n            <Button\n              variant=\"outline\"\n              size=\"sm\"\n              onClick={() => setAutoApprove(!autoApprove)}\n              data-testid=\"button-toggle-auto-approve\"\n            >\n              {autoApprove ? \"Enabled\" : \"Disabled\"}\n            </Button>\n          </div>\n        </CardContent>\n      </Card>\n    </div>\n  );\n}\n","size_bytes":12612},"server/db-storage.ts":{"content":"import { drizzle } from \"drizzle-orm/neon-http\";\nimport { neon } from \"@neondatabase/serverless\";\nimport { eq, desc, and, or, inArray } from \"drizzle-orm\";\nimport {\n  tasks,\n  taskLogs,\n  reasoningSteps,\n  fileDiffs,\n  githubEvents,\n  settings,\n  repositoryContexts,\n  containerRunners,\n  mcpConnections,\n} from \"@shared/schema\";\nimport type {\n  Task,\n  InsertTask,\n  GithubEvent,\n  InsertGithubEvent,\n  Settings,\n  LogEntry,\n  ReasoningStep,\n  FileDiff,\n  RepositoryContext,\n  InsertRepositoryContext,\n  MCPConnection,\n  InsertMCPConnection,\n} from \"@shared/schema\";\nimport type { IStorage } from \"./storage\";\n\nif (!process.env.DATABASE_URL) {\n  throw new Error(\"DATABASE_URL is not set\");\n}\n\nconst sql = neon(process.env.DATABASE_URL);\nconst db = drizzle(sql);\n\nexport class DatabaseStorage implements IStorage {\n  async getTask(id: string): Promise<Task | undefined> {\n    const [task] = await db.select().from(tasks).where(eq(tasks.id, id));\n    if (!task) return undefined;\n\n    const logs = await db.select().from(taskLogs).where(eq(taskLogs.taskId, id));\n    const reasoning = await db.select().from(reasoningSteps).where(eq(reasoningSteps.taskId, id));\n    const diffs = await db.select().from(fileDiffs).where(eq(fileDiffs.taskId, id));\n\n    return {\n      id: task.id,\n      title: task.title,\n      status: task.status as Task[\"status\"],\n      repository: task.repository,\n      branch: task.branch || undefined,\n      summary: task.summary,\n      createdAt: task.createdAt.toISOString(),\n      updatedAt: task.updatedAt.toISOString(),\n      progress: task.progress,\n      eventId: task.eventId || undefined,\n      logs: logs.map((log) => ({\n        id: log.id,\n        timestamp: log.timestamp,\n        level: log.level as LogEntry[\"level\"],\n        message: log.message,\n      })),\n      reasoning: reasoning.map((step) => ({\n        id: step.id,\n        timestamp: step.timestamp,\n        description: step.description,\n        confidence: step.confidence || undefined,\n        completed: step.completed,\n      })),\n      diffs: diffs.map((diff) => ({\n        path: diff.path,\n        lines: diff.lines as FileDiff[\"lines\"],\n      })),\n    };\n  }\n\n  async getAllTasks(): Promise<Task[]> {\n    const allTasks = await db.select().from(tasks).orderBy(desc(tasks.createdAt));\n    \n    const taskIds = allTasks.map((t) => t.id);\n    if (taskIds.length === 0) return [];\n\n    const allLogs = await db.select().from(taskLogs).where(inArray(taskLogs.taskId, taskIds));\n    const allReasoning = await db.select().from(reasoningSteps).where(inArray(reasoningSteps.taskId, taskIds));\n    const allDiffs = await db.select().from(fileDiffs).where(inArray(fileDiffs.taskId, taskIds));\n\n    const logsMap = new Map<string, typeof allLogs>();\n    const reasoningMap = new Map<string, typeof allReasoning>();\n    const diffsMap = new Map<string, typeof allDiffs>();\n\n    for (const log of allLogs) {\n      if (!logsMap.has(log.taskId)) logsMap.set(log.taskId, []);\n      logsMap.get(log.taskId)!.push(log);\n    }\n    for (const step of allReasoning) {\n      if (!reasoningMap.has(step.taskId)) reasoningMap.set(step.taskId, []);\n      reasoningMap.get(step.taskId)!.push(step);\n    }\n    for (const diff of allDiffs) {\n      if (!diffsMap.has(diff.taskId)) diffsMap.set(diff.taskId, []);\n      diffsMap.get(diff.taskId)!.push(diff);\n    }\n\n    return allTasks.map((task) => ({\n      id: task.id,\n      title: task.title,\n      status: task.status as Task[\"status\"],\n      repository: task.repository,\n      branch: task.branch || undefined,\n      summary: task.summary,\n      createdAt: task.createdAt.toISOString(),\n      updatedAt: task.updatedAt.toISOString(),\n      progress: task.progress,\n      eventId: task.eventId || undefined,\n      logs: (logsMap.get(task.id) || []).map((log) => ({\n        id: log.id,\n        timestamp: log.timestamp,\n        level: log.level as LogEntry[\"level\"],\n        message: log.message,\n      })),\n      reasoning: (reasoningMap.get(task.id) || []).map((step) => ({\n        id: step.id,\n        timestamp: step.timestamp,\n        description: step.description,\n        confidence: step.confidence || undefined,\n        completed: step.completed,\n      })),\n      diffs: (diffsMap.get(task.id) || []).map((diff) => ({\n        path: diff.path,\n        lines: diff.lines as FileDiff[\"lines\"],\n      })),\n    }));\n  }\n\n  async getActiveTasks(): Promise<Task[]> {\n    const activeTasks = await db\n      .select()\n      .from(tasks)\n      .where(or(\n        eq(tasks.status, \"planning\"),\n        eq(tasks.status, \"executing\"),\n        eq(tasks.status, \"queued\")\n      ))\n      .orderBy(desc(tasks.createdAt));\n\n    if (activeTasks.length === 0) return [];\n\n    const taskIds = activeTasks.map((t) => t.id);\n    const allLogs = await db.select().from(taskLogs).where(inArray(taskLogs.taskId, taskIds));\n    const allReasoning = await db.select().from(reasoningSteps).where(inArray(reasoningSteps.taskId, taskIds));\n    const allDiffs = await db.select().from(fileDiffs).where(inArray(fileDiffs.taskId, taskIds));\n\n    const logsMap = new Map<string, typeof allLogs>();\n    const reasoningMap = new Map<string, typeof allReasoning>();\n    const diffsMap = new Map<string, typeof allDiffs>();\n\n    for (const log of allLogs) {\n      if (!logsMap.has(log.taskId)) logsMap.set(log.taskId, []);\n      logsMap.get(log.taskId)!.push(log);\n    }\n    for (const step of allReasoning) {\n      if (!reasoningMap.has(step.taskId)) reasoningMap.set(step.taskId, []);\n      reasoningMap.get(step.taskId)!.push(step);\n    }\n    for (const diff of allDiffs) {\n      if (!diffsMap.has(diff.taskId)) diffsMap.set(diff.taskId, []);\n      diffsMap.get(diff.taskId)!.push(diff);\n    }\n\n    return activeTasks.map((task) => ({\n      id: task.id,\n      title: task.title,\n      status: task.status as Task[\"status\"],\n      repository: task.repository,\n      branch: task.branch || undefined,\n      summary: task.summary,\n      createdAt: task.createdAt.toISOString(),\n      updatedAt: task.updatedAt.toISOString(),\n      progress: task.progress,\n      eventId: task.eventId || undefined,\n      logs: (logsMap.get(task.id) || []).map((log) => ({\n        id: log.id,\n        timestamp: log.timestamp,\n        level: log.level as LogEntry[\"level\"],\n        message: log.message,\n      })),\n      reasoning: (reasoningMap.get(task.id) || []).map((step) => ({\n        id: step.id,\n        timestamp: step.timestamp,\n        description: step.description,\n        confidence: step.confidence || undefined,\n        completed: step.completed,\n      })),\n      diffs: (diffsMap.get(task.id) || []).map((diff) => ({\n        path: diff.path,\n        lines: diff.lines as FileDiff[\"lines\"],\n      })),\n    }));\n  }\n\n  async createTask(insertTask: InsertTask): Promise<Task> {\n    const [task] = await db\n      .insert(tasks)\n      .values({\n        title: insertTask.title,\n        status: insertTask.status,\n        repository: insertTask.repository,\n        branch: insertTask.branch,\n        summary: insertTask.summary,\n        progress: insertTask.progress || 0,\n        eventId: insertTask.eventId,\n      })\n      .returning();\n\n    return {\n      id: task.id,\n      title: task.title,\n      status: task.status as Task[\"status\"],\n      repository: task.repository,\n      branch: task.branch || undefined,\n      summary: task.summary,\n      createdAt: task.createdAt.toISOString(),\n      updatedAt: task.updatedAt.toISOString(),\n      progress: task.progress,\n      eventId: task.eventId || undefined,\n      logs: [],\n      reasoning: [],\n      diffs: [],\n    };\n  }\n\n  async updateTask(id: string, updates: Partial<Task>): Promise<Task | undefined> {\n    const [updated] = await db\n      .update(tasks)\n      .set({\n        ...(updates.title && { title: updates.title }),\n        ...(updates.status && { status: updates.status }),\n        ...(updates.repository && { repository: updates.repository }),\n        ...(updates.branch !== undefined && { branch: updates.branch }),\n        ...(updates.summary && { summary: updates.summary }),\n        ...(updates.progress !== undefined && { progress: updates.progress }),\n        ...(updates.eventId !== undefined && { eventId: updates.eventId }),\n        updatedAt: new Date(),\n      })\n      .where(eq(tasks.id, id))\n      .returning();\n\n    if (!updated) return undefined;\n\n    return this.getTask(id);\n  }\n\n  async addTaskLog(taskId: string, log: LogEntry): Promise<void> {\n    await db.insert(taskLogs).values({\n      taskId,\n      timestamp: log.timestamp,\n      level: log.level,\n      message: log.message,\n    });\n  }\n\n  async addTaskReasoning(taskId: string, step: ReasoningStep): Promise<void> {\n    await db.insert(reasoningSteps).values({\n      taskId,\n      timestamp: step.timestamp,\n      description: step.description,\n      confidence: step.confidence,\n      completed: step.completed,\n    });\n  }\n\n  async addTaskDiff(taskId: string, diff: FileDiff): Promise<void> {\n    await db.insert(fileDiffs).values({\n      taskId,\n      path: diff.path,\n      lines: diff.lines,\n    });\n  }\n\n  async getEvent(id: string): Promise<GithubEvent | undefined> {\n    const [event] = await db.select().from(githubEvents).where(eq(githubEvents.id, id));\n    if (!event) return undefined;\n\n    return {\n      id: event.id,\n      timestamp: event.timestamp.toISOString(),\n      type: event.type as GithubEvent[\"type\"],\n      repository: event.repository,\n      action: event.action,\n      status: event.status as GithubEvent[\"status\"],\n      payload: event.payload as Record<string, any> | undefined,\n      taskId: event.taskId || undefined,\n    };\n  }\n\n  async getAllEvents(): Promise<GithubEvent[]> {\n    const events = await db.select().from(githubEvents).orderBy(desc(githubEvents.timestamp));\n    \n    return events.map((event) => ({\n      id: event.id,\n      timestamp: event.timestamp.toISOString(),\n      type: event.type as GithubEvent[\"type\"],\n      repository: event.repository,\n      action: event.action,\n      status: event.status as GithubEvent[\"status\"],\n      payload: event.payload as Record<string, any> | undefined,\n      taskId: event.taskId || undefined,\n    }));\n  }\n\n  async getRecentEvents(limit: number): Promise<GithubEvent[]> {\n    const events = await db\n      .select()\n      .from(githubEvents)\n      .orderBy(desc(githubEvents.timestamp))\n      .limit(limit);\n\n    return events.map((event) => ({\n      id: event.id,\n      timestamp: event.timestamp.toISOString(),\n      type: event.type as GithubEvent[\"type\"],\n      repository: event.repository,\n      action: event.action,\n      status: event.status as GithubEvent[\"status\"],\n      payload: event.payload as Record<string, any> | undefined,\n      taskId: event.taskId || undefined,\n    }));\n  }\n\n  async createEvent(insertEvent: InsertGithubEvent): Promise<GithubEvent> {\n    const [event] = await db\n      .insert(githubEvents)\n      .values({\n        type: insertEvent.type,\n        repository: insertEvent.repository,\n        action: insertEvent.action,\n        status: insertEvent.status,\n        payload: insertEvent.payload,\n        taskId: insertEvent.taskId,\n      })\n      .returning();\n\n    return {\n      id: event.id,\n      timestamp: event.timestamp.toISOString(),\n      type: event.type as GithubEvent[\"type\"],\n      repository: event.repository,\n      action: event.action,\n      status: event.status as GithubEvent[\"status\"],\n      payload: event.payload as Record<string, any> | undefined,\n      taskId: event.taskId || undefined,\n    };\n  }\n\n  async updateEvent(id: string, updates: Partial<GithubEvent>): Promise<GithubEvent | undefined> {\n    const [updated] = await db\n      .update(githubEvents)\n      .set({\n        ...(updates.type && { type: updates.type }),\n        ...(updates.repository && { repository: updates.repository }),\n        ...(updates.action && { action: updates.action }),\n        ...(updates.status && { status: updates.status }),\n        ...(updates.payload !== undefined && { payload: updates.payload }),\n        ...(updates.taskId !== undefined && { taskId: updates.taskId }),\n      })\n      .where(eq(githubEvents.id, id))\n      .returning();\n\n    if (!updated) return undefined;\n\n    return this.getEvent(id);\n  }\n\n  async getSettings(): Promise<Settings | undefined> {\n    const [setting] = await db.select().from(settings).limit(1);\n    if (!setting) return undefined;\n\n    return {\n      ai: {\n        apiEndpoint: setting.aiEndpoint,\n        apiKey: setting.aiKey,\n        model: setting.aiModel,\n        maxTokens: setting.aiMaxTokens,\n        temperature: setting.aiTemperature / 100,\n      },\n      github: {\n        token: setting.githubToken,\n        webhookSecret: setting.githubWebhookSecret || undefined,\n      },\n      autoApprove: setting.autoApprove,\n    };\n  }\n\n  async updateSettings(updates: Partial<Settings>): Promise<Settings> {\n    const existing = await db.select().from(settings).limit(1);\n\n    const settingsData = {\n      aiEndpoint: updates.ai?.apiEndpoint || existing[0]?.aiEndpoint || \"https://api.openai.com/v1\",\n      aiKey: updates.ai?.apiKey || existing[0]?.aiKey || \"\",\n      aiModel: updates.ai?.model || existing[0]?.aiModel || \"gpt-4\",\n      aiMaxTokens: updates.ai?.maxTokens || existing[0]?.aiMaxTokens || 4096,\n      aiTemperature: updates.ai?.temperature !== undefined \n        ? Math.round(updates.ai.temperature * 100)\n        : (existing[0]?.aiTemperature || 70),\n      githubToken: updates.github?.token || existing[0]?.githubToken || \"\",\n      githubWebhookSecret: updates.github?.webhookSecret || existing[0]?.githubWebhookSecret,\n      autoApprove: updates.autoApprove !== undefined ? updates.autoApprove : existing[0]?.autoApprove || false,\n      updatedAt: new Date(),\n    };\n\n    let result;\n    if (existing.length > 0) {\n      [result] = await db\n        .update(settings)\n        .set(settingsData)\n        .where(eq(settings.id, existing[0].id))\n        .returning();\n    } else {\n      [result] = await db.insert(settings).values(settingsData).returning();\n    }\n\n    return {\n      ai: {\n        apiEndpoint: result.aiEndpoint,\n        apiKey: result.aiKey,\n        model: result.aiModel,\n        maxTokens: result.aiMaxTokens,\n        temperature: result.aiTemperature / 100,\n      },\n      github: {\n        token: result.githubToken,\n        webhookSecret: result.githubWebhookSecret || undefined,\n      },\n      autoApprove: result.autoApprove,\n    };\n  }\n\n  async getRepositoryContext(repository: string): Promise<RepositoryContext | undefined> {\n    const [context] = await db\n      .select()\n      .from(repositoryContexts)\n      .where(eq(repositoryContexts.repository, repository));\n    \n    if (!context) return undefined;\n\n    return {\n      id: context.id,\n      repository: context.repository,\n      architecture: context.architecture as Record<string, any> | undefined,\n      dependencies: context.dependencies as Record<string, any> | undefined,\n      fileStructure: context.fileStructure as string[] | undefined,\n      branches: context.branches as Array<Record<string, any>> | undefined,\n      recentCommits: context.recentCommits as Array<Record<string, any>> | undefined,\n      openIssues: context.openIssues as Array<Record<string, any>> | undefined,\n      semanticSummary: context.semanticSummary || undefined,\n      createdAt: context.createdAt.toISOString(),\n      updatedAt: context.updatedAt.toISOString(),\n    };\n  }\n\n  async createRepositoryContext(insertContext: InsertRepositoryContext): Promise<RepositoryContext> {\n    const [context] = await db\n      .insert(repositoryContexts)\n      .values({\n        repository: insertContext.repository,\n        architecture: insertContext.architecture,\n        dependencies: insertContext.dependencies,\n        fileStructure: insertContext.fileStructure,\n        branches: insertContext.branches,\n        recentCommits: insertContext.recentCommits,\n        openIssues: insertContext.openIssues,\n        semanticSummary: insertContext.semanticSummary,\n      })\n      .returning();\n\n    return {\n      id: context.id,\n      repository: context.repository,\n      architecture: context.architecture as Record<string, any> | undefined,\n      dependencies: context.dependencies as Record<string, any> | undefined,\n      fileStructure: context.fileStructure as string[] | undefined,\n      branches: context.branches as Array<Record<string, any>> | undefined,\n      recentCommits: context.recentCommits as Array<Record<string, any>> | undefined,\n      openIssues: context.openIssues as Array<Record<string, any>> | undefined,\n      semanticSummary: context.semanticSummary || undefined,\n      createdAt: context.createdAt.toISOString(),\n      updatedAt: context.updatedAt.toISOString(),\n    };\n  }\n\n  async updateRepositoryContext(repository: string, updates: Partial<RepositoryContext>): Promise<RepositoryContext | undefined> {\n    const [updated] = await db\n      .update(repositoryContexts)\n      .set({\n        ...(updates.architecture !== undefined && { architecture: updates.architecture }),\n        ...(updates.dependencies !== undefined && { dependencies: updates.dependencies }),\n        ...(updates.fileStructure !== undefined && { fileStructure: updates.fileStructure }),\n        ...(updates.branches !== undefined && { branches: updates.branches }),\n        ...(updates.recentCommits !== undefined && { recentCommits: updates.recentCommits }),\n        ...(updates.openIssues !== undefined && { openIssues: updates.openIssues }),\n        ...(updates.semanticSummary !== undefined && { semanticSummary: updates.semanticSummary }),\n        updatedAt: new Date(),\n      })\n      .where(eq(repositoryContexts.repository, repository))\n      .returning();\n\n    if (!updated) return undefined;\n\n    return this.getRepositoryContext(repository);\n  }\n\n  async getMCPConnection(id: string): Promise<MCPConnection | undefined> {\n    const [connection] = await db\n      .select()\n      .from(mcpConnections)\n      .where(eq(mcpConnections.id, id));\n\n    if (!connection) return undefined;\n\n    return {\n      id: connection.id,\n      type: connection.type as MCPConnection[\"type\"],\n      name: connection.name,\n      config: connection.config as Record<string, any>,\n      status: connection.status as MCPConnection[\"status\"],\n      lastUsed: connection.lastUsed?.toISOString(),\n      createdAt: connection.createdAt.toISOString(),\n    };\n  }\n\n  async getAllMCPConnections(): Promise<MCPConnection[]> {\n    const connections = await db\n      .select()\n      .from(mcpConnections)\n      .orderBy(desc(mcpConnections.createdAt));\n\n    return connections.map((connection) => ({\n      id: connection.id,\n      type: connection.type as MCPConnection[\"type\"],\n      name: connection.name,\n      config: connection.config as Record<string, any>,\n      status: connection.status as MCPConnection[\"status\"],\n      lastUsed: connection.lastUsed?.toISOString(),\n      createdAt: connection.createdAt.toISOString(),\n    }));\n  }\n\n  async createMCPConnection(insertConnection: InsertMCPConnection): Promise<MCPConnection> {\n    const [connection] = await db\n      .insert(mcpConnections)\n      .values({\n        type: insertConnection.type,\n        name: insertConnection.name,\n        config: insertConnection.config,\n        status: insertConnection.status,\n        lastUsed: insertConnection.lastUsed ? new Date(insertConnection.lastUsed) : null,\n      })\n      .returning();\n\n    return {\n      id: connection.id,\n      type: connection.type as MCPConnection[\"type\"],\n      name: connection.name,\n      config: connection.config as Record<string, any>,\n      status: connection.status as MCPConnection[\"status\"],\n      lastUsed: connection.lastUsed?.toISOString(),\n      createdAt: connection.createdAt.toISOString(),\n    };\n  }\n\n  async updateMCPConnection(id: string, updates: Partial<MCPConnection>): Promise<MCPConnection | undefined> {\n    const [updated] = await db\n      .update(mcpConnections)\n      .set({\n        ...(updates.type && { type: updates.type }),\n        ...(updates.name && { name: updates.name }),\n        ...(updates.config !== undefined && { config: updates.config }),\n        ...(updates.status && { status: updates.status }),\n        ...(updates.lastUsed !== undefined && { lastUsed: updates.lastUsed ? new Date(updates.lastUsed) : null }),\n      })\n      .where(eq(mcpConnections.id, id))\n      .returning();\n\n    if (!updated) return undefined;\n\n    return this.getMCPConnection(id);\n  }\n\n  async deleteMCPConnection(id: string): Promise<boolean> {\n    const result = await db\n      .delete(mcpConnections)\n      .where(eq(mcpConnections.id, id));\n\n    return true;\n  }\n}\n\nexport const storage = new DatabaseStorage();\n","size_bytes":20633},"client/src/components/ui/alert.tsx":{"content":"import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst alertVariants = cva(\n  \"relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-background text-foreground\",\n        destructive:\n          \"border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nconst Alert = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>\n>(({ className, variant, ...props }, ref) => (\n  <div\n    ref={ref}\n    role=\"alert\"\n    className={cn(alertVariants({ variant }), className)}\n    {...props}\n  />\n))\nAlert.displayName = \"Alert\"\n\nconst AlertTitle = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLHeadingElement>\n>(({ className, ...props }, ref) => (\n  <h5\n    ref={ref}\n    className={cn(\"mb-1 font-medium leading-none tracking-tight\", className)}\n    {...props}\n  />\n))\nAlertTitle.displayName = \"AlertTitle\"\n\nconst AlertDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"text-sm [&_p]:leading-relaxed\", className)}\n    {...props}\n  />\n))\nAlertDescription.displayName = \"AlertDescription\"\n\nexport { Alert, AlertTitle, AlertDescription }\n","size_bytes":1584},"server/services/websocket.ts":{"content":"import { WebSocketServer, WebSocket } from \"ws\";\nimport type { Server } from \"http\";\nimport type {\n  WSMessage,\n  WSTaskUpdate,\n  WSLogAdded,\n  WSReasoningAdded,\n  WSDiffCreated,\n  WSRunnerStatus,\n  LogEntry,\n  ReasoningStep,\n  FileDiff,\n  TaskStatus,\n} from \"@shared/schema\";\n\ninterface WebSocketClient {\n  ws: WebSocket;\n  id: string;\n  subscribedTasks: Set<string>;\n  isAlive: boolean;\n  lastPing: number;\n}\n\nexport class WebSocketService {\n  private wss: WebSocketServer;\n  private clients: Map<string, WebSocketClient> = new Map();\n  private pingInterval: NodeJS.Timeout | null = null;\n  private readonly PING_INTERVAL = 30000;\n  private readonly PING_TIMEOUT = 5000;\n\n  constructor(server: Server) {\n    this.wss = new WebSocketServer({ \n      server,\n      path: \"/ws\",\n    });\n\n    this.setupWebSocketServer();\n    this.startPingInterval();\n  }\n\n  private setupWebSocketServer() {\n    this.wss.on(\"connection\", (ws: WebSocket) => {\n      const clientId = this.generateClientId();\n      const client: WebSocketClient = {\n        ws,\n        id: clientId,\n        subscribedTasks: new Set(),\n        isAlive: true,\n        lastPing: Date.now(),\n      };\n\n      this.clients.set(clientId, client);\n      console.log(`[WebSocket] Client connected: ${clientId}`);\n\n      ws.on(\"message\", (data: Buffer) => {\n        this.handleMessage(clientId, data);\n      });\n\n      ws.on(\"pong\", () => {\n        const client = this.clients.get(clientId);\n        if (client) {\n          client.isAlive = true;\n          client.lastPing = Date.now();\n        }\n      });\n\n      ws.on(\"close\", () => {\n        console.log(`[WebSocket] Client disconnected: ${clientId}`);\n        this.clients.delete(clientId);\n      });\n\n      ws.on(\"error\", (error) => {\n        console.error(`[WebSocket] Client error ${clientId}:`, error);\n        this.clients.delete(clientId);\n      });\n\n      this.sendMessage(ws, {\n        type: \"ping\",\n        timestamp: Date.now(),\n      });\n    });\n\n    this.wss.on(\"error\", (error) => {\n      console.error(\"[WebSocket] Server error:\", error);\n    });\n  }\n\n  private handleMessage(clientId: string, data: Buffer) {\n    try {\n      const message = JSON.parse(data.toString());\n      const client = this.clients.get(clientId);\n      \n      if (!client) return;\n\n      if (message.type === \"subscribe\" && message.taskId) {\n        client.subscribedTasks.add(message.taskId);\n        console.log(`[WebSocket] Client ${clientId} subscribed to task ${message.taskId}`);\n      } else if (message.type === \"unsubscribe\" && message.taskId) {\n        client.subscribedTasks.delete(message.taskId);\n        console.log(`[WebSocket] Client ${clientId} unsubscribed from task ${message.taskId}`);\n      } else if (message.type === \"pong\") {\n        client.isAlive = true;\n        client.lastPing = Date.now();\n      }\n    } catch (error) {\n      console.error(`[WebSocket] Error handling message from ${clientId}:`, error);\n    }\n  }\n\n  private startPingInterval() {\n    this.pingInterval = setInterval(() => {\n      this.clients.forEach((client, clientId) => {\n        if (!client.isAlive) {\n          console.log(`[WebSocket] Terminating inactive client: ${clientId}`);\n          client.ws.terminate();\n          this.clients.delete(clientId);\n          return;\n        }\n\n        client.isAlive = false;\n        client.ws.ping();\n        \n        this.sendMessage(client.ws, {\n          type: \"ping\",\n          timestamp: Date.now(),\n        });\n      });\n    }, this.PING_INTERVAL);\n  }\n\n  private generateClientId(): string {\n    return `client_${Date.now()}_${Math.random().toString(36).substring(7)}`;\n  }\n\n  private sendMessage(ws: WebSocket, message: WSMessage) {\n    if (ws.readyState === WebSocket.OPEN) {\n      try {\n        ws.send(JSON.stringify(message));\n      } catch (error) {\n        console.error(\"[WebSocket] Error sending message:\", error);\n      }\n    }\n  }\n\n  private broadcast(message: WSMessage, taskId?: string) {\n    this.clients.forEach((client) => {\n      if (!taskId || client.subscribedTasks.has(taskId) || client.subscribedTasks.size === 0) {\n        this.sendMessage(client.ws, message);\n      }\n    });\n  }\n\n  public broadcastTaskUpdate(\n    taskId: string,\n    status?: TaskStatus,\n    progress?: number,\n    updates?: Record<string, any>\n  ) {\n    const message: WSTaskUpdate = {\n      type: \"task_update\",\n      taskId,\n      status,\n      progress,\n      updates,\n    };\n    this.broadcast(message, taskId);\n  }\n\n  public broadcastLogAdded(taskId: string, log: LogEntry) {\n    const message: WSLogAdded = {\n      type: \"log_added\",\n      taskId,\n      log,\n    };\n    this.broadcast(message, taskId);\n  }\n\n  public broadcastReasoningAdded(taskId: string, step: ReasoningStep) {\n    const message: WSReasoningAdded = {\n      type: \"reasoning_added\",\n      taskId,\n      step,\n    };\n    this.broadcast(message, taskId);\n  }\n\n  public broadcastDiffCreated(taskId: string, diff: FileDiff) {\n    const message: WSDiffCreated = {\n      type: \"diff_created\",\n      taskId,\n      diff,\n    };\n    this.broadcast(message, taskId);\n  }\n\n  public broadcastRunnerStatus(\n    taskId: string,\n    runnerId: string,\n    status: string,\n    metadata?: Record<string, any>\n  ) {\n    const message: WSRunnerStatus = {\n      type: \"runner_status\",\n      taskId,\n      runnerId,\n      status,\n      metadata,\n    };\n    this.broadcast(message, taskId);\n  }\n\n  public getConnectedClients(): number {\n    return this.clients.size;\n  }\n\n  public getClientsByTask(taskId: string): number {\n    let count = 0;\n    this.clients.forEach((client) => {\n      if (client.subscribedTasks.has(taskId)) {\n        count++;\n      }\n    });\n    return count;\n  }\n\n  public close() {\n    if (this.pingInterval) {\n      clearInterval(this.pingInterval);\n    }\n    \n    this.clients.forEach((client) => {\n      client.ws.close();\n    });\n    \n    this.wss.close();\n    console.log(\"[WebSocket] Server closed\");\n  }\n}\n","size_bytes":5921},"server/storage.ts":{"content":"import {\n  type Task,\n  type InsertTask,\n  type GithubEvent,\n  type InsertGithubEvent,\n  type Settings,\n  type LogEntry,\n  type ReasoningStep,\n  type FileDiff,\n  type RepositoryContext,\n  type InsertRepositoryContext,\n  type MCPConnection,\n  type InsertMCPConnection,\n} from \"@shared/schema\";\nimport { randomUUID } from \"crypto\";\n\nexport interface IStorage {\n  // Tasks\n  getTask(id: string): Promise<Task | undefined>;\n  getAllTasks(): Promise<Task[]>;\n  getActiveTasks(): Promise<Task[]>;\n  createTask(task: InsertTask): Promise<Task>;\n  updateTask(id: string, updates: Partial<Task>): Promise<Task | undefined>;\n  addTaskLog(taskId: string, log: LogEntry): Promise<void>;\n  addTaskReasoning(taskId: string, step: ReasoningStep): Promise<void>;\n  addTaskDiff(taskId: string, diff: FileDiff): Promise<void>;\n  \n  // Events\n  getEvent(id: string): Promise<GithubEvent | undefined>;\n  getAllEvents(): Promise<GithubEvent[]>;\n  getRecentEvents(limit: number): Promise<GithubEvent[]>;\n  createEvent(event: InsertGithubEvent): Promise<GithubEvent>;\n  updateEvent(id: string, updates: Partial<GithubEvent>): Promise<GithubEvent | undefined>;\n  \n  // Settings\n  getSettings(): Promise<Settings | undefined>;\n  updateSettings(settings: Partial<Settings>): Promise<Settings>;\n  \n  // Repository Contexts\n  getRepositoryContext(repository: string): Promise<RepositoryContext | undefined>;\n  createRepositoryContext(context: InsertRepositoryContext): Promise<RepositoryContext>;\n  updateRepositoryContext(repository: string, updates: Partial<RepositoryContext>): Promise<RepositoryContext | undefined>;\n  \n  // MCP Connections\n  getMCPConnection(id: string): Promise<MCPConnection | undefined>;\n  getAllMCPConnections(): Promise<MCPConnection[]>;\n  createMCPConnection(connection: InsertMCPConnection): Promise<MCPConnection>;\n  updateMCPConnection(id: string, updates: Partial<MCPConnection>): Promise<MCPConnection | undefined>;\n  deleteMCPConnection(id: string): Promise<boolean>;\n}\n\nexport class MemStorage implements IStorage {\n  private tasks: Map<string, Task>;\n  private events: Map<string, GithubEvent>;\n  private settings: Settings | undefined;\n  private repositoryContexts: Map<string, RepositoryContext>;\n  private mcpConnections: Map<string, MCPConnection>;\n\n  constructor() {\n    this.tasks = new Map();\n    this.events = new Map();\n    this.repositoryContexts = new Map();\n    this.mcpConnections = new Map();\n  }\n\n  // Tasks\n  async getTask(id: string): Promise<Task | undefined> {\n    return this.tasks.get(id);\n  }\n\n  async getAllTasks(): Promise<Task[]> {\n    return Array.from(this.tasks.values());\n  }\n\n  async getActiveTasks(): Promise<Task[]> {\n    return Array.from(this.tasks.values()).filter(\n      (task) => task.status === \"planning\" || task.status === \"executing\" || task.status === \"queued\"\n    );\n  }\n\n  async createTask(insertTask: InsertTask): Promise<Task> {\n    const id = randomUUID();\n    const now = new Date().toISOString();\n    const task: Task = {\n      ...insertTask,\n      id,\n      createdAt: now,\n      updatedAt: now,\n      logs: [],\n      reasoning: [],\n      diffs: [],\n    };\n    this.tasks.set(id, task);\n    return task;\n  }\n\n  async updateTask(id: string, updates: Partial<Task>): Promise<Task | undefined> {\n    const task = this.tasks.get(id);\n    if (!task) return undefined;\n\n    const updatedTask = {\n      ...task,\n      ...updates,\n      updatedAt: new Date().toISOString(),\n    };\n    this.tasks.set(id, updatedTask);\n    return updatedTask;\n  }\n\n  async addTaskLog(taskId: string, log: LogEntry): Promise<void> {\n    const task = this.tasks.get(taskId);\n    if (task) {\n      task.logs.push(log);\n      task.updatedAt = new Date().toISOString();\n    }\n  }\n\n  async addTaskReasoning(taskId: string, step: ReasoningStep): Promise<void> {\n    const task = this.tasks.get(taskId);\n    if (task) {\n      task.reasoning.push(step);\n      task.updatedAt = new Date().toISOString();\n    }\n  }\n\n  async addTaskDiff(taskId: string, diff: FileDiff): Promise<void> {\n    const task = this.tasks.get(taskId);\n    if (task) {\n      task.diffs.push(diff);\n      task.updatedAt = new Date().toISOString();\n    }\n  }\n\n  // Events\n  async getEvent(id: string): Promise<GithubEvent | undefined> {\n    return this.events.get(id);\n  }\n\n  async getAllEvents(): Promise<GithubEvent[]> {\n    return Array.from(this.events.values());\n  }\n\n  async getRecentEvents(limit: number): Promise<GithubEvent[]> {\n    const events = Array.from(this.events.values());\n    return events\n      .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())\n      .slice(0, limit);\n  }\n\n  async createEvent(insertEvent: InsertGithubEvent): Promise<GithubEvent> {\n    const id = randomUUID();\n    const event: GithubEvent = {\n      ...insertEvent,\n      id,\n      timestamp: new Date().toISOString(),\n    };\n    this.events.set(id, event);\n    return event;\n  }\n\n  async updateEvent(id: string, updates: Partial<GithubEvent>): Promise<GithubEvent | undefined> {\n    const event = this.events.get(id);\n    if (!event) return undefined;\n\n    const updatedEvent = {\n      ...event,\n      ...updates,\n    };\n    this.events.set(id, updatedEvent);\n    return updatedEvent;\n  }\n\n  // Settings\n  async getSettings(): Promise<Settings | undefined> {\n    return this.settings;\n  }\n\n  async updateSettings(updates: Partial<Settings>): Promise<Settings> {\n    this.settings = {\n      ...this.settings,\n      ...updates,\n    } as Settings;\n    return this.settings;\n  }\n\n  // Repository Contexts\n  async getRepositoryContext(repository: string): Promise<RepositoryContext | undefined> {\n    return this.repositoryContexts.get(repository);\n  }\n\n  async createRepositoryContext(insertContext: InsertRepositoryContext): Promise<RepositoryContext> {\n    const id = randomUUID();\n    const now = new Date().toISOString();\n    const context: RepositoryContext = {\n      ...insertContext,\n      id,\n      createdAt: now,\n      updatedAt: now,\n    };\n    this.repositoryContexts.set(insertContext.repository, context);\n    return context;\n  }\n\n  async updateRepositoryContext(repository: string, updates: Partial<RepositoryContext>): Promise<RepositoryContext | undefined> {\n    const context = this.repositoryContexts.get(repository);\n    if (!context) return undefined;\n\n    const updatedContext = {\n      ...context,\n      ...updates,\n      updatedAt: new Date().toISOString(),\n    };\n    this.repositoryContexts.set(repository, updatedContext);\n    return updatedContext;\n  }\n\n  // MCP Connections\n  async getMCPConnection(id: string): Promise<MCPConnection | undefined> {\n    return this.mcpConnections.get(id);\n  }\n\n  async getAllMCPConnections(): Promise<MCPConnection[]> {\n    return Array.from(this.mcpConnections.values());\n  }\n\n  async createMCPConnection(insertConnection: InsertMCPConnection): Promise<MCPConnection> {\n    const id = randomUUID();\n    const connection: MCPConnection = {\n      ...insertConnection,\n      id,\n      createdAt: new Date().toISOString(),\n    };\n    this.mcpConnections.set(id, connection);\n    return connection;\n  }\n\n  async updateMCPConnection(id: string, updates: Partial<MCPConnection>): Promise<MCPConnection | undefined> {\n    const connection = this.mcpConnections.get(id);\n    if (!connection) return undefined;\n\n    const updatedConnection = {\n      ...connection,\n      ...updates,\n    };\n    this.mcpConnections.set(id, updatedConnection);\n    return updatedConnection;\n  }\n\n  async deleteMCPConnection(id: string): Promise<boolean> {\n    return this.mcpConnections.delete(id);\n  }\n}\n\nexport const storage = new MemStorage();\n","size_bytes":7591},"server/services/ai.ts":{"content":"import type { AISettings, Task, ReasoningStep, FileDiff, DiffLine, MCPTool } from \"@shared/schema\";\nimport type { IStorage } from \"../storage\";\nimport { DiffService } from \"./diff\";\nimport { AIProviderManager, type ChatMessage } from \"./ai-provider-manager\";\nimport type { MCPClientManager } from \"./mcp-client\";\n\ninterface ChatCompletionRequest {\n  model: string;\n  messages: ChatMessage[];\n  temperature?: number;\n  max_tokens?: number;\n}\n\ninterface ChatCompletionResponse {\n  choices: Array<{\n    message: {\n      content: string;\n    };\n  }>;\n}\n\nexport type TaskType = \n  | \"refactoring\" \n  | \"feature_creation\" \n  | \"debugging\" \n  | \"test_generation\" \n  | \"ux_validation\"\n  | \"code_review\"\n  | \"architecture_design\"\n  | \"dependency_update\"\n  | \"security_fix\";\n\nexport type ReasoningStrategy = \"analytical\" | \"creative\" | \"debugging\" | \"systematic\" | \"exploratory\";\n\ninterface RepositoryContext {\n  architecture?: string;\n  dependencies?: Record<string, string>;\n  fileStructure?: string[];\n  recentCommits?: string[];\n  openIssues?: string[];\n}\n\ninterface CodeContext {\n  filePath: string;\n  content: string;\n  language?: string;\n  relatedFiles?: Array<{ path: string; content: string }>;\n}\n\ninterface ConversationContext {\n  taskId: string;\n  messages: ChatMessage[];\n  reasoningHistory: ReasoningStep[];\n  metadata: Record<string, any>;\n}\n\ninterface PromptTemplate {\n  system: string;\n  userTemplate: (context: any) => string;\n  temperature: number;\n  maxTokens: number;\n}\n\nexport class AIService {\n  private settings: AISettings;\n  private storage?: IStorage;\n  private promptTemplates: Map<TaskType, PromptTemplate>;\n  private conversationContexts: Map<string, ConversationContext>;\n  private diffService: DiffService;\n  private providerManager?: AIProviderManager;\n  private mcpClientManager?: MCPClientManager;\n\n  constructor(settings: AISettings, storage?: IStorage, mcpClientManager?: MCPClientManager) {\n    this.settings = settings;\n    this.storage = storage;\n    this.mcpClientManager = mcpClientManager;\n    this.conversationContexts = new Map();\n    this.promptTemplates = this.initializePromptTemplates();\n    this.diffService = new DiffService();\n    \n    if (settings.providers && settings.providers.length > 0) {\n      this.providerManager = new AIProviderManager(\n        settings.providers,\n        settings.routing\n      );\n    }\n  }\n\n  updateSettings(settings: AISettings) {\n    this.settings = settings;\n    \n    if (settings.providers && settings.providers.length > 0) {\n      this.providerManager = new AIProviderManager(\n        settings.providers,\n        settings.routing\n      );\n    }\n  }\n\n  getProviderManager(): AIProviderManager | undefined {\n    return this.providerManager;\n  }\n\n  private initializePromptTemplates(): Map<TaskType, PromptTemplate> {\n    const templates = new Map<TaskType, PromptTemplate>();\n\n    templates.set(\"refactoring\", {\n      system: `You are an expert code refactoring specialist with deep knowledge of software design patterns, clean code principles, and best practices.\n\nYour approach:\n1. Analyze the existing code structure and identify code smells\n2. Consider SOLID principles and design patterns\n3. Ensure backward compatibility unless explicitly stated otherwise\n4. Maintain or improve performance\n5. Add clear documentation for significant changes\n\nThink step-by-step and explain your reasoning for each refactoring decision.`,\n      userTemplate: (ctx) => `\nTask: Refactor the following code\nContext: ${ctx.summary || \"Improve code quality and maintainability\"}\n\n${ctx.repositoryContext ? `Repository Architecture:\n${JSON.stringify(ctx.repositoryContext.architecture, null, 2)}\n\nDependencies:\n${JSON.stringify(ctx.repositoryContext.dependencies, null, 2)}\n` : ''}\n\nFile: ${ctx.filePath}\nCode:\n${ctx.code}\n\n${ctx.priorReasoning ? `Previous Analysis:\n${ctx.priorReasoning.map((r: ReasoningStep) => `- ${r.description} (confidence: ${r.confidence}%)`).join('\\n')}\n` : ''}\n\nProvide a detailed refactoring plan with reasoning for each change.`,\n      temperature: 0.3,\n      maxTokens: 4096,\n    });\n\n    templates.set(\"feature_creation\", {\n      system: `You are an expert software architect and developer specializing in feature design and implementation.\n\nYour approach:\n1. Understand the feature requirements thoroughly\n2. Design a scalable and maintainable architecture\n3. Consider edge cases and error handling\n4. Plan for testing and validation\n5. Ensure security best practices\n6. Think about user experience and API design\n\nUse chain-of-thought reasoning to break down complex features into manageable components.`,\n      userTemplate: (ctx) => `\nTask: ${ctx.title || \"Implement new feature\"}\nRequirements: ${ctx.summary}\n\n${ctx.repositoryContext ? `Current Architecture:\n${JSON.stringify(ctx.repositoryContext.architecture, null, 2)}\n\nExisting Dependencies:\n${JSON.stringify(ctx.repositoryContext.dependencies, null, 2)}\n\nFile Structure:\n${ctx.repositoryContext.fileStructure?.slice(0, 50).join('\\n') || 'Not available'}\n` : ''}\n\n${ctx.relatedCode ? `Related Code:\n${ctx.relatedCode.map((rc: any) => `File: ${rc.path}\\n${rc.content.substring(0, 500)}...`).join('\\n\\n')}\n` : ''}\n\nDesign and plan the implementation of this feature with detailed reasoning.`,\n      temperature: 0.7,\n      maxTokens: 6144,\n    });\n\n    templates.set(\"debugging\", {\n      system: `You are an expert debugger with exceptional analytical skills for identifying and fixing software bugs.\n\nYour debugging process:\n1. Analyze the error message and stack trace\n2. Identify the root cause, not just symptoms\n3. Consider edge cases and race conditions\n4. Check for common pitfalls (null references, off-by-one errors, etc.)\n5. Verify the fix doesn't introduce new issues\n6. Suggest preventive measures (tests, validation, etc.)\n\nThink systematically and explain each step of your reasoning.`,\n      userTemplate: (ctx) => `\nBug Report: ${ctx.title}\nDescription: ${ctx.summary}\n\n${ctx.errorLog ? `Error Log:\n${ctx.errorLog}\n` : ''}\n\n${ctx.stackTrace ? `Stack Trace:\n${ctx.stackTrace}\n` : ''}\n\nFile: ${ctx.filePath}\nCode:\n${ctx.code}\n\n${ctx.reproductionSteps ? `Steps to Reproduce:\n${ctx.reproductionSteps}\n` : ''}\n\n${ctx.priorAttempts ? `Previous Fix Attempts:\n${ctx.priorAttempts}\n` : ''}\n\nDiagnose the root cause and provide a comprehensive fix with reasoning.`,\n      temperature: 0.2,\n      maxTokens: 4096,\n    });\n\n    templates.set(\"test_generation\", {\n      system: `You are a test automation expert specializing in comprehensive test coverage and quality assurance.\n\nYour testing strategy:\n1. Identify all critical paths and edge cases\n2. Write tests for both happy paths and error conditions\n3. Ensure tests are maintainable and readable\n4. Follow testing best practices (AAA pattern, descriptive names, etc.)\n5. Consider integration and unit tests appropriately\n6. Aim for meaningful coverage, not just high percentages\n\nThink about what could go wrong and how to catch it early.`,\n      userTemplate: (ctx) => `\nGenerate tests for: ${ctx.title}\nContext: ${ctx.summary}\n\nCode to Test:\nFile: ${ctx.filePath}\n${ctx.code}\n\n${ctx.dependencies ? `Dependencies:\n${JSON.stringify(ctx.dependencies, null, 2)}\n` : ''}\n\n${ctx.existingTests ? `Existing Test Patterns:\n${ctx.existingTests}\n` : ''}\n\nCreate comprehensive test cases with clear reasoning for each test scenario.`,\n      temperature: 0.4,\n      maxTokens: 5120,\n    });\n\n    templates.set(\"ux_validation\", {\n      system: `You are a UX expert with deep understanding of user experience principles, accessibility, and usability best practices.\n\nYour evaluation criteria:\n1. User flow and navigation clarity\n2. Accessibility (WCAG compliance)\n3. Visual hierarchy and consistency\n4. Error prevention and recovery\n5. Performance and responsiveness\n6. Mobile and cross-platform compatibility\n\nThink from the user's perspective and identify potential friction points.`,\n      userTemplate: (ctx) => `\nValidate UX for: ${ctx.title}\nFeature Description: ${ctx.summary}\n\n${ctx.uiCode ? `UI Implementation:\n${ctx.uiCode}\n` : ''}\n\n${ctx.userFlows ? `User Flows:\n${ctx.userFlows}\n` : ''}\n\n${ctx.screenshots ? `Screenshots: ${ctx.screenshots.length} provided` : ''}\n\nAnalyze the user experience and provide detailed recommendations with reasoning.`,\n      temperature: 0.6,\n      maxTokens: 4096,\n    });\n\n    templates.set(\"code_review\", {\n      system: `You are a senior code reviewer with expertise in software quality, security, and best practices.\n\nReview checklist:\n1. Code quality and maintainability\n2. Security vulnerabilities\n3. Performance implications\n4. Error handling and edge cases\n5. Test coverage\n6. Documentation and comments\n7. Adherence to project conventions\n\nBe constructive and prioritize feedback by importance.`,\n      userTemplate: (ctx) => `\nReview Request: ${ctx.title}\nDescription: ${ctx.summary}\n\nChanged Files:\n${ctx.diffs?.map((d: any) => `${d.path}:\\n${d.content}`).join('\\n\\n')}\n\n${ctx.repositoryContext ? `Project Context:\nArchitecture: ${JSON.stringify(ctx.repositoryContext.architecture, null, 2)}\n` : ''}\n\nProvide a thorough code review with reasoning for each comment.`,\n      temperature: 0.4,\n      maxTokens: 5120,\n    });\n\n    templates.set(\"architecture_design\", {\n      system: `You are a software architect specializing in scalable, maintainable system design.\n\nDesign principles:\n1. Modularity and separation of concerns\n2. Scalability and performance\n3. Security and data protection\n4. Testability and maintainability\n5. Technology stack alignment\n6. Cost-effectiveness\n\nThink holistically about the system and its future growth.`,\n      userTemplate: (ctx) => `\nArchitecture Design for: ${ctx.title}\nRequirements: ${ctx.summary}\n\n${ctx.constraints ? `Constraints:\n${ctx.constraints}\n` : ''}\n\n${ctx.existingArchitecture ? `Current Architecture:\n${ctx.existingArchitecture}\n` : ''}\n\n${ctx.scalingRequirements ? `Scaling Requirements:\n${ctx.scalingRequirements}\n` : ''}\n\nDesign a robust architecture with detailed reasoning for each decision.`,\n      temperature: 0.7,\n      maxTokens: 6144,\n    });\n\n    templates.set(\"dependency_update\", {\n      system: `You are a dependency management expert focused on keeping projects secure and up-to-date.\n\nUpdate strategy:\n1. Assess breaking changes\n2. Check for security vulnerabilities\n3. Evaluate performance improvements\n4. Review migration guides\n5. Plan incremental updates\n6. Consider transitive dependencies\n\nBalance stability with staying current.`,\n      userTemplate: (ctx) => `\nUpdate Dependencies for: ${ctx.repository}\n\nCurrent Dependencies:\n${JSON.stringify(ctx.currentDependencies, null, 2)}\n\n${ctx.availableUpdates ? `Available Updates:\n${JSON.stringify(ctx.availableUpdates, null, 2)}\n` : ''}\n\n${ctx.securityIssues ? `Security Issues:\n${ctx.securityIssues}\n` : ''}\n\nCreate an update plan with risk assessment and reasoning.`,\n      temperature: 0.3,\n      maxTokens: 4096,\n    });\n\n    templates.set(\"security_fix\", {\n      system: `You are a security expert specializing in identifying and fixing vulnerabilities.\n\nSecurity assessment:\n1. Identify vulnerability type and severity\n2. Understand the attack vector\n3. Design a secure fix\n4. Prevent similar issues\n5. Consider defense in depth\n6. Validate the fix thoroughly\n\nPrioritize security without breaking functionality.`,\n      userTemplate: (ctx) => `\nSecurity Issue: ${ctx.title}\nSeverity: ${ctx.severity || 'Unknown'}\nDescription: ${ctx.summary}\n\n${ctx.vulnerabilityDetails ? `Vulnerability Details:\n${ctx.vulnerabilityDetails}\n` : ''}\n\nAffected Code:\n${ctx.code}\n\n${ctx.cveId ? `CVE ID: ${ctx.cveId}` : ''}\n\nProvide a secure fix with comprehensive reasoning and preventive measures.`,\n      temperature: 0.2,\n      maxTokens: 4096,\n    });\n\n    return templates;\n  }\n\n  async analyzeCode(\n    code: string,\n    filePath: string,\n    taskType: TaskType = \"code_review\",\n    options: {\n      language?: string;\n      focusAreas?: string[];\n      repositoryContext?: RepositoryContext;\n    } = {}\n  ): Promise<{\n    analysis: string;\n    suggestions: Array<{ line?: number; message: string; severity: \"info\" | \"warning\" | \"error\" }>;\n    metrics: { complexity?: number; maintainability?: number };\n  }> {\n    const systemPrompt = `You are an expert code analyzer. Analyze the provided code and return insights in JSON format:\n{\n  \"analysis\": \"Overall code analysis summary\",\n  \"suggestions\": [\n    { \"line\": 10, \"message\": \"Suggestion text\", \"severity\": \"warning\" }\n  ],\n  \"metrics\": {\n    \"complexity\": 5,\n    \"maintainability\": 8\n  }\n}`;\n\n    const userPrompt = `\nAnalyze this ${options.language || 'code'} file:\nPath: ${filePath}\n${options.focusAreas ? `Focus Areas: ${options.focusAreas.join(', ')}` : ''}\n\nCode:\n${code}\n\n${options.repositoryContext ? `Repository Context:\n${JSON.stringify(options.repositoryContext, null, 2)}\n` : ''}\n\nProvide detailed analysis with actionable suggestions.`;\n\n    const response = await this.callAPI({\n      model: this.settings.model,\n      messages: [\n        { role: \"system\", content: systemPrompt },\n        { role: \"user\", content: userPrompt },\n      ],\n      temperature: 0.3,\n      max_tokens: this.settings.maxTokens,\n    });\n\n    try {\n      const parsed = JSON.parse(response.choices[0].message.content);\n      return {\n        analysis: parsed.analysis || \"Code analysis completed\",\n        suggestions: parsed.suggestions || [],\n        metrics: parsed.metrics || {},\n      };\n    } catch (error) {\n      return {\n        analysis: response.choices[0].message.content,\n        suggestions: [],\n        metrics: {},\n      };\n    }\n  }\n\n  async understandArchitecture(\n    repositoryContext: RepositoryContext,\n    specificQuestions?: string[]\n  ): Promise<{\n    overview: string;\n    components: Array<{ name: string; purpose: string; dependencies: string[] }>;\n    dataFlow: string;\n    recommendations: string[];\n  }> {\n    const systemPrompt = `You are a software architecture expert. Analyze the repository and provide insights in JSON format:\n{\n  \"overview\": \"High-level architecture overview\",\n  \"components\": [\n    { \"name\": \"ComponentName\", \"purpose\": \"What it does\", \"dependencies\": [\"dep1\", \"dep2\"] }\n  ],\n  \"dataFlow\": \"Description of how data flows through the system\",\n  \"recommendations\": [\"Recommendation 1\", \"Recommendation 2\"]\n}`;\n\n    const userPrompt = `\nAnalyze this repository architecture:\n\n${repositoryContext.architecture ? `Architecture Documentation:\n${repositoryContext.architecture}\n` : ''}\n\nFile Structure:\n${repositoryContext.fileStructure?.slice(0, 100).join('\\n') || 'Not available'}\n\nDependencies:\n${JSON.stringify(repositoryContext.dependencies, null, 2)}\n\n${specificQuestions ? `Specific Questions:\n${specificQuestions.join('\\n')}\n` : ''}\n\nProvide a comprehensive architecture analysis.`;\n\n    const response = await this.callAPI({\n      model: this.settings.model,\n      messages: [\n        { role: \"system\", content: systemPrompt },\n        { role: \"user\", content: userPrompt },\n      ],\n      temperature: 0.5,\n      max_tokens: 6144,\n    });\n\n    try {\n      const parsed = JSON.parse(response.choices[0].message.content);\n      return {\n        overview: parsed.overview || \"Architecture overview\",\n        components: parsed.components || [],\n        dataFlow: parsed.dataFlow || \"Data flow not analyzed\",\n        recommendations: parsed.recommendations || [],\n      };\n    } catch (error) {\n      return {\n        overview: response.choices[0].message.content,\n        components: [],\n        dataFlow: \"Unable to analyze data flow\",\n        recommendations: [],\n      };\n    }\n  }\n\n  async mapDependencies(\n    code: string,\n    filePath: string,\n    repositoryContext?: RepositoryContext\n  ): Promise<{\n    imports: Array<{ module: string; items: string[]; type: \"internal\" | \"external\" }>;\n    exports: string[];\n    usedBy: string[];\n    graph: Record<string, string[]>;\n  }> {\n    const systemPrompt = `You are a dependency analysis expert. Analyze code dependencies and return in JSON format:\n{\n  \"imports\": [\n    { \"module\": \"@/lib/utils\", \"items\": [\"cn\", \"formatDate\"], \"type\": \"internal\" }\n  ],\n  \"exports\": [\"MyComponent\", \"helper\"],\n  \"usedBy\": [\"File1.tsx\", \"File2.tsx\"],\n  \"graph\": { \"utils\": [\"date\", \"string\"], \"date\": [] }\n}`;\n\n    const userPrompt = `\nAnalyze dependencies for:\nFile: ${filePath}\n\nCode:\n${code}\n\n${repositoryContext ? `Repository Context:\nFile Structure: ${repositoryContext.fileStructure?.slice(0, 50).join(', ')}\nDependencies: ${JSON.stringify(repositoryContext.dependencies, null, 2)}\n` : ''}\n\nMap all dependencies and their relationships.`;\n\n    const response = await this.callAPI({\n      model: this.settings.model,\n      messages: [\n        { role: \"system\", content: systemPrompt },\n        { role: \"user\", content: userPrompt },\n      ],\n      temperature: 0.2,\n      max_tokens: 4096,\n    });\n\n    try {\n      const parsed = JSON.parse(response.choices[0].message.content);\n      return {\n        imports: parsed.imports || [],\n        exports: parsed.exports || [],\n        usedBy: parsed.usedBy || [],\n        graph: parsed.graph || {},\n      };\n    } catch (error) {\n      return {\n        imports: [],\n        exports: [],\n        usedBy: [],\n        graph: {},\n      };\n    }\n  }\n\n  async detectBugs(\n    code: string,\n    filePath: string,\n    options: {\n      errorLog?: string;\n      stackTrace?: string;\n      language?: string;\n      testResults?: string;\n    } = {}\n  ): Promise<{\n    bugs: Array<{\n      type: string;\n      severity: \"low\" | \"medium\" | \"high\" | \"critical\";\n      location: { line: number; column?: number };\n      description: string;\n      fix: string;\n    }>;\n    rootCause?: string;\n    preventiveMeasures: string[];\n  }> {\n    const template = this.promptTemplates.get(\"debugging\");\n    if (!template) {\n      throw new Error(\"Debugging template not found\");\n    }\n\n    const context = {\n      title: \"Bug Detection\",\n      summary: \"Analyze code for potential bugs and issues\",\n      filePath,\n      code,\n      errorLog: options.errorLog,\n      stackTrace: options.stackTrace,\n    };\n\n    const systemPrompt = `${template.system}\n\nAdditionally, return results in JSON format:\n{\n  \"bugs\": [\n    {\n      \"type\": \"NullPointerException\",\n      \"severity\": \"high\",\n      \"location\": { \"line\": 42, \"column\": 10 },\n      \"description\": \"Detailed description\",\n      \"fix\": \"Suggested fix\"\n    }\n  ],\n  \"rootCause\": \"Explanation of the underlying issue\",\n  \"preventiveMeasures\": [\"Add null checks\", \"Write tests\"]\n}`;\n\n    const response = await this.callAPI({\n      model: this.settings.model,\n      messages: [\n        { role: \"system\", content: systemPrompt },\n        { role: \"user\", content: template.userTemplate(context) },\n      ],\n      temperature: template.temperature,\n      max_tokens: template.maxTokens,\n    });\n\n    try {\n      const parsed = JSON.parse(response.choices[0].message.content);\n      return {\n        bugs: parsed.bugs || [],\n        rootCause: parsed.rootCause,\n        preventiveMeasures: parsed.preventiveMeasures || [],\n      };\n    } catch (error) {\n      return {\n        bugs: [],\n        rootCause: \"Unable to determine root cause\",\n        preventiveMeasures: [],\n      };\n    }\n  }\n\n  async reasonWithChainOfThought(\n    taskId: string,\n    prompt: string,\n    context: {\n      taskType?: TaskType;\n      strategy?: ReasoningStrategy;\n      priorSteps?: ReasoningStep[];\n      repositoryContext?: RepositoryContext;\n      codeContext?: CodeContext;\n    } = {}\n  ): Promise<{\n    reasoning: ReasoningStep[];\n    conclusion: string;\n    nextSteps: string[];\n  }> {\n    const strategy = context.strategy || \"analytical\";\n    const taskType = context.taskType || \"code_review\";\n\n    const systemPrompt = `You are an AI agent using ${strategy} reasoning to solve problems.\n\nChain-of-thought process:\n1. Break down the problem into smaller sub-problems\n2. Reason through each step explicitly\n3. Show your work and confidence levels\n4. Build upon previous conclusions\n5. Arrive at a well-reasoned solution\n\nFor each reasoning step, think aloud and explain your logic.\n\nReturn results in JSON format:\n{\n  \"reasoning\": [\n    {\n      \"id\": \"step-1\",\n      \"timestamp\": \"2024-01-01T00:00:00Z\",\n      \"description\": \"First, I analyze...\",\n      \"confidence\": 85,\n      \"completed\": true\n    }\n  ],\n  \"conclusion\": \"Based on the reasoning above...\",\n  \"nextSteps\": [\"Step 1\", \"Step 2\"]\n}`;\n\n    const contextInfo = [];\n    if (context.priorSteps && context.priorSteps.length > 0) {\n      contextInfo.push(`Prior Reasoning Steps:\n${context.priorSteps.map((s, i) => `${i + 1}. ${s.description} (confidence: ${s.confidence}%)`).join('\\n')}`);\n    }\n\n    if (context.repositoryContext) {\n      contextInfo.push(`Repository Architecture:\n${JSON.stringify(context.repositoryContext.architecture, null, 2)}`);\n    }\n\n    if (context.codeContext) {\n      contextInfo.push(`Code Context:\nFile: ${context.codeContext.filePath}\nLanguage: ${context.codeContext.language || 'unknown'}\n\nCode:\n${context.codeContext.content}`);\n\n      if (context.codeContext.relatedFiles) {\n        contextInfo.push(`Related Files:\n${context.codeContext.relatedFiles.map((f) => `- ${f.path}`).join('\\n')}`);\n      }\n    }\n\n    const userPrompt = `\nTask: ${prompt}\nTask Type: ${taskType}\nReasoning Strategy: ${strategy}\n\n${contextInfo.join('\\n\\n')}\n\nUse chain-of-thought reasoning to solve this task. Show each step of your thinking process.`;\n\n    const response = await this.callAPI({\n      model: this.settings.model,\n      messages: [\n        { role: \"system\", content: systemPrompt },\n        { role: \"user\", content: userPrompt },\n      ],\n      temperature: strategy === \"creative\" ? 0.8 : strategy === \"debugging\" ? 0.2 : 0.5,\n      max_tokens: 8192,\n    });\n\n    try {\n      const parsed = JSON.parse(response.choices[0].message.content);\n      const reasoning = parsed.reasoning || [];\n\n      if (this.storage && taskId) {\n        for (const step of reasoning) {\n          await this.storage.addTaskReasoning(taskId, step);\n        }\n      }\n\n      return {\n        reasoning,\n        conclusion: parsed.conclusion || \"Reasoning completed\",\n        nextSteps: parsed.nextSteps || [],\n      };\n    } catch (error) {\n      console.error(\"Failed to parse chain-of-thought response:\", error);\n      return {\n        reasoning: [],\n        conclusion: response.choices[0].message.content,\n        nextSteps: [],\n      };\n    }\n  }\n\n  async executeTaskWithReasoning(\n    taskId: string,\n    taskType: TaskType,\n    context: any,\n    strategy: ReasoningStrategy = \"analytical\"\n  ): Promise<{\n    result: any;\n    reasoning: ReasoningStep[];\n    confidence: number;\n  }> {\n    const template = this.promptTemplates.get(taskType);\n    if (!template) {\n      throw new Error(`Template not found for task type: ${taskType}`);\n    }\n\n    const task = this.storage ? await this.storage.getTask(taskId) : undefined;\n    const priorReasoning = task?.reasoning || [];\n\n    const enrichedContext = {\n      ...context,\n      priorReasoning,\n      taskType,\n      strategy,\n    };\n\n    const systemPrompt = `${template.system}\n\nUse ${strategy} reasoning and return detailed results with your reasoning process in JSON format.\nInclude a \"reasoning\" array with each step of your thought process.`;\n\n    const response = await this.callAPI({\n      model: this.settings.model,\n      messages: [\n        { role: \"system\", content: systemPrompt },\n        { role: \"user\", content: template.userTemplate(enrichedContext) },\n      ],\n      temperature: template.temperature,\n      max_tokens: template.maxTokens,\n    });\n\n    try {\n      const parsed = JSON.parse(response.choices[0].message.content);\n      \n      const reasoning: ReasoningStep[] = parsed.reasoning || [];\n      if (this.storage && taskId && reasoning.length > 0) {\n        for (const step of reasoning) {\n          await this.storage.addTaskReasoning(taskId, step);\n        }\n      }\n\n      return {\n        result: parsed,\n        reasoning,\n        confidence: parsed.confidence || 80,\n      };\n    } catch (error) {\n      console.error(\"Failed to parse task execution response:\", error);\n      return {\n        result: { content: response.choices[0].message.content },\n        reasoning: [],\n        confidence: 50,\n      };\n    }\n  }\n\n  async continueConversation(\n    taskId: string,\n    message: string,\n    options: {\n      includeContext?: boolean;\n      repositoryContext?: RepositoryContext;\n      codeContext?: CodeContext;\n    } = {}\n  ): Promise<{\n    response: string;\n    reasoning?: ReasoningStep[];\n  }> {\n    let conversation = this.conversationContexts.get(taskId);\n    \n    if (!conversation) {\n      const task = this.storage ? await this.storage.getTask(taskId) : undefined;\n      conversation = {\n        taskId,\n        messages: [],\n        reasoningHistory: task?.reasoning || [],\n        metadata: {},\n      };\n      this.conversationContexts.set(taskId, conversation);\n    }\n\n    const contextMessages: ChatMessage[] = [];\n    \n    if (options.includeContext && conversation.reasoningHistory.length > 0) {\n      const contextSummary = `Previous reasoning steps:\\n${\n        conversation.reasoningHistory\n          .slice(-5)\n          .map((s) => `- ${s.description}`)\n          .join('\\n')\n      }`;\n      contextMessages.push({ role: \"assistant\", content: contextSummary });\n    }\n\n    if (options.repositoryContext) {\n      contextMessages.push({\n        role: \"system\",\n        content: `Repository context: ${JSON.stringify(options.repositoryContext, null, 2)}`,\n      });\n    }\n\n    if (options.codeContext) {\n      contextMessages.push({\n        role: \"system\",\n        content: `Current code context:\\nFile: ${options.codeContext.filePath}\\n\\n${options.codeContext.content}`,\n      });\n    }\n\n    conversation.messages.push({ role: \"user\", content: message });\n\n    const allMessages = [\n      {\n        role: \"system\" as const,\n        content: \"You are an expert AI development assistant. Provide clear, actionable responses.\",\n      },\n      ...contextMessages,\n      ...conversation.messages.slice(-10),\n    ];\n\n    const response = await this.callAPI({\n      model: this.settings.model,\n      messages: allMessages,\n      temperature: 0.6,\n      max_tokens: this.settings.maxTokens,\n    });\n\n    const assistantMessage = response.choices[0].message.content;\n    conversation.messages.push({ role: \"assistant\", content: assistantMessage });\n\n    return {\n      response: assistantMessage,\n    };\n  }\n\n  clearConversationContext(taskId: string): void {\n    this.conversationContexts.delete(taskId);\n  }\n\n  // Backward compatible methods\n\n  async generateTaskPlan(\n    eventType: string,\n    repository: string,\n    action: string,\n    payload: any\n  ): Promise<{\n    title: string;\n    summary: string;\n    steps: string[];\n  }> {\n    const systemPrompt = `You are an expert AI software development agent. Your role is to analyze GitHub repository events and create detailed, actionable development plans.\n\nWhen given a repository event, you should:\n1. Understand the context and intent\n2. Identify what needs to be done\n3. Break down the work into clear steps\n4. Consider security, best practices, and testing\n\nRespond in JSON format with:\n{\n  \"title\": \"Brief task title\",\n  \"summary\": \"2-3 sentence summary of what needs to be done and why\",\n  \"steps\": [\"step 1\", \"step 2\", ...]\n}`;\n\n    const userPrompt = `Repository: ${repository}\nEvent Type: ${eventType}\nAction: ${action}\n\nEvent Details:\n${JSON.stringify(payload, null, 2)}\n\nCreate a development task plan for this GitHub event.`;\n\n    const response = await this.callAPI({\n      model: this.settings.model,\n      messages: [\n        { role: \"system\", content: systemPrompt },\n        { role: \"user\", content: userPrompt },\n      ],\n      temperature: this.settings.temperature,\n      max_tokens: this.settings.maxTokens,\n    });\n\n    try {\n      const content = response.choices[0].message.content;\n      const parsed = JSON.parse(content);\n      return {\n        title: parsed.title || \"Untitled Task\",\n        summary: parsed.summary || \"No summary provided\",\n        steps: parsed.steps || [],\n      };\n    } catch (error) {\n      console.error(\"Failed to parse AI response:\", error);\n      return {\n        title: `Handle ${eventType} event`,\n        summary: `Process ${action} in ${repository}`,\n        steps: [\"Analyze event\", \"Plan changes\", \"Execute modifications\"],\n      };\n    }\n  }\n\n  async generateCodeModifications(\n    task: Task,\n    fileContent: string,\n    filePath: string\n  ): Promise<string> {\n    const systemPrompt = `You are an expert code refactoring assistant. Your role is to analyze code and suggest improvements based on the given task.\n\nReturn ONLY the modified code, without any explanations or markdown formatting.`;\n\n    const userPrompt = `Task: ${task.title}\nContext: ${task.summary}\n\nFile: ${filePath}\nCurrent Code:\n${fileContent}\n\nProvide the improved code that addresses this task.`;\n\n    const response = await this.callAPI({\n      model: this.settings.model,\n      messages: [\n        { role: \"system\", content: systemPrompt },\n        { role: \"user\", content: userPrompt },\n      ],\n      temperature: 0.3,\n      max_tokens: this.settings.maxTokens,\n    });\n\n    return response.choices[0].message.content;\n  }\n\n  async generateCodeDiff(\n    task: Task,\n    fileContent: string,\n    filePath: string,\n    options: {\n      includeReasoning?: boolean;\n      repositoryContext?: RepositoryContext;\n    } = {}\n  ): Promise<FileDiff> {\n    const systemPrompt = `You are an expert code modification assistant. Your role is to analyze code and suggest precise improvements.\n\nReturn ONLY the modified code, without any explanations or markdown formatting.`;\n\n    const userPrompt = `Task: ${task.title}\nContext: ${task.summary}\n\n${options.repositoryContext ? `Repository Context:\nArchitecture: ${JSON.stringify(options.repositoryContext.architecture, null, 2)}\nDependencies: ${JSON.stringify(options.repositoryContext.dependencies, null, 2)}\n` : ''}\n\nFile: ${filePath}\nCurrent Code:\n${fileContent}\n\nProvide the improved code that addresses this task.`;\n\n    const response = await this.callAPI({\n      model: this.settings.model,\n      messages: [\n        { role: \"system\", content: systemPrompt },\n        { role: \"user\", content: userPrompt },\n      ],\n      temperature: 0.3,\n      max_tokens: this.settings.maxTokens,\n    });\n\n    const modifiedCode = response.choices[0].message.content;\n    const diff = this.diffService.generateDiff(fileContent, modifiedCode, filePath);\n\n    if (this.storage) {\n      await this.storage.addTaskDiff(task.id, diff);\n    }\n\n    return diff;\n  }\n\n  async generateCodeDiffWithReasoning(\n    task: Task,\n    fileContent: string,\n    filePath: string,\n    options: {\n      repositoryContext?: RepositoryContext;\n    } = {}\n  ): Promise<{\n    diff: FileDiff;\n    reasoning: Array<{\n      lineNumber: number;\n      changeType: \"add\" | \"remove\" | \"modify\";\n      reason: string;\n      confidence: number;\n    }>;\n  }> {\n    const systemPrompt = `You are an expert code modification assistant. Analyze code and suggest precise improvements with detailed reasoning.\n\nReturn your response in JSON format:\n{\n  \"modifiedCode\": \"The complete modified code\",\n  \"reasoning\": [\n    {\n      \"lineNumber\": 10,\n      \"changeType\": \"add\",\n      \"reason\": \"Added error handling to prevent crashes\",\n      \"confidence\": 95\n    }\n  ]\n}`;\n\n    const userPrompt = `Task: ${task.title}\nContext: ${task.summary}\n\n${options.repositoryContext ? `Repository Context:\nArchitecture: ${JSON.stringify(options.repositoryContext.architecture, null, 2)}\nDependencies: ${JSON.stringify(options.repositoryContext.dependencies, null, 2)}\n` : ''}\n\nFile: ${filePath}\nCurrent Code:\n${fileContent}\n\nProvide the improved code with reasoning for each change.`;\n\n    const response = await this.callAPI({\n      model: this.settings.model,\n      messages: [\n        { role: \"system\", content: systemPrompt },\n        { role: \"user\", content: userPrompt },\n      ],\n      temperature: 0.3,\n      max_tokens: this.settings.maxTokens,\n    });\n\n    try {\n      const parsed = JSON.parse(response.choices[0].message.content);\n      const modifiedCode = parsed.modifiedCode || response.choices[0].message.content;\n      const reasoning = parsed.reasoning || [];\n\n      const diff = this.diffService.generateDiff(fileContent, modifiedCode, filePath);\n\n      if (this.storage) {\n        await this.storage.addTaskDiff(task.id, diff);\n\n        for (const reason of reasoning) {\n          await this.storage.addTaskReasoning(task.id, {\n            id: `reasoning-${Date.now()}-${Math.random()}`,\n            timestamp: new Date().toISOString(),\n            description: `Line ${reason.lineNumber} (${reason.changeType}): ${reason.reason}`,\n            confidence: reason.confidence,\n            completed: true,\n          });\n        }\n      }\n\n      return {\n        diff,\n        reasoning,\n      };\n    } catch (error) {\n      const diff = this.diffService.generateDiff(fileContent, response.choices[0].message.content, filePath);\n      \n      if (this.storage) {\n        await this.storage.addTaskDiff(task.id, diff);\n      }\n\n      return {\n        diff,\n        reasoning: [],\n      };\n    }\n  }\n\n  async explainDiff(diff: FileDiff): Promise<{\n    summary: string;\n    changes: Array<{\n      type: \"add\" | \"remove\" | \"context\";\n      lineNumber: number;\n      explanation: string;\n    }>;\n  }> {\n    const diffString = this.diffService.formatDiffForDisplay(diff);\n    const stats = this.diffService.getDiffStatistics(diff);\n\n    const systemPrompt = `You are a code review expert. Analyze the provided diff and explain the changes clearly.\n\nReturn in JSON format:\n{\n  \"summary\": \"Overall summary of changes\",\n  \"changes\": [\n    {\n      \"type\": \"add\",\n      \"lineNumber\": 10,\n      \"explanation\": \"Added null check for safety\"\n    }\n  ]\n}`;\n\n    const userPrompt = `Analyze this code diff:\n\nFile: ${diff.path}\nStatistics: ${stats.additions} additions, ${stats.deletions} deletions\n\nDiff:\n${diffString}\n\nExplain the changes and their purpose.`;\n\n    const response = await this.callAPI({\n      model: this.settings.model,\n      messages: [\n        { role: \"system\", content: systemPrompt },\n        { role: \"user\", content: userPrompt },\n      ],\n      temperature: 0.5,\n      max_tokens: 2048,\n    });\n\n    try {\n      const parsed = JSON.parse(response.choices[0].message.content);\n      return {\n        summary: parsed.summary || \"Code changes analyzed\",\n        changes: parsed.changes || [],\n      };\n    } catch (error) {\n      return {\n        summary: response.choices[0].message.content,\n        changes: [],\n      };\n    }\n  }\n\n  async generateMultiFileDiffs(\n    task: Task,\n    files: Array<{ path: string; content: string }>,\n    options: {\n      repositoryContext?: RepositoryContext;\n    } = {}\n  ): Promise<FileDiff[]> {\n    const diffs: FileDiff[] = [];\n\n    for (const file of files) {\n      try {\n        const diff = await this.generateCodeDiff(task, file.content, file.path, options);\n        diffs.push(diff);\n      } catch (error) {\n        console.error(`Failed to generate diff for ${file.path}:`, error);\n      }\n    }\n\n    return diffs;\n  }\n\n  async validateDiffSafety(\n    diff: FileDiff,\n    originalContent: string\n  ): Promise<{\n    safe: boolean;\n    issues: string[];\n    warnings: string[];\n  }> {\n    const validation = this.diffService.validatePatch(originalContent, diff.lines);\n    \n    const systemPrompt = `You are a code safety validator. Analyze code changes for potential issues.\n\nReturn in JSON format:\n{\n  \"safe\": true,\n  \"issues\": [\"Critical issue 1\"],\n  \"warnings\": [\"Warning 1\"]\n}`;\n\n    const diffString = this.diffService.formatDiffForDisplay(diff);\n\n    const userPrompt = `Analyze this diff for safety:\n\nFile: ${diff.path}\nDiff:\n${diffString}\n\nOriginal:\n${originalContent}\n\nCheck for:\n- Breaking changes\n- Security vulnerabilities\n- Performance issues\n- Logic errors`;\n\n    const response = await this.callAPI({\n      model: this.settings.model,\n      messages: [\n        { role: \"system\", content: systemPrompt },\n        { role: \"user\", content: userPrompt },\n      ],\n      temperature: 0.2,\n      max_tokens: 2048,\n    });\n\n    try {\n      const parsed = JSON.parse(response.choices[0].message.content);\n      \n      const issues = [...validation.errors, ...(parsed.issues || [])];\n      \n      return {\n        safe: validation.valid && parsed.safe,\n        issues,\n        warnings: parsed.warnings || [],\n      };\n    } catch (error) {\n      return {\n        safe: validation.valid,\n        issues: validation.errors,\n        warnings: [],\n      };\n    }\n  }\n\n  async explainReasoning(\n    step: string,\n    context: string\n  ): Promise<{ description: string; confidence: number }> {\n    const systemPrompt = `You are explaining your reasoning process as an AI development agent. Be concise but clear.\n\nRespond in JSON format:\n{\n  \"description\": \"Brief explanation of this step\",\n  \"confidence\": 85\n}`;\n\n    const userPrompt = `Step: ${step}\nContext: ${context}\n\nExplain your reasoning for this step.`;\n\n    const response = await this.callAPI({\n      model: this.settings.model,\n      messages: [\n        { role: \"system\", content: systemPrompt },\n        { role: \"user\", content: userPrompt },\n      ],\n      temperature: 0.5,\n      max_tokens: 300,\n    });\n\n    try {\n      const parsed = JSON.parse(response.choices[0].message.content);\n      return {\n        description: parsed.description || step,\n        confidence: parsed.confidence || 80,\n      };\n    } catch {\n      return {\n        description: step,\n        confidence: 80,\n      };\n    }\n  }\n\n  private async callAPI(request: ChatCompletionRequest): Promise<ChatCompletionResponse> {\n    if (this.providerManager) {\n      try {\n        const response = await this.providerManager.chat({\n          messages: request.messages,\n          temperature: request.temperature,\n          max_tokens: request.max_tokens,\n          model: request.model,\n        });\n\n        return {\n          choices: [\n            {\n              message: {\n                content: response.content,\n              },\n            },\n          ],\n        };\n      } catch (error) {\n        console.error(\"Provider manager failed, falling back to direct API:\", error);\n      }\n    }\n\n    const endpoint = this.settings.apiEndpoint.endsWith(\"/chat/completions\")\n      ? this.settings.apiEndpoint\n      : `${this.settings.apiEndpoint}/chat/completions`;\n\n    const response = await fetch(endpoint, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${this.settings.apiKey}`,\n      },\n      body: JSON.stringify(request),\n    });\n\n    if (!response.ok) {\n      throw new Error(`AI API request failed: ${response.statusText}`);\n    }\n\n    return response.json();\n  }\n\n  setMCPClientManager(mcpClientManager: MCPClientManager): void {\n    this.mcpClientManager = mcpClientManager;\n  }\n\n  async getAvailableMCPTools(): Promise<Array<{ serverId: string; serverName: string; tools: MCPTool[] }>> {\n    if (!this.storage || !this.mcpClientManager) {\n      return [];\n    }\n\n    const connections = await this.storage.getAllMCPConnections();\n    const toolsByServer: Array<{ serverId: string; serverName: string; tools: MCPTool[] }> = [];\n\n    for (const connection of connections) {\n      if (connection.status !== \"connected\") {\n        continue;\n      }\n\n      const client = this.mcpClientManager.getClient(connection.id);\n      if (!client || !client.isInitialized()) {\n        continue;\n      }\n\n      try {\n        const tools = await client.listTools();\n        toolsByServer.push({\n          serverId: connection.id,\n          serverName: connection.name,\n          tools,\n        });\n      } catch (error) {\n        console.error(`Error fetching tools from ${connection.name}:`, error);\n      }\n    }\n\n    return toolsByServer;\n  }\n\n  async executeMCPTool(serverId: string, toolName: string, params?: Record<string, any>): Promise<any> {\n    if (!this.mcpClientManager) {\n      throw new Error(\"MCP Client Manager not configured\");\n    }\n\n    const client = this.mcpClientManager.getClient(serverId);\n    if (!client) {\n      throw new Error(`MCP server ${serverId} not found`);\n    }\n\n    if (!client.isInitialized()) {\n      throw new Error(`MCP server ${serverId} not initialized`);\n    }\n\n    const result = await client.callTool(toolName, params);\n\n    if (this.storage) {\n      await this.storage.updateMCPConnection(serverId, {\n        lastUsed: new Date().toISOString(),\n      });\n    }\n\n    return result;\n  }\n\n  async getMCPToolsDescription(): Promise<string> {\n    const toolsByServer = await this.getAvailableMCPTools();\n\n    if (toolsByServer.length === 0) {\n      return \"No MCP tools available.\";\n    }\n\n    let description = \"Available MCP Tools:\\n\\n\";\n\n    for (const serverTools of toolsByServer) {\n      description += `Server: ${serverTools.serverName} (${serverTools.serverId})\\n`;\n      description += `Tools:\\n`;\n\n      for (const tool of serverTools.tools) {\n        description += `  - ${tool.name}: ${tool.description}\\n`;\n        if (tool.inputSchema && Object.keys(tool.inputSchema).length > 0) {\n          description += `    Parameters: ${JSON.stringify(tool.inputSchema, null, 2)}\\n`;\n        }\n      }\n\n      description += \"\\n\";\n    }\n\n    description += `\\nTo execute an MCP tool, use the format:\\n`;\n    description += `{ \"action\": \"execute_mcp_tool\", \"serverId\": \"<server_id>\", \"toolName\": \"<tool_name>\", \"params\": { ... } }\\n`;\n\n    return description;\n  }\n\n  async executeTaskWithMCPTools(\n    taskId: string,\n    taskDescription: string,\n    taskType: TaskType = \"feature_creation\"\n  ): Promise<void> {\n    const mcpToolsDescription = await this.getMCPToolsDescription();\n\n    const systemPrompt = `You are an AI assistant with access to MCP (Model Context Protocol) tools.\n\n${mcpToolsDescription}\n\nWhen you need to use an MCP tool, respond with a JSON object in this format:\n{\n  \"action\": \"execute_mcp_tool\",\n  \"serverId\": \"<server_id>\",\n  \"toolName\": \"<tool_name>\",\n  \"params\": { ... },\n  \"reasoning\": \"Why you're using this tool\"\n}\n\nAfter receiving the tool result, continue with your task using the information provided.`;\n\n    const context = this.conversationContexts.get(taskId) || {\n      taskId,\n      messages: [],\n      reasoningHistory: [],\n      metadata: {},\n    };\n\n    context.messages.push({\n      role: \"system\",\n      content: systemPrompt,\n    });\n\n    context.messages.push({\n      role: \"user\",\n      content: `Task: ${taskDescription}\\n\\nPlease analyze this task and determine if you need to use any MCP tools to complete it.`,\n    });\n\n    this.conversationContexts.set(taskId, context);\n\n    let maxIterations = 10;\n    let iteration = 0;\n\n    while (iteration < maxIterations) {\n      iteration++;\n\n      const request: ChatCompletionRequest = {\n        model: this.settings.model,\n        messages: context.messages,\n        temperature: 0.7,\n        max_tokens: 4096,\n      };\n\n      const response = await this.callAPI(request);\n      const assistantMessage = response.choices[0].message.content;\n\n      context.messages.push({\n        role: \"assistant\",\n        content: assistantMessage,\n      });\n\n      try {\n        const parsedResponse = JSON.parse(assistantMessage);\n\n        if (parsedResponse.action === \"execute_mcp_tool\") {\n          const { serverId, toolName, params, reasoning } = parsedResponse;\n\n          if (this.storage) {\n            await this.storage.addTaskReasoning(taskId, {\n              id: randomUUID(),\n              timestamp: new Date().toISOString(),\n              description: `Executing MCP tool: ${toolName} - ${reasoning}`,\n              confidence: 85,\n              completed: false,\n            });\n          }\n\n          const toolResult = await this.executeMCPTool(serverId, toolName, params);\n\n          context.messages.push({\n            role: \"user\",\n            content: `Tool execution result:\\n${JSON.stringify(toolResult, null, 2)}\\n\\nPlease continue with the task using this information.`,\n          });\n\n          if (this.storage) {\n            await this.storage.addTaskLog(taskId, {\n              id: randomUUID(),\n              timestamp: new Date().toISOString(),\n              level: \"info\",\n              message: `MCP tool executed: ${toolName} on ${serverId}`,\n            });\n          }\n        } else if (parsedResponse.action === \"complete\") {\n          break;\n        }\n      } catch (error) {\n        break;\n      }\n    }\n\n    this.conversationContexts.set(taskId, context);\n  }\n}\n","size_bytes":44569},"client/src/components/ui/chart.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as RechartsPrimitive from \"recharts\"\n\nimport { cn } from \"@/lib/utils\"\n\n// Format: { THEME_NAME: CSS_SELECTOR }\nconst THEMES = { light: \"\", dark: \".dark\" } as const\n\nexport type ChartConfig = {\n  [k in string]: {\n    label?: React.ReactNode\n    icon?: React.ComponentType\n  } & (\n    | { color?: string; theme?: never }\n    | { color?: never; theme: Record<keyof typeof THEMES, string> }\n  )\n}\n\ntype ChartContextProps = {\n  config: ChartConfig\n}\n\nconst ChartContext = React.createContext<ChartContextProps | null>(null)\n\nfunction useChart() {\n  const context = React.useContext(ChartContext)\n\n  if (!context) {\n    throw new Error(\"useChart must be used within a <ChartContainer />\")\n  }\n\n  return context\n}\n\nconst ChartContainer = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & {\n    config: ChartConfig\n    children: React.ComponentProps<\n      typeof RechartsPrimitive.ResponsiveContainer\n    >[\"children\"]\n  }\n>(({ id, className, children, config, ...props }, ref) => {\n  const uniqueId = React.useId()\n  const chartId = `chart-${id || uniqueId.replace(/:/g, \"\")}`\n\n  return (\n    <ChartContext.Provider value={{ config }}>\n      <div\n        data-chart={chartId}\n        ref={ref}\n        className={cn(\n          \"flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none\",\n          className\n        )}\n        {...props}\n      >\n        <ChartStyle id={chartId} config={config} />\n        <RechartsPrimitive.ResponsiveContainer>\n          {children}\n        </RechartsPrimitive.ResponsiveContainer>\n      </div>\n    </ChartContext.Provider>\n  )\n})\nChartContainer.displayName = \"Chart\"\n\nconst ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {\n  const colorConfig = Object.entries(config).filter(\n    ([, config]) => config.theme || config.color\n  )\n\n  if (!colorConfig.length) {\n    return null\n  }\n\n  return (\n    <style\n      dangerouslySetInnerHTML={{\n        __html: Object.entries(THEMES)\n          .map(\n            ([theme, prefix]) => `\n${prefix} [data-chart=${id}] {\n${colorConfig\n  .map(([key, itemConfig]) => {\n    const color =\n      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||\n      itemConfig.color\n    return color ? `  --color-${key}: ${color};` : null\n  })\n  .join(\"\\n\")}\n}\n`\n          )\n          .join(\"\\n\"),\n      }}\n    />\n  )\n}\n\nconst ChartTooltip = RechartsPrimitive.Tooltip\n\nconst ChartTooltipContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &\n    React.ComponentProps<\"div\"> & {\n      hideLabel?: boolean\n      hideIndicator?: boolean\n      indicator?: \"line\" | \"dot\" | \"dashed\"\n      nameKey?: string\n      labelKey?: string\n    }\n>(\n  (\n    {\n      active,\n      payload,\n      className,\n      indicator = \"dot\",\n      hideLabel = false,\n      hideIndicator = false,\n      label,\n      labelFormatter,\n      labelClassName,\n      formatter,\n      color,\n      nameKey,\n      labelKey,\n    },\n    ref\n  ) => {\n    const { config } = useChart()\n\n    const tooltipLabel = React.useMemo(() => {\n      if (hideLabel || !payload?.length) {\n        return null\n      }\n\n      const [item] = payload\n      const key = `${labelKey || item?.dataKey || item?.name || \"value\"}`\n      const itemConfig = getPayloadConfigFromPayload(config, item, key)\n      const value =\n        !labelKey && typeof label === \"string\"\n          ? config[label as keyof typeof config]?.label || label\n          : itemConfig?.label\n\n      if (labelFormatter) {\n        return (\n          <div className={cn(\"font-medium\", labelClassName)}>\n            {labelFormatter(value, payload)}\n          </div>\n        )\n      }\n\n      if (!value) {\n        return null\n      }\n\n      return <div className={cn(\"font-medium\", labelClassName)}>{value}</div>\n    }, [\n      label,\n      labelFormatter,\n      payload,\n      hideLabel,\n      labelClassName,\n      config,\n      labelKey,\n    ])\n\n    if (!active || !payload?.length) {\n      return null\n    }\n\n    const nestLabel = payload.length === 1 && indicator !== \"dot\"\n\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          \"grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl\",\n          className\n        )}\n      >\n        {!nestLabel ? tooltipLabel : null}\n        <div className=\"grid gap-1.5\">\n          {payload.map((item, index) => {\n            const key = `${nameKey || item.name || item.dataKey || \"value\"}`\n            const itemConfig = getPayloadConfigFromPayload(config, item, key)\n            const indicatorColor = color || item.payload.fill || item.color\n\n            return (\n              <div\n                key={item.dataKey}\n                className={cn(\n                  \"flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground\",\n                  indicator === \"dot\" && \"items-center\"\n                )}\n              >\n                {formatter && item?.value !== undefined && item.name ? (\n                  formatter(item.value, item.name, item, index, item.payload)\n                ) : (\n                  <>\n                    {itemConfig?.icon ? (\n                      <itemConfig.icon />\n                    ) : (\n                      !hideIndicator && (\n                        <div\n                          className={cn(\n                            \"shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]\",\n                            {\n                              \"h-2.5 w-2.5\": indicator === \"dot\",\n                              \"w-1\": indicator === \"line\",\n                              \"w-0 border-[1.5px] border-dashed bg-transparent\":\n                                indicator === \"dashed\",\n                              \"my-0.5\": nestLabel && indicator === \"dashed\",\n                            }\n                          )}\n                          style={\n                            {\n                              \"--color-bg\": indicatorColor,\n                              \"--color-border\": indicatorColor,\n                            } as React.CSSProperties\n                          }\n                        />\n                      )\n                    )}\n                    <div\n                      className={cn(\n                        \"flex flex-1 justify-between leading-none\",\n                        nestLabel ? \"items-end\" : \"items-center\"\n                      )}\n                    >\n                      <div className=\"grid gap-1.5\">\n                        {nestLabel ? tooltipLabel : null}\n                        <span className=\"text-muted-foreground\">\n                          {itemConfig?.label || item.name}\n                        </span>\n                      </div>\n                      {item.value && (\n                        <span className=\"font-mono font-medium tabular-nums text-foreground\">\n                          {item.value.toLocaleString()}\n                        </span>\n                      )}\n                    </div>\n                  </>\n                )}\n              </div>\n            )\n          })}\n        </div>\n      </div>\n    )\n  }\n)\nChartTooltipContent.displayName = \"ChartTooltip\"\n\nconst ChartLegend = RechartsPrimitive.Legend\n\nconst ChartLegendContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> &\n    Pick<RechartsPrimitive.LegendProps, \"payload\" | \"verticalAlign\"> & {\n      hideIcon?: boolean\n      nameKey?: string\n    }\n>(\n  (\n    { className, hideIcon = false, payload, verticalAlign = \"bottom\", nameKey },\n    ref\n  ) => {\n    const { config } = useChart()\n\n    if (!payload?.length) {\n      return null\n    }\n\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          \"flex items-center justify-center gap-4\",\n          verticalAlign === \"top\" ? \"pb-3\" : \"pt-3\",\n          className\n        )}\n      >\n        {payload.map((item) => {\n          const key = `${nameKey || item.dataKey || \"value\"}`\n          const itemConfig = getPayloadConfigFromPayload(config, item, key)\n\n          return (\n            <div\n              key={item.value}\n              className={cn(\n                \"flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground\"\n              )}\n            >\n              {itemConfig?.icon && !hideIcon ? (\n                <itemConfig.icon />\n              ) : (\n                <div\n                  className=\"h-2 w-2 shrink-0 rounded-[2px]\"\n                  style={{\n                    backgroundColor: item.color,\n                  }}\n                />\n              )}\n              {itemConfig?.label}\n            </div>\n          )\n        })}\n      </div>\n    )\n  }\n)\nChartLegendContent.displayName = \"ChartLegend\"\n\n// Helper to extract item config from a payload.\nfunction getPayloadConfigFromPayload(\n  config: ChartConfig,\n  payload: unknown,\n  key: string\n) {\n  if (typeof payload !== \"object\" || payload === null) {\n    return undefined\n  }\n\n  const payloadPayload =\n    \"payload\" in payload &&\n    typeof payload.payload === \"object\" &&\n    payload.payload !== null\n      ? payload.payload\n      : undefined\n\n  let configLabelKey: string = key\n\n  if (\n    key in payload &&\n    typeof payload[key as keyof typeof payload] === \"string\"\n  ) {\n    configLabelKey = payload[key as keyof typeof payload] as string\n  } else if (\n    payloadPayload &&\n    key in payloadPayload &&\n    typeof payloadPayload[key as keyof typeof payloadPayload] === \"string\"\n  ) {\n    configLabelKey = payloadPayload[\n      key as keyof typeof payloadPayload\n    ] as string\n  }\n\n  return configLabelKey in config\n    ? config[configLabelKey]\n    : config[key as keyof typeof config]\n}\n\nexport {\n  ChartContainer,\n  ChartTooltip,\n  ChartTooltipContent,\n  ChartLegend,\n  ChartLegendContent,\n  ChartStyle,\n}\n","size_bytes":10481},"client/src/components/ui/progress.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as ProgressPrimitive from \"@radix-ui/react-progress\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Progress = React.forwardRef<\n  React.ElementRef<typeof ProgressPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>\n>(({ className, value, ...props }, ref) => (\n  <ProgressPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative h-4 w-full overflow-hidden rounded-full bg-secondary\",\n      className\n    )}\n    {...props}\n  >\n    <ProgressPrimitive.Indicator\n      className=\"h-full w-full flex-1 bg-primary transition-all\"\n      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}\n    />\n  </ProgressPrimitive.Root>\n))\nProgress.displayName = ProgressPrimitive.Root.displayName\n\nexport { Progress }\n","size_bytes":791},"client/src/components/ui/drawer.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport { Drawer as DrawerPrimitive } from \"vaul\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Drawer = ({\n  shouldScaleBackground = true,\n  ...props\n}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (\n  <DrawerPrimitive.Root\n    shouldScaleBackground={shouldScaleBackground}\n    {...props}\n  />\n)\nDrawer.displayName = \"Drawer\"\n\nconst DrawerTrigger = DrawerPrimitive.Trigger\n\nconst DrawerPortal = DrawerPrimitive.Portal\n\nconst DrawerClose = DrawerPrimitive.Close\n\nconst DrawerOverlay = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <DrawerPrimitive.Overlay\n    ref={ref}\n    className={cn(\"fixed inset-0 z-50 bg-black/80\", className)}\n    {...props}\n  />\n))\nDrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName\n\nconst DrawerContent = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <DrawerPortal>\n    <DrawerOverlay />\n    <DrawerPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background\",\n        className\n      )}\n      {...props}\n    >\n      <div className=\"mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted\" />\n      {children}\n    </DrawerPrimitive.Content>\n  </DrawerPortal>\n))\nDrawerContent.displayName = \"DrawerContent\"\n\nconst DrawerHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\"grid gap-1.5 p-4 text-center sm:text-left\", className)}\n    {...props}\n  />\n)\nDrawerHeader.displayName = \"DrawerHeader\"\n\nconst DrawerFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\"mt-auto flex flex-col gap-2 p-4\", className)}\n    {...props}\n  />\n)\nDrawerFooter.displayName = \"DrawerFooter\"\n\nconst DrawerTitle = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <DrawerPrimitive.Title\n    ref={ref}\n    className={cn(\n      \"text-lg font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nDrawerTitle.displayName = DrawerPrimitive.Title.displayName\n\nconst DrawerDescription = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <DrawerPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nDrawerDescription.displayName = DrawerPrimitive.Description.displayName\n\nexport {\n  Drawer,\n  DrawerPortal,\n  DrawerOverlay,\n  DrawerTrigger,\n  DrawerClose,\n  DrawerContent,\n  DrawerHeader,\n  DrawerFooter,\n  DrawerTitle,\n  DrawerDescription,\n}\n","size_bytes":3021},"vite.config.ts":{"content":"import { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\nimport path from \"path\";\nimport runtimeErrorOverlay from \"@replit/vite-plugin-runtime-error-modal\";\n\nexport default defineConfig({\n  plugins: [\n    react(),\n    runtimeErrorOverlay(),\n    ...(process.env.NODE_ENV !== \"production\" &&\n    process.env.REPL_ID !== undefined\n      ? [\n          await import(\"@replit/vite-plugin-cartographer\").then((m) =>\n            m.cartographer(),\n          ),\n          await import(\"@replit/vite-plugin-dev-banner\").then((m) =>\n            m.devBanner(),\n          ),\n        ]\n      : []),\n  ],\n  resolve: {\n    alias: {\n      \"@\": path.resolve(import.meta.dirname, \"client\", \"src\"),\n      \"@shared\": path.resolve(import.meta.dirname, \"shared\"),\n      \"@assets\": path.resolve(import.meta.dirname, \"attached_assets\"),\n    },\n  },\n  root: path.resolve(import.meta.dirname, \"client\"),\n  build: {\n    outDir: path.resolve(import.meta.dirname, \"dist/public\"),\n    emptyOutDir: true,\n  },\n  server: {\n    fs: {\n      strict: true,\n      deny: [\"**/.*\"],\n    },\n  },\n});\n","size_bytes":1080},"server/services/diff.ts":{"content":"import type { FileDiff, DiffLine } from \"@shared/schema\";\n\ninterface ValidationResult {\n  valid: boolean;\n  errors: string[];\n}\n\ninterface DiffChange {\n  type: \"add\" | \"remove\" | \"context\";\n  lineNumber: number;\n  content: string;\n  reasoning?: string;\n  confidence?: number;\n}\n\nexport class DiffService {\n  private contextLines: number = 3;\n\n  constructor(contextLines: number = 3) {\n    this.contextLines = contextLines;\n  }\n\n  generateDiff(\n    original: string,\n    modified: string,\n    filePath: string,\n    reasoning?: Map<number, { reason: string; confidence: number }>\n  ): FileDiff {\n    const originalLines = original.split(\"\\n\");\n    const modifiedLines = modified.split(\"\\n\");\n    \n    const changes = this.computeDiff(originalLines, modifiedLines);\n    const diffLines = this.createUnifiedDiff(changes, originalLines, modifiedLines, reasoning);\n\n    return {\n      path: filePath,\n      lines: diffLines,\n    };\n  }\n\n  applyPatch(\n    original: string,\n    patch: DiffLine[],\n    filePath: string\n  ): { success: boolean; result?: string; error?: string } {\n    const validation = this.validatePatch(original, patch);\n    \n    if (!validation.valid) {\n      return {\n        success: false,\n        error: `Patch validation failed: ${validation.errors.join(\", \")}`,\n      };\n    }\n\n    try {\n      const originalLines = original.split(\"\\n\");\n      const result: string[] = [];\n      let originalIndex = 0;\n      let patchIndex = 0;\n\n      while (patchIndex < patch.length) {\n        const diffLine = patch[patchIndex];\n\n        if (diffLine.type === \"context\") {\n          if (originalIndex < originalLines.length) {\n            result.push(originalLines[originalIndex]);\n            originalIndex++;\n          }\n          patchIndex++;\n        } else if (diffLine.type === \"remove\") {\n          originalIndex++;\n          patchIndex++;\n        } else if (diffLine.type === \"add\") {\n          result.push(diffLine.content);\n          patchIndex++;\n        }\n      }\n\n      while (originalIndex < originalLines.length) {\n        result.push(originalLines[originalIndex]);\n        originalIndex++;\n      }\n\n      return {\n        success: true,\n        result: result.join(\"\\n\"),\n      };\n    } catch (error: any) {\n      return {\n        success: false,\n        error: `Failed to apply patch: ${error.message}`,\n      };\n    }\n  }\n\n  validatePatch(original: string, patch: DiffLine[]): ValidationResult {\n    const errors: string[] = [];\n    const originalLines = original.split(\"\\n\");\n\n    let originalIndex = 0;\n\n    for (let i = 0; i < patch.length; i++) {\n      const diffLine = patch[i];\n\n      if (diffLine.type === \"context\" || diffLine.type === \"remove\") {\n        if (originalIndex >= originalLines.length) {\n          errors.push(\n            `Line ${i + 1}: Expected line at index ${originalIndex}, but original file has only ${originalLines.length} lines`\n          );\n          continue;\n        }\n\n        const originalLine = originalLines[originalIndex];\n        if (diffLine.type === \"context\" && diffLine.content !== originalLine) {\n          errors.push(\n            `Line ${i + 1}: Context mismatch. Expected \"${originalLine}\", got \"${diffLine.content}\"`\n          );\n        } else if (diffLine.type === \"remove\" && diffLine.content !== originalLine) {\n          errors.push(\n            `Line ${i + 1}: Remove mismatch. Expected \"${originalLine}\", got \"${diffLine.content}\"`\n          );\n        }\n\n        originalIndex++;\n      }\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n    };\n  }\n\n  formatDiffForDisplay(diff: FileDiff): string {\n    const lines: string[] = [];\n    lines.push(`--- a/${diff.path}`);\n    lines.push(`+++ b/${diff.path}`);\n\n    let currentHunk: DiffLine[] = [];\n    let hunkStartOriginal = 0;\n    let hunkStartModified = 0;\n\n    const flushHunk = () => {\n      if (currentHunk.length === 0) return;\n\n      let originalCount = 0;\n      let modifiedCount = 0;\n\n      for (const line of currentHunk) {\n        if (line.type === \"context\" || line.type === \"remove\") {\n          originalCount++;\n        }\n        if (line.type === \"context\" || line.type === \"add\") {\n          modifiedCount++;\n        }\n      }\n\n      lines.push(\n        `@@ -${hunkStartOriginal + 1},${originalCount} +${hunkStartModified + 1},${modifiedCount} @@`\n      );\n\n      for (const line of currentHunk) {\n        const prefix =\n          line.type === \"add\" ? \"+\" : line.type === \"remove\" ? \"-\" : \" \";\n        lines.push(`${prefix}${line.content}`);\n      }\n\n      currentHunk = [];\n    };\n\n    let originalLine = 0;\n    let modifiedLine = 0;\n\n    for (const diffLine of diff.lines) {\n      if (currentHunk.length === 0) {\n        hunkStartOriginal = originalLine;\n        hunkStartModified = modifiedLine;\n      }\n\n      currentHunk.push(diffLine);\n\n      if (diffLine.type === \"context\" || diffLine.type === \"remove\") {\n        originalLine++;\n      }\n      if (diffLine.type === \"context\" || diffLine.type === \"add\") {\n        modifiedLine++;\n      }\n    }\n\n    flushHunk();\n\n    return lines.join(\"\\n\");\n  }\n\n  parseDiffString(diffString: string): FileDiff[] {\n    const lines = diffString.split(\"\\n\");\n    const diffs: FileDiff[] = [];\n    let currentDiff: FileDiff | null = null;\n    let currentLines: DiffLine[] = [];\n    let lineNumber = 0;\n\n    for (const line of lines) {\n      if (line.startsWith(\"--- \")) {\n        if (currentDiff && currentLines.length > 0) {\n          currentDiff.lines = currentLines;\n          diffs.push(currentDiff);\n        }\n        currentLines = [];\n        lineNumber = 0;\n      } else if (line.startsWith(\"+++ \")) {\n        const match = line.match(/^\\+\\+\\+ [ab]\\/(.+)$/);\n        if (match) {\n          currentDiff = {\n            path: match[1],\n            lines: [],\n          };\n        }\n      } else if (line.startsWith(\"@@ \")) {\n        const match = line.match(/^@@ -(\\d+),?\\d* \\+(\\d+),?\\d* @@/);\n        if (match) {\n          lineNumber = parseInt(match[1], 10) - 1;\n        }\n      } else if (line.startsWith(\"+\")) {\n        currentLines.push({\n          lineNumber: lineNumber++,\n          type: \"add\",\n          content: line.substring(1),\n        });\n      } else if (line.startsWith(\"-\")) {\n        currentLines.push({\n          lineNumber: lineNumber++,\n          type: \"remove\",\n          content: line.substring(1),\n        });\n      } else if (line.startsWith(\" \")) {\n        currentLines.push({\n          lineNumber: lineNumber++,\n          type: \"context\",\n          content: line.substring(1),\n        });\n      }\n    }\n\n    if (currentDiff && currentLines.length > 0) {\n      currentDiff.lines = currentLines;\n      diffs.push(currentDiff);\n    }\n\n    return diffs;\n  }\n\n  reverseDiff(diff: FileDiff): FileDiff {\n    const reversedLines: DiffLine[] = diff.lines.map((line) => ({\n      ...line,\n      type:\n        line.type === \"add\"\n          ? \"remove\"\n          : line.type === \"remove\"\n          ? \"add\"\n          : \"context\",\n    }));\n\n    return {\n      path: diff.path,\n      lines: reversedLines,\n    };\n  }\n\n  private computeDiff(\n    originalLines: string[],\n    modifiedLines: string[]\n  ): DiffChange[] {\n    const changes: DiffChange[] = [];\n    \n    const lcs = this.longestCommonSubsequence(originalLines, modifiedLines);\n    \n    let i = 0;\n    let j = 0;\n    let lineNumber = 0;\n\n    for (const [origIdx, modIdx] of lcs) {\n      while (i < origIdx) {\n        changes.push({\n          type: \"remove\",\n          lineNumber: lineNumber++,\n          content: originalLines[i],\n        });\n        i++;\n      }\n\n      while (j < modIdx) {\n        changes.push({\n          type: \"add\",\n          lineNumber: lineNumber++,\n          content: modifiedLines[j],\n        });\n        j++;\n      }\n\n      changes.push({\n        type: \"context\",\n        lineNumber: lineNumber++,\n        content: originalLines[i],\n      });\n      i++;\n      j++;\n    }\n\n    while (i < originalLines.length) {\n      changes.push({\n        type: \"remove\",\n        lineNumber: lineNumber++,\n        content: originalLines[i],\n      });\n      i++;\n    }\n\n    while (j < modifiedLines.length) {\n      changes.push({\n        type: \"add\",\n        lineNumber: lineNumber++,\n        content: modifiedLines[j],\n      });\n      j++;\n    }\n\n    return changes;\n  }\n\n  private longestCommonSubsequence(\n    a: string[],\n    b: string[]\n  ): Array<[number, number]> {\n    const m = a.length;\n    const n = b.length;\n    const dp: number[][] = Array.from({ length: m + 1 }, () =>\n      Array(n + 1).fill(0)\n    );\n\n    for (let i = 1; i <= m; i++) {\n      for (let j = 1; j <= n; j++) {\n        if (a[i - 1] === b[j - 1]) {\n          dp[i][j] = dp[i - 1][j - 1] + 1;\n        } else {\n          dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n        }\n      }\n    }\n\n    const result: Array<[number, number]> = [];\n    let i = m;\n    let j = n;\n\n    while (i > 0 && j > 0) {\n      if (a[i - 1] === b[j - 1]) {\n        result.unshift([i - 1, j - 1]);\n        i--;\n        j--;\n      } else if (dp[i - 1][j] > dp[i][j - 1]) {\n        i--;\n      } else {\n        j--;\n      }\n    }\n\n    return result;\n  }\n\n  private createUnifiedDiff(\n    changes: DiffChange[],\n    originalLines: string[],\n    modifiedLines: string[],\n    reasoning?: Map<number, { reason: string; confidence: number }>\n  ): DiffLine[] {\n    const diffLines: DiffLine[] = [];\n    \n    for (const change of changes) {\n      diffLines.push({\n        lineNumber: change.lineNumber,\n        type: change.type,\n        content: change.content,\n      });\n    }\n\n    return diffLines;\n  }\n\n  mergeSequentialDiffs(diffs: FileDiff[]): FileDiff[] {\n    const merged = new Map<string, FileDiff>();\n\n    for (const diff of diffs) {\n      if (merged.has(diff.path)) {\n        const existing = merged.get(diff.path)!;\n        existing.lines.push(...diff.lines);\n      } else {\n        merged.set(diff.path, { ...diff });\n      }\n    }\n\n    return Array.from(merged.values());\n  }\n\n  getDiffStatistics(diff: FileDiff): {\n    additions: number;\n    deletions: number;\n    changes: number;\n  } {\n    let additions = 0;\n    let deletions = 0;\n\n    for (const line of diff.lines) {\n      if (line.type === \"add\") additions++;\n      if (line.type === \"remove\") deletions++;\n    }\n\n    return {\n      additions,\n      deletions,\n      changes: additions + deletions,\n    };\n  }\n}\n","size_bytes":10319},"client/src/components/examples/AIReasoningChain.tsx":{"content":"import { AIReasoningChain } from '../ai-reasoning-chain';\n\nconst mockSteps = [\n  {\n    id: \"r1\",\n    timestamp: \"14:23:02\",\n    description: \"Identified authentication middleware as critical security component requiring modular refactoring\",\n    confidence: 95,\n    completed: true,\n  },\n  {\n    id: \"r2\",\n    timestamp: \"14:23:12\",\n    description: \"Detected hardcoded secret in token validation - security risk that requires immediate attention\",\n    confidence: 98,\n    completed: true,\n  },\n  {\n    id: \"r3\",\n    timestamp: \"14:23:15\",\n    description: \"Proposed solution: Extract validation logic into separate module with environment-based configuration\",\n    confidence: 92,\n    completed: false,\n  },\n];\n\nexport default function AIReasoningChainExample() {\n  return <AIReasoningChain steps={mockSteps} />;\n}\n","size_bytes":816},"client/src/components/ui/input-otp.tsx":{"content":"import * as React from \"react\"\nimport { OTPInput, OTPInputContext } from \"input-otp\"\nimport { Dot } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst InputOTP = React.forwardRef<\n  React.ElementRef<typeof OTPInput>,\n  React.ComponentPropsWithoutRef<typeof OTPInput>\n>(({ className, containerClassName, ...props }, ref) => (\n  <OTPInput\n    ref={ref}\n    containerClassName={cn(\n      \"flex items-center gap-2 has-[:disabled]:opacity-50\",\n      containerClassName\n    )}\n    className={cn(\"disabled:cursor-not-allowed\", className)}\n    {...props}\n  />\n))\nInputOTP.displayName = \"InputOTP\"\n\nconst InputOTPGroup = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\">\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"flex items-center\", className)} {...props} />\n))\nInputOTPGroup.displayName = \"InputOTPGroup\"\n\nconst InputOTPSlot = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\"> & { index: number }\n>(({ index, className, ...props }, ref) => {\n  const inputOTPContext = React.useContext(OTPInputContext)\n  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]\n\n  return (\n    <div\n      ref={ref}\n      className={cn(\n        \"relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md\",\n        isActive && \"z-10 ring-2 ring-ring ring-offset-background\",\n        className\n      )}\n      {...props}\n    >\n      {char}\n      {hasFakeCaret && (\n        <div className=\"pointer-events-none absolute inset-0 flex items-center justify-center\">\n          <div className=\"h-4 w-px animate-caret-blink bg-foreground duration-1000\" />\n        </div>\n      )}\n    </div>\n  )\n})\nInputOTPSlot.displayName = \"InputOTPSlot\"\n\nconst InputOTPSeparator = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\">\n>(({ ...props }, ref) => (\n  <div ref={ref} role=\"separator\" {...props}>\n    <Dot />\n  </div>\n))\nInputOTPSeparator.displayName = \"InputOTPSeparator\"\n\nexport { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }\n","size_bytes":2154},"client/src/components/ui/collapsible.tsx":{"content":"\"use client\"\n\nimport * as CollapsiblePrimitive from \"@radix-ui/react-collapsible\"\n\nconst Collapsible = CollapsiblePrimitive.Root\n\nconst CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger\n\nconst CollapsibleContent = CollapsiblePrimitive.CollapsibleContent\n\nexport { Collapsible, CollapsibleTrigger, CollapsibleContent }\n","size_bytes":329},"client/src/components/status-badge.tsx":{"content":"import { Badge } from \"@/components/ui/badge\";\nimport { CheckCircle, Clock, XCircle, PlayCircle, Loader2 } from \"lucide-react\";\n\ntype TaskStatus = \"planning\" | \"executing\" | \"completed\" | \"failed\" | \"queued\";\n\ninterface StatusBadgeProps {\n  status: TaskStatus;\n  className?: string;\n}\n\nconst statusConfig = {\n  planning: {\n    label: \"Planning\",\n    icon: Loader2,\n    variant: \"secondary\" as const,\n    iconClass: \"animate-spin\",\n  },\n  executing: {\n    label: \"Executing\",\n    icon: PlayCircle,\n    variant: \"default\" as const,\n    iconClass: \"animate-pulse\",\n  },\n  completed: {\n    label: \"Completed\",\n    icon: CheckCircle,\n    variant: \"secondary\" as const,\n    iconClass: \"text-chart-2\",\n  },\n  failed: {\n    label: \"Failed\",\n    icon: XCircle,\n    variant: \"destructive\" as const,\n    iconClass: \"\",\n  },\n  queued: {\n    label: \"Queued\",\n    icon: Clock,\n    variant: \"outline\" as const,\n    iconClass: \"text-muted-foreground\",\n  },\n};\n\nexport function StatusBadge({ status, className }: StatusBadgeProps) {\n  const config = statusConfig[status];\n  const Icon = config.icon;\n\n  return (\n    <Badge variant={config.variant} className={className} data-testid={`badge-status-${status}`}>\n      <Icon className={`h-3 w-3 mr-1 ${config.iconClass}`} />\n      {config.label}\n    </Badge>\n  );\n}\n","size_bytes":1296},"replit.md":{"content":"# AI GitHub Agent Dashboard\n\n## Overview\n\nThis is an **AI-driven GitHub automation agent** that integrates with MCP (Model Context Protocol) GitHub and Playwright servers to autonomously plan, orchestrate, and execute full-stack software development workflows. The system operates both as an autonomous AI developer and as a GitHub App bot that reacts intelligently to repository events (pull requests, issues, comments, pushes, workflow updates).\n\nThe application provides a real-time dashboard for monitoring AI reasoning chains, execution logs, code diffs, and task progress. It supports any OpenAI-compatible API endpoint and employs advanced prompt engineering with semantic memory of repository architecture and context across sessions.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Frontend Architecture\n\n**Framework:** React with TypeScript using Vite as the build tool\n\n**UI Component System:** Radix UI primitives with shadcn/ui component library following a \"New York\" style design system\n\n**Design Philosophy:** Inspired by Linear, GitHub, and VS Code - prioritizing information density, scannable data hierarchy, and functional clarity for technical workflows. Uses Inter for UI typography and JetBrains Mono for code/logs.\n\n**Styling:** Tailwind CSS with custom design tokens for light/dark themes, utilizing CSS variables for dynamic theming\n\n**State Management:** TanStack Query (React Query) for server state management with custom query client configuration\n\n**Routing:** Wouter for client-side routing (lightweight alternative to React Router)\n\n**Key UI Components:**\n- Real-time task monitoring dashboard with metrics cards\n- AI reasoning chain visualization showing step-by-step decision making with confidence scores\n- Execution log panel with auto-scroll and log level filtering\n- Diff viewer for code changes with syntax highlighting\n- Event log table for GitHub webhook events\n- Settings configuration for AI endpoints and GitHub integration\n\n### Backend Architecture\n\n**Runtime:** Node.js with Express.js server\n\n**Language:** TypeScript with ESNext module system\n\n**API Design:** RESTful HTTP endpoints under `/api` namespace with additional Server-Sent Events (SSE) for real-time log streaming\n\n**Server-Side Rendering:** Vite development server integration with custom middleware mode for hot module replacement during development\n\n**Build System:** \n- Vite for client-side bundling\n- esbuild for server-side production builds\n- Platform-specific bundling with external package handling\n\n**Key Services:**\n- `AIService`: Manages connections to OpenAI-compatible endpoints, handles task planning and reasoning generation\n- `AIProviderManager`: **NEW** - Multi-provider AI orchestration system that supports OpenAI, Anthropic Claude, and Azure OpenAI with:\n  - Smart routing algorithm based on task complexity, context size, rate limits, and user preferences\n  - Automatic failover between providers for high availability\n  - Comprehensive error handling with exponential backoff retry logic (max 3 attempts, 120s timeout)\n  - Rate limiting with request queueing (429 errors)\n  - Performance tracking (response times, token usage, success rates, cost tracking)\n  - Provider-specific adapters for OpenAI and Anthropic message formats\n- `GitHubService`: Integrates with GitHub API for repository operations, file content retrieval, and webhook processing\n- `Storage`: In-memory storage implementation (IStorage interface allows for future database backends)\n\n### Data Storage\n\n**Current Implementation:** In-memory storage using Maps for tasks, events, and settings\n\n**Schema Design:** Zod schemas for runtime type validation with TypeScript types derived from schemas\n\n**Data Models:**\n- **Tasks:** Track AI agent work with status (planning, executing, completed, failed, queued), logs, reasoning steps, and file diffs\n- **GitHub Events:** Store webhook events with repository, action, and processing status\n- **Settings:** AI configuration (endpoint, API key, model, tokens, temperature) and GitHub configuration (token, webhook secret, auto-approve)\n\n**Future-Ready:** Storage interface abstraction (`IStorage`) allows seamless migration to PostgreSQL via Drizzle ORM (configuration already present in `drizzle.config.ts`)\n\n### Authentication & Security\n\n**GitHub App Integration:** Webhook endpoint (`/api/webhook`) designed to receive and process GitHub events with signature validation support via webhook secrets\n\n**API Key Management:** Secure storage of sensitive credentials (AI API keys, GitHub tokens) with masked display in settings UI\n\n**Safety Controls:** \n- Human-in-the-loop approval workflow (auto-approve setting)\n- Sandboxed container execution mentioned in project requirements\n- Audit logging through task log entries\n\n### External Dependencies\n\n**AI Model Integration:**\n- **Multi-Provider System** with intelligent routing:\n  - **OpenAI**: GPT-4 Turbo (128K context window, 0.3-0.7 temperature)\n  - **Anthropic**: Claude 3 Sonnet (200K context window, 1.0 temperature)\n  - **Azure OpenAI**: Enterprise-grade deployment support\n- Smart provider selection based on:\n  - Task complexity (threshold: 0.7 for advanced models)\n  - Context size (threshold: 90,000 tokens for large context models)\n  - Rate limit remaining (threshold: 20% for fallback triggers)\n  - User preference settings\n- Automatic failover and load balancing\n- Real-time performance metrics and cost tracking\n- Configurable model selection, temperature, and max tokens per provider\n- Chat completion interface for reasoning and task generation\n\n**GitHub Integration:**\n- GitHub REST API for repository operations\n- GitHub App webhook system for event-driven automation\n- File content retrieval and repository metadata access\n\n**MCP Servers (Planned):**\n- MCP GitHub Server for enhanced repository operations\n- MCP Playwright Server for browser automation and testing\n\n**UI Component Libraries:**\n- Radix UI primitives (accordion, alert-dialog, avatar, checkbox, dialog, dropdown, popover, scroll-area, select, tabs, toast, tooltip, etc.)\n- cmdk for command palette functionality\n- embla-carousel for carousel components\n- date-fns for date formatting and manipulation\n- lucide-react for consistent iconography\n\n**Database (Configured but Not Active):**\n- Drizzle ORM with PostgreSQL dialect\n- Neon Database serverless driver (`@neondatabase/serverless`)\n- Migration system configured in `./migrations`\n\n**Development Tools:**\n- Replit-specific plugins for runtime error overlay, cartographer, and dev banner\n- TypeScript strict mode with ESNext targeting\n- PostCSS with Tailwind and Autoprefixer\n\n**Session Management:**\n- `connect-pg-simple` for PostgreSQL session store (prepared for future use)\n- Express session handling with raw body parsing for webhook validation","size_bytes":6845},"client/src/components/ui/alert-dialog.tsx":{"content":"import * as React from \"react\"\nimport * as AlertDialogPrimitive from \"@radix-ui/react-alert-dialog\"\n\nimport { cn } from \"@/lib/utils\"\nimport { buttonVariants } from \"@/components/ui/button\"\n\nconst AlertDialog = AlertDialogPrimitive.Root\n\nconst AlertDialogTrigger = AlertDialogPrimitive.Trigger\n\nconst AlertDialogPortal = AlertDialogPrimitive.Portal\n\nconst AlertDialogOverlay = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Overlay\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  />\n))\nAlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName\n\nconst AlertDialogContent = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPortal>\n    <AlertDialogOverlay />\n    <AlertDialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\n        className\n      )}\n      {...props}\n    />\n  </AlertDialogPortal>\n))\nAlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName\n\nconst AlertDialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-2 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nAlertDialogHeader.displayName = \"AlertDialogHeader\"\n\nconst AlertDialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nAlertDialogFooter.displayName = \"AlertDialogFooter\"\n\nconst AlertDialogTitle = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Title\n    ref={ref}\n    className={cn(\"text-lg font-semibold\", className)}\n    {...props}\n  />\n))\nAlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName\n\nconst AlertDialogDescription = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nAlertDialogDescription.displayName =\n  AlertDialogPrimitive.Description.displayName\n\nconst AlertDialogAction = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Action>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Action\n    ref={ref}\n    className={cn(buttonVariants(), className)}\n    {...props}\n  />\n))\nAlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName\n\nconst AlertDialogCancel = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Cancel\n    ref={ref}\n    className={cn(\n      buttonVariants({ variant: \"outline\" }),\n      \"mt-2 sm:mt-0\",\n      className\n    )}\n    {...props}\n  />\n))\nAlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName\n\nexport {\n  AlertDialog,\n  AlertDialogPortal,\n  AlertDialogOverlay,\n  AlertDialogTrigger,\n  AlertDialogContent,\n  AlertDialogHeader,\n  AlertDialogFooter,\n  AlertDialogTitle,\n  AlertDialogDescription,\n  AlertDialogAction,\n  AlertDialogCancel,\n}\n","size_bytes":4420},"client/src/components/ui/pagination.tsx":{"content":"import * as React from \"react\"\nimport { ChevronLeft, ChevronRight, MoreHorizontal } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { ButtonProps, buttonVariants } from \"@/components/ui/button\"\n\nconst Pagination = ({ className, ...props }: React.ComponentProps<\"nav\">) => (\n  <nav\n    role=\"navigation\"\n    aria-label=\"pagination\"\n    className={cn(\"mx-auto flex w-full justify-center\", className)}\n    {...props}\n  />\n)\nPagination.displayName = \"Pagination\"\n\nconst PaginationContent = React.forwardRef<\n  HTMLUListElement,\n  React.ComponentProps<\"ul\">\n>(({ className, ...props }, ref) => (\n  <ul\n    ref={ref}\n    className={cn(\"flex flex-row items-center gap-1\", className)}\n    {...props}\n  />\n))\nPaginationContent.displayName = \"PaginationContent\"\n\nconst PaginationItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentProps<\"li\">\n>(({ className, ...props }, ref) => (\n  <li ref={ref} className={cn(\"\", className)} {...props} />\n))\nPaginationItem.displayName = \"PaginationItem\"\n\ntype PaginationLinkProps = {\n  isActive?: boolean\n} & Pick<ButtonProps, \"size\"> &\n  React.ComponentProps<\"a\">\n\nconst PaginationLink = ({\n  className,\n  isActive,\n  size = \"icon\",\n  ...props\n}: PaginationLinkProps) => (\n  <a\n    aria-current={isActive ? \"page\" : undefined}\n    className={cn(\n      buttonVariants({\n        variant: isActive ? \"outline\" : \"ghost\",\n        size,\n      }),\n      className\n    )}\n    {...props}\n  />\n)\nPaginationLink.displayName = \"PaginationLink\"\n\nconst PaginationPrevious = ({\n  className,\n  ...props\n}: React.ComponentProps<typeof PaginationLink>) => (\n  <PaginationLink\n    aria-label=\"Go to previous page\"\n    size=\"default\"\n    className={cn(\"gap-1 pl-2.5\", className)}\n    {...props}\n  >\n    <ChevronLeft className=\"h-4 w-4\" />\n    <span>Previous</span>\n  </PaginationLink>\n)\nPaginationPrevious.displayName = \"PaginationPrevious\"\n\nconst PaginationNext = ({\n  className,\n  ...props\n}: React.ComponentProps<typeof PaginationLink>) => (\n  <PaginationLink\n    aria-label=\"Go to next page\"\n    size=\"default\"\n    className={cn(\"gap-1 pr-2.5\", className)}\n    {...props}\n  >\n    <span>Next</span>\n    <ChevronRight className=\"h-4 w-4\" />\n  </PaginationLink>\n)\nPaginationNext.displayName = \"PaginationNext\"\n\nconst PaginationEllipsis = ({\n  className,\n  ...props\n}: React.ComponentProps<\"span\">) => (\n  <span\n    aria-hidden\n    className={cn(\"flex h-9 w-9 items-center justify-center\", className)}\n    {...props}\n  >\n    <MoreHorizontal className=\"h-4 w-4\" />\n    <span className=\"sr-only\">More pages</span>\n  </span>\n)\nPaginationEllipsis.displayName = \"PaginationEllipsis\"\n\nexport {\n  Pagination,\n  PaginationContent,\n  PaginationEllipsis,\n  PaginationItem,\n  PaginationLink,\n  PaginationNext,\n  PaginationPrevious,\n}\n","size_bytes":2751},"client/src/components/ui/slider.tsx":{"content":"import * as React from \"react\"\nimport * as SliderPrimitive from \"@radix-ui/react-slider\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Slider = React.forwardRef<\n  React.ElementRef<typeof SliderPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <SliderPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative flex w-full touch-none select-none items-center\",\n      className\n    )}\n    {...props}\n  >\n    <SliderPrimitive.Track className=\"relative h-2 w-full grow overflow-hidden rounded-full bg-secondary\">\n      <SliderPrimitive.Range className=\"absolute h-full bg-primary\" />\n    </SliderPrimitive.Track>\n    <SliderPrimitive.Thumb className=\"block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\" />\n  </SliderPrimitive.Root>\n))\nSlider.displayName = SliderPrimitive.Root.displayName\n\nexport { Slider }\n","size_bytes":1077},"client/src/components/ui/toggle.tsx":{"content":"import * as React from \"react\"\nimport * as TogglePrimitive from \"@radix-ui/react-toggle\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst toggleVariants = cva(\n  \"inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 gap-2\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-transparent\",\n        outline:\n          \"border border-input bg-transparent hover:bg-accent hover:text-accent-foreground\",\n      },\n      size: {\n        default: \"h-10 px-3 min-w-10\",\n        sm: \"h-9 px-2.5 min-w-9\",\n        lg: \"h-11 px-5 min-w-11\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nconst Toggle = React.forwardRef<\n  React.ElementRef<typeof TogglePrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &\n    VariantProps<typeof toggleVariants>\n>(({ className, variant, size, ...props }, ref) => (\n  <TogglePrimitive.Root\n    ref={ref}\n    className={cn(toggleVariants({ variant, size, className }))}\n    {...props}\n  />\n))\n\nToggle.displayName = TogglePrimitive.Root.displayName\n\nexport { Toggle, toggleVariants }\n","size_bytes":1527},"postcss.config.js":{"content":"export default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n","size_bytes":80},"client/src/components/metrics-card.tsx":{"content":"import { Card, CardContent, CardHeader } from \"@/components/ui/card\";\nimport { LucideIcon } from \"lucide-react\";\n\ninterface MetricsCardProps {\n  title: string;\n  value: string | number;\n  icon: LucideIcon;\n  trend?: string;\n}\n\nexport function MetricsCard({ title, value, icon: Icon, trend }: MetricsCardProps) {\n  return (\n    <Card data-testid={`card-metric-${title.toLowerCase().replace(/\\s+/g, '-')}`}>\n      <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n        <div className=\"text-sm font-medium text-muted-foreground\">{title}</div>\n        <Icon className=\"h-4 w-4 text-muted-foreground\" />\n      </CardHeader>\n      <CardContent>\n        <div className=\"text-3xl font-bold\" data-testid={`text-metric-value-${title.toLowerCase().replace(/\\s+/g, '-')}`}>\n          {value}\n        </div>\n        {trend && (\n          <p className=\"text-xs text-muted-foreground mt-1\">{trend}</p>\n        )}\n      </CardContent>\n    </Card>\n  );\n}\n","size_bytes":974},"client/src/components/ui/table.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Table = React.forwardRef<\n  HTMLTableElement,\n  React.HTMLAttributes<HTMLTableElement>\n>(({ className, ...props }, ref) => (\n  <div className=\"relative w-full overflow-auto\">\n    <table\n      ref={ref}\n      className={cn(\"w-full caption-bottom text-sm\", className)}\n      {...props}\n    />\n  </div>\n))\nTable.displayName = \"Table\"\n\nconst TableHeader = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <thead ref={ref} className={cn(\"[&_tr]:border-b\", className)} {...props} />\n))\nTableHeader.displayName = \"TableHeader\"\n\nconst TableBody = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tbody\n    ref={ref}\n    className={cn(\"[&_tr:last-child]:border-0\", className)}\n    {...props}\n  />\n))\nTableBody.displayName = \"TableBody\"\n\nconst TableFooter = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tfoot\n    ref={ref}\n    className={cn(\n      \"border-t bg-muted/50 font-medium [&>tr]:last:border-b-0\",\n      className\n    )}\n    {...props}\n  />\n))\nTableFooter.displayName = \"TableFooter\"\n\nconst TableRow = React.forwardRef<\n  HTMLTableRowElement,\n  React.HTMLAttributes<HTMLTableRowElement>\n>(({ className, ...props }, ref) => (\n  <tr\n    ref={ref}\n    className={cn(\n      \"border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted\",\n      className\n    )}\n    {...props}\n  />\n))\nTableRow.displayName = \"TableRow\"\n\nconst TableHead = React.forwardRef<\n  HTMLTableCellElement,\n  React.ThHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <th\n    ref={ref}\n    className={cn(\n      \"h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0\",\n      className\n    )}\n    {...props}\n  />\n))\nTableHead.displayName = \"TableHead\"\n\nconst TableCell = React.forwardRef<\n  HTMLTableCellElement,\n  React.TdHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <td\n    ref={ref}\n    className={cn(\"p-4 align-middle [&:has([role=checkbox])]:pr-0\", className)}\n    {...props}\n  />\n))\nTableCell.displayName = \"TableCell\"\n\nconst TableCaption = React.forwardRef<\n  HTMLTableCaptionElement,\n  React.HTMLAttributes<HTMLTableCaptionElement>\n>(({ className, ...props }, ref) => (\n  <caption\n    ref={ref}\n    className={cn(\"mt-4 text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nTableCaption.displayName = \"TableCaption\"\n\nexport {\n  Table,\n  TableHeader,\n  TableBody,\n  TableFooter,\n  TableHead,\n  TableRow,\n  TableCell,\n  TableCaption,\n}\n","size_bytes":2765},"client/src/components/ui/carousel.tsx":{"content":"import * as React from \"react\"\nimport useEmblaCarousel, {\n  type UseEmblaCarouselType,\n} from \"embla-carousel-react\"\nimport { ArrowLeft, ArrowRight } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\n\ntype CarouselApi = UseEmblaCarouselType[1]\ntype UseCarouselParameters = Parameters<typeof useEmblaCarousel>\ntype CarouselOptions = UseCarouselParameters[0]\ntype CarouselPlugin = UseCarouselParameters[1]\n\ntype CarouselProps = {\n  opts?: CarouselOptions\n  plugins?: CarouselPlugin\n  orientation?: \"horizontal\" | \"vertical\"\n  setApi?: (api: CarouselApi) => void\n}\n\ntype CarouselContextProps = {\n  carouselRef: ReturnType<typeof useEmblaCarousel>[0]\n  api: ReturnType<typeof useEmblaCarousel>[1]\n  scrollPrev: () => void\n  scrollNext: () => void\n  canScrollPrev: boolean\n  canScrollNext: boolean\n} & CarouselProps\n\nconst CarouselContext = React.createContext<CarouselContextProps | null>(null)\n\nfunction useCarousel() {\n  const context = React.useContext(CarouselContext)\n\n  if (!context) {\n    throw new Error(\"useCarousel must be used within a <Carousel />\")\n  }\n\n  return context\n}\n\nconst Carousel = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement> & CarouselProps\n>(\n  (\n    {\n      orientation = \"horizontal\",\n      opts,\n      setApi,\n      plugins,\n      className,\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    const [carouselRef, api] = useEmblaCarousel(\n      {\n        ...opts,\n        axis: orientation === \"horizontal\" ? \"x\" : \"y\",\n      },\n      plugins\n    )\n    const [canScrollPrev, setCanScrollPrev] = React.useState(false)\n    const [canScrollNext, setCanScrollNext] = React.useState(false)\n\n    const onSelect = React.useCallback((api: CarouselApi) => {\n      if (!api) {\n        return\n      }\n\n      setCanScrollPrev(api.canScrollPrev())\n      setCanScrollNext(api.canScrollNext())\n    }, [])\n\n    const scrollPrev = React.useCallback(() => {\n      api?.scrollPrev()\n    }, [api])\n\n    const scrollNext = React.useCallback(() => {\n      api?.scrollNext()\n    }, [api])\n\n    const handleKeyDown = React.useCallback(\n      (event: React.KeyboardEvent<HTMLDivElement>) => {\n        if (event.key === \"ArrowLeft\") {\n          event.preventDefault()\n          scrollPrev()\n        } else if (event.key === \"ArrowRight\") {\n          event.preventDefault()\n          scrollNext()\n        }\n      },\n      [scrollPrev, scrollNext]\n    )\n\n    React.useEffect(() => {\n      if (!api || !setApi) {\n        return\n      }\n\n      setApi(api)\n    }, [api, setApi])\n\n    React.useEffect(() => {\n      if (!api) {\n        return\n      }\n\n      onSelect(api)\n      api.on(\"reInit\", onSelect)\n      api.on(\"select\", onSelect)\n\n      return () => {\n        api?.off(\"select\", onSelect)\n      }\n    }, [api, onSelect])\n\n    return (\n      <CarouselContext.Provider\n        value={{\n          carouselRef,\n          api: api,\n          opts,\n          orientation:\n            orientation || (opts?.axis === \"y\" ? \"vertical\" : \"horizontal\"),\n          scrollPrev,\n          scrollNext,\n          canScrollPrev,\n          canScrollNext,\n        }}\n      >\n        <div\n          ref={ref}\n          onKeyDownCapture={handleKeyDown}\n          className={cn(\"relative\", className)}\n          role=\"region\"\n          aria-roledescription=\"carousel\"\n          {...props}\n        >\n          {children}\n        </div>\n      </CarouselContext.Provider>\n    )\n  }\n)\nCarousel.displayName = \"Carousel\"\n\nconst CarouselContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const { carouselRef, orientation } = useCarousel()\n\n  return (\n    <div ref={carouselRef} className=\"overflow-hidden\">\n      <div\n        ref={ref}\n        className={cn(\n          \"flex\",\n          orientation === \"horizontal\" ? \"-ml-4\" : \"-mt-4 flex-col\",\n          className\n        )}\n        {...props}\n      />\n    </div>\n  )\n})\nCarouselContent.displayName = \"CarouselContent\"\n\nconst CarouselItem = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const { orientation } = useCarousel()\n\n  return (\n    <div\n      ref={ref}\n      role=\"group\"\n      aria-roledescription=\"slide\"\n      className={cn(\n        \"min-w-0 shrink-0 grow-0 basis-full\",\n        orientation === \"horizontal\" ? \"pl-4\" : \"pt-4\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nCarouselItem.displayName = \"CarouselItem\"\n\nconst CarouselPrevious = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<typeof Button>\n>(({ className, variant = \"outline\", size = \"icon\", ...props }, ref) => {\n  const { orientation, scrollPrev, canScrollPrev } = useCarousel()\n\n  return (\n    <Button\n      ref={ref}\n      variant={variant}\n      size={size}\n      className={cn(\n        \"absolute  h-8 w-8 rounded-full\",\n        orientation === \"horizontal\"\n          ? \"-left-12 top-1/2 -translate-y-1/2\"\n          : \"-top-12 left-1/2 -translate-x-1/2 rotate-90\",\n        className\n      )}\n      disabled={!canScrollPrev}\n      onClick={scrollPrev}\n      {...props}\n    >\n      <ArrowLeft className=\"h-4 w-4\" />\n      <span className=\"sr-only\">Previous slide</span>\n    </Button>\n  )\n})\nCarouselPrevious.displayName = \"CarouselPrevious\"\n\nconst CarouselNext = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<typeof Button>\n>(({ className, variant = \"outline\", size = \"icon\", ...props }, ref) => {\n  const { orientation, scrollNext, canScrollNext } = useCarousel()\n\n  return (\n    <Button\n      ref={ref}\n      variant={variant}\n      size={size}\n      className={cn(\n        \"absolute h-8 w-8 rounded-full\",\n        orientation === \"horizontal\"\n          ? \"-right-12 top-1/2 -translate-y-1/2\"\n          : \"-bottom-12 left-1/2 -translate-x-1/2 rotate-90\",\n        className\n      )}\n      disabled={!canScrollNext}\n      onClick={scrollNext}\n      {...props}\n    >\n      <ArrowRight className=\"h-4 w-4\" />\n      <span className=\"sr-only\">Next slide</span>\n    </Button>\n  )\n})\nCarouselNext.displayName = \"CarouselNext\"\n\nexport {\n  type CarouselApi,\n  Carousel,\n  CarouselContent,\n  CarouselItem,\n  CarouselPrevious,\n  CarouselNext,\n}\n","size_bytes":6210},"client/src/components/ui/tabs.tsx":{"content":"import * as React from \"react\"\nimport * as TabsPrimitive from \"@radix-ui/react-tabs\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Tabs = TabsPrimitive.Root\n\nconst TabsList = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.List\n    ref={ref}\n    className={cn(\n      \"inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsList.displayName = TabsPrimitive.List.displayName\n\nconst TabsTrigger = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsTrigger.displayName = TabsPrimitive.Trigger.displayName\n\nconst TabsContent = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.Content\n    ref={ref}\n    className={cn(\n      \"mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsContent.displayName = TabsPrimitive.Content.displayName\n\nexport { Tabs, TabsList, TabsTrigger, TabsContent }\n","size_bytes":1883},"client/src/components/ui/accordion.tsx":{"content":"import * as React from \"react\"\nimport * as AccordionPrimitive from \"@radix-ui/react-accordion\"\nimport { ChevronDown } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Accordion = AccordionPrimitive.Root\n\nconst AccordionItem = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>\n>(({ className, ...props }, ref) => (\n  <AccordionPrimitive.Item\n    ref={ref}\n    className={cn(\"border-b\", className)}\n    {...props}\n  />\n))\nAccordionItem.displayName = \"AccordionItem\"\n\nconst AccordionTrigger = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <AccordionPrimitive.Header className=\"flex\">\n    <AccordionPrimitive.Trigger\n      ref={ref}\n      className={cn(\n        \"flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180\",\n        className\n      )}\n      {...props}\n    >\n      {children}\n      <ChevronDown className=\"h-4 w-4 shrink-0 transition-transform duration-200\" />\n    </AccordionPrimitive.Trigger>\n  </AccordionPrimitive.Header>\n))\nAccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName\n\nconst AccordionContent = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <AccordionPrimitive.Content\n    ref={ref}\n    className=\"overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down\"\n    {...props}\n  >\n    <div className={cn(\"pb-4 pt-0\", className)}>{children}</div>\n  </AccordionPrimitive.Content>\n))\n\nAccordionContent.displayName = AccordionPrimitive.Content.displayName\n\nexport { Accordion, AccordionItem, AccordionTrigger, AccordionContent }\n","size_bytes":1977},"client/src/components/ui/calendar.tsx":{"content":"import * as React from \"react\"\nimport { ChevronLeft, ChevronRight } from \"lucide-react\"\nimport { DayPicker } from \"react-day-picker\"\n\nimport { cn } from \"@/lib/utils\"\nimport { buttonVariants } from \"@/components/ui/button\"\n\nexport type CalendarProps = React.ComponentProps<typeof DayPicker>\n\nfunction Calendar({\n  className,\n  classNames,\n  showOutsideDays = true,\n  ...props\n}: CalendarProps) {\n  return (\n    <DayPicker\n      showOutsideDays={showOutsideDays}\n      className={cn(\"p-3\", className)}\n      classNames={{\n        months: \"flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0\",\n        month: \"space-y-4\",\n        caption: \"flex justify-center pt-1 relative items-center\",\n        caption_label: \"text-sm font-medium\",\n        nav: \"space-x-1 flex items-center\",\n        nav_button: cn(\n          buttonVariants({ variant: \"outline\" }),\n          \"h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100\"\n        ),\n        nav_button_previous: \"absolute left-1\",\n        nav_button_next: \"absolute right-1\",\n        table: \"w-full border-collapse space-y-1\",\n        head_row: \"flex\",\n        head_cell:\n          \"text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]\",\n        row: \"flex w-full mt-2\",\n        cell: \"h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20\",\n        day: cn(\n          buttonVariants({ variant: \"ghost\" }),\n          \"h-9 w-9 p-0 font-normal aria-selected:opacity-100\"\n        ),\n        day_range_end: \"day-range-end\",\n        day_selected:\n          \"bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground\",\n        day_today: \"bg-accent text-accent-foreground\",\n        day_outside:\n          \"day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground\",\n        day_disabled: \"text-muted-foreground opacity-50\",\n        day_range_middle:\n          \"aria-selected:bg-accent aria-selected:text-accent-foreground\",\n        day_hidden: \"invisible\",\n        ...classNames,\n      }}\n      components={{\n        IconLeft: ({ className, ...props }) => (\n          <ChevronLeft className={cn(\"h-4 w-4\", className)} {...props} />\n        ),\n        IconRight: ({ className, ...props }) => (\n          <ChevronRight className={cn(\"h-4 w-4\", className)} {...props} />\n        ),\n      }}\n      {...props}\n    />\n  )\n}\nCalendar.displayName = \"Calendar\"\n\nexport { Calendar }\n","size_bytes":2695},"client/src/components/ui/popover.tsx":{"content":"import * as React from \"react\"\nimport * as PopoverPrimitive from \"@radix-ui/react-popover\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Popover = PopoverPrimitive.Root\n\nconst PopoverTrigger = PopoverPrimitive.Trigger\n\nconst PopoverContent = React.forwardRef<\n  React.ElementRef<typeof PopoverPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>\n>(({ className, align = \"center\", sideOffset = 4, ...props }, ref) => (\n  <PopoverPrimitive.Portal>\n    <PopoverPrimitive.Content\n      ref={ref}\n      align={align}\n      sideOffset={sideOffset}\n      className={cn(\n        \"z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-popover-content-transform-origin]\",\n        className\n      )}\n      {...props}\n    />\n  </PopoverPrimitive.Portal>\n))\nPopoverContent.displayName = PopoverPrimitive.Content.displayName\n\nexport { Popover, PopoverTrigger, PopoverContent }\n","size_bytes":1280},"drizzle.config.ts":{"content":"import { defineConfig } from \"drizzle-kit\";\n\nif (!process.env.DATABASE_URL) {\n  throw new Error(\"DATABASE_URL, ensure the database is provisioned\");\n}\n\nexport default defineConfig({\n  out: \"./migrations\",\n  schema: \"./shared/schema.ts\",\n  dialect: \"postgresql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL,\n  },\n});\n","size_bytes":325},"client/src/components/ui/hover-card.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as HoverCardPrimitive from \"@radix-ui/react-hover-card\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst HoverCard = HoverCardPrimitive.Root\n\nconst HoverCardTrigger = HoverCardPrimitive.Trigger\n\nconst HoverCardContent = React.forwardRef<\n  React.ElementRef<typeof HoverCardPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>\n>(({ className, align = \"center\", sideOffset = 4, ...props }, ref) => (\n  <HoverCardPrimitive.Content\n    ref={ref}\n    align={align}\n    sideOffset={sideOffset}\n    className={cn(\n      \"z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-hover-card-content-transform-origin]\",\n      className\n    )}\n    {...props}\n  />\n))\nHoverCardContent.displayName = HoverCardPrimitive.Content.displayName\n\nexport { HoverCard, HoverCardTrigger, HoverCardContent }\n","size_bytes":1251},"client/src/components/ui/button.tsx":{"content":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\" +\n  \" hover-elevate active-elevate-2\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"bg-primary text-primary-foreground border border-primary-border\",\n        destructive:\n          \"bg-destructive text-destructive-foreground border border-destructive-border\",\n        outline:\n          // Shows the background color of whatever card / sidebar / accent background it is inside of.\n          // Inherits the current text color.\n          \" border [border-color:var(--button-outline)]  shadow-xs active:shadow-none \",\n        secondary: \"border bg-secondary text-secondary-foreground border border-secondary-border \",\n        // Add a transparent border so that when someone toggles a border on later, it doesn't shift layout/size.\n        ghost: \"border border-transparent\",\n      },\n      // Heights are set as \"min\" heights, because sometimes Ai will place large amount of content\n      // inside buttons. With a min-height they will look appropriate with small amounts of content,\n      // but will expand to fit large amounts of content.\n      size: {\n        default: \"min-h-9 px-4 py-2\",\n        sm: \"min-h-8 rounded-md px-3 text-xs\",\n        lg: \"min-h-10 rounded-md px-8\",\n        icon: \"h-9 w-9\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  },\n)\n\nexport interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  asChild?: boolean\n}\n\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\n    const Comp = asChild ? Slot : \"button\"\n    return (\n      <Comp\n        className={cn(buttonVariants({ variant, size, className }))}\n        ref={ref}\n        {...props}\n      />\n    )\n  },\n)\nButton.displayName = \"Button\"\n\nexport { Button, buttonVariants }\n","size_bytes":2359},"client/src/pages/task-detail.tsx":{"content":"import { useRoute } from \"wouter\";\nimport { Button } from \"@/components/ui/button\";\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { StatusBadge } from \"@/components/status-badge\";\nimport { ExecutionLogPanel } from \"@/components/execution-log-panel\";\nimport { AIReasoningChain } from \"@/components/ai-reasoning-chain\";\nimport { DiffViewer } from \"@/components/diff-viewer\";\nimport { ArrowLeft, GitBranch, Calendar } from \"lucide-react\";\nimport { Link } from \"wouter\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport type { Task } from \"@shared/schema\";\nimport { useEffect, useState } from \"react\";\n\nexport default function TaskDetail() {\n  const [, params] = useRoute(\"/task/:id\");\n  const taskId = params?.id || \"\";\n\n  const { data: task, isLoading } = useQuery<Task>({\n    queryKey: [\"/api/tasks\", taskId],\n    enabled: !!taskId,\n  });\n\n  // SSE for real-time logs\n  const [liveLogs, setLiveLogs] = useState<Task[\"logs\"]>([]);\n\n  useEffect(() => {\n    if (!taskId) return;\n\n    const eventSource = new EventSource(`/api/tasks/${taskId}/logs/stream`);\n\n    eventSource.onmessage = (event) => {\n      const log = JSON.parse(event.data);\n      setLiveLogs((prev) => [...prev, log]);\n    };\n\n    eventSource.onerror = () => {\n      eventSource.close();\n    };\n\n    return () => {\n      eventSource.close();\n    };\n  }, [taskId]);\n\n  const formatTimestamp = (isoString: string) => {\n    const date = new Date(isoString);\n    const now = new Date();\n    const diffMs = now.getTime() - date.getTime();\n    const diffMins = Math.floor(diffMs / 60000);\n\n    if (diffMins < 1) return \"just now\";\n    if (diffMins < 60) return `${diffMins}m ago`;\n    const diffHours = Math.floor(diffMins / 60);\n    if (diffHours < 24) return `${diffHours}h ago`;\n    return `${Math.floor(diffHours / 24)}d ago`;\n  };\n\n  if (isLoading || !task) {\n    return (\n      <div className=\"flex items-center justify-center h-full\">\n        <div className=\"text-muted-foreground\">Loading task...</div>\n      </div>\n    );\n  }\n\n  const allLogs = liveLogs.length > 0 ? liveLogs : task.logs;\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex items-center gap-4\">\n        <Button\n          asChild\n          variant=\"ghost\"\n          size=\"sm\"\n          data-testid=\"button-back\"\n        >\n          <Link href=\"/\">\n            <ArrowLeft className=\"h-4 w-4 mr-1\" />\n            Back\n          </Link>\n        </Button>\n      </div>\n\n      <Card>\n        <CardHeader>\n          <div className=\"flex items-start justify-between\">\n            <div className=\"space-y-2\">\n              <CardTitle className=\"text-xl\" data-testid=\"text-task-title\">\n                {task.title}\n              </CardTitle>\n              <div className=\"flex items-center gap-4 text-sm text-muted-foreground\">\n                <div className=\"flex items-center gap-1\">\n                  <GitBranch className=\"h-3 w-3\" />\n                  <span>{task.repository}</span>\n                </div>\n                <div className=\"flex items-center gap-1\">\n                  <Calendar className=\"h-3 w-3\" />\n                  <span>Started {formatTimestamp(task.createdAt)}</span>\n                </div>\n              </div>\n            </div>\n            <StatusBadge status={task.status} />\n          </div>\n        </CardHeader>\n        <CardContent>\n          <p className=\"text-sm text-foreground\">\n            {task.summary}\n          </p>\n        </CardContent>\n      </Card>\n\n      <div className=\"grid grid-cols-1 lg:grid-cols-3 gap-6\">\n        <div className=\"lg:col-span-2 space-y-6\">\n          <div className=\"h-[500px]\">\n            <ExecutionLogPanel logs={allLogs} />\n          </div>\n          {task.diffs.length > 0 && <DiffViewer files={task.diffs} />}\n        </div>\n\n        <div className=\"space-y-6\">\n          {task.reasoning.length > 0 && (\n            <AIReasoningChain steps={task.reasoning} />\n          )}\n          \n          <Card>\n            <CardHeader>\n              <CardTitle className=\"text-lg font-medium\">Repository Context</CardTitle>\n            </CardHeader>\n            <CardContent>\n              <div className=\"space-y-3 text-sm\">\n                <div>\n                  <div className=\"text-muted-foreground mb-1\">Repository</div>\n                  <div className=\"font-mono\">{task.repository}</div>\n                </div>\n                {task.branch && (\n                  <div>\n                    <div className=\"text-muted-foreground mb-1\">Branch</div>\n                    <div className=\"font-mono\">{task.branch}</div>\n                  </div>\n                )}\n                <div>\n                  <div className=\"text-muted-foreground mb-1\">Progress</div>\n                  <div>{task.progress}%</div>\n                </div>\n                <div>\n                  <div className=\"text-muted-foreground mb-1\">Status</div>\n                  <div className=\"capitalize\">{task.status}</div>\n                </div>\n              </div>\n            </CardContent>\n          </Card>\n        </div>\n      </div>\n    </div>\n  );\n}\n","size_bytes":5085},"client/src/components/examples/DiffViewer.tsx":{"content":"import { DiffViewer } from '../diff-viewer';\n\nconst mockDiffs = [\n  {\n    path: \"src/middleware/auth.ts\",\n    lines: [\n      { lineNumber: 1, type: \"context\" as const, content: \"import { Request, Response, NextFunction } from 'express';\" },\n      { lineNumber: 2, type: \"context\" as const, content: \"import jwt from 'jsonwebtoken';\" },\n      { lineNumber: 3, type: \"remove\" as const, content: \"const SECRET = 'hardcoded-secret-key';\" },\n      { lineNumber: 3, type: \"add\" as const, content: \"import { getJWTSecret } from '../config/secrets';\" },\n      { lineNumber: 4, type: \"context\" as const, content: \"\" },\n      { lineNumber: 5, type: \"context\" as const, content: \"export async function authMiddleware(req: Request, res: Response, next: NextFunction) {\" },\n    ],\n  },\n  {\n    path: \"src/config/secrets.ts\",\n    lines: [\n      { lineNumber: 1, type: \"add\" as const, content: \"export function getJWTSecret(): string {\" },\n      { lineNumber: 2, type: \"add\" as const, content: \"  return process.env.JWT_SECRET || '';\" },\n      { lineNumber: 3, type: \"add\" as const, content: \"}\" },\n    ],\n  },\n];\n\nexport default function DiffViewerExample() {\n  return <DiffViewer files={mockDiffs} />;\n}\n","size_bytes":1191},"client/src/components/task-card.tsx":{"content":"import { Card, CardContent, CardFooter, CardHeader } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { StatusBadge } from \"./status-badge\";\nimport { Eye, X } from \"lucide-react\";\nimport { Link } from \"wouter\";\n\ntype TaskStatus = \"planning\" | \"executing\" | \"completed\" | \"failed\" | \"queued\";\n\ninterface TaskCardProps {\n  id: string;\n  title: string;\n  status: TaskStatus;\n  timestamp: string;\n  summary: string;\n  progress?: number;\n  repository?: string;\n}\n\nexport function TaskCard({\n  id,\n  title,\n  status,\n  timestamp,\n  summary,\n  progress = 0,\n  repository,\n}: TaskCardProps) {\n  return (\n    <Card className=\"hover-elevate\" data-testid={`card-task-${id}`}>\n      <CardHeader className=\"space-y-0 pb-3\">\n        <div className=\"flex items-start justify-between gap-3\">\n          <div className=\"flex-1 min-w-0\">\n            <h3 className=\"text-base font-medium truncate\" data-testid={`text-task-title-${id}`}>\n              {title}\n            </h3>\n            <div className=\"flex items-center gap-2 mt-1\">\n              {repository && (\n                <span className=\"text-xs text-muted-foreground\">{repository}</span>\n              )}\n              <span className=\"text-xs text-muted-foreground\">{timestamp}</span>\n            </div>\n          </div>\n          <StatusBadge status={status} />\n        </div>\n      </CardHeader>\n\n      <CardContent className=\"pb-3\">\n        <p className=\"text-sm text-foreground line-clamp-2\" data-testid={`text-task-summary-${id}`}>\n          {summary}\n        </p>\n        \n        {progress > 0 && (\n          <div className=\"mt-3\">\n            <div className=\"flex items-center justify-between text-xs mb-1\">\n              <span className=\"text-muted-foreground\">Progress</span>\n              <span className=\"text-foreground\">{progress}%</span>\n            </div>\n            <div className=\"h-1.5 bg-muted rounded-full overflow-hidden\">\n              <div\n                className=\"h-full bg-primary transition-all duration-300\"\n                style={{ width: `${progress}%` }}\n              />\n            </div>\n          </div>\n        )}\n      </CardContent>\n\n      <CardFooter className=\"gap-2 pt-0\">\n        <Button\n          asChild\n          variant=\"outline\"\n          size=\"sm\"\n          className=\"flex-1\"\n          data-testid={`button-view-task-${id}`}\n        >\n          <Link href={`/task/${id}`}>\n            <Eye className=\"h-3 w-3 mr-1\" />\n            View Details\n          </Link>\n        </Button>\n        {status === \"executing\" && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            data-testid={`button-cancel-task-${id}`}\n            onClick={() => console.log(`Cancel task ${id}`)}\n          >\n            <X className=\"h-3 w-3 mr-1\" />\n            Cancel\n          </Button>\n        )}\n      </CardFooter>\n    </Card>\n  );\n}\n","size_bytes":2874},"client/src/components/ui/tooltip.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as TooltipPrimitive from \"@radix-ui/react-tooltip\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst TooltipProvider = TooltipPrimitive.Provider\n\nconst Tooltip = TooltipPrimitive.Root\n\nconst TooltipTrigger = TooltipPrimitive.Trigger\n\nconst TooltipContent = React.forwardRef<\n  React.ElementRef<typeof TooltipPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>\n>(({ className, sideOffset = 4, ...props }, ref) => (\n  <TooltipPrimitive.Content\n    ref={ref}\n    sideOffset={sideOffset}\n    className={cn(\n      \"z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]\",\n      className\n    )}\n    {...props}\n  />\n))\nTooltipContent.displayName = TooltipPrimitive.Content.displayName\n\nexport { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }\n","size_bytes":1209},"client/src/components/ui/radio-group.tsx":{"content":"import * as React from \"react\"\nimport * as RadioGroupPrimitive from \"@radix-ui/react-radio-group\"\nimport { Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst RadioGroup = React.forwardRef<\n  React.ElementRef<typeof RadioGroupPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>\n>(({ className, ...props }, ref) => {\n  return (\n    <RadioGroupPrimitive.Root\n      className={cn(\"grid gap-2\", className)}\n      {...props}\n      ref={ref}\n    />\n  )\n})\nRadioGroup.displayName = RadioGroupPrimitive.Root.displayName\n\nconst RadioGroupItem = React.forwardRef<\n  React.ElementRef<typeof RadioGroupPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>\n>(({ className, ...props }, ref) => {\n  return (\n    <RadioGroupPrimitive.Item\n      ref={ref}\n      className={cn(\n        \"aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    >\n      <RadioGroupPrimitive.Indicator className=\"flex items-center justify-center\">\n        <Circle className=\"h-2.5 w-2.5 fill-current text-current\" />\n      </RadioGroupPrimitive.Indicator>\n    </RadioGroupPrimitive.Item>\n  )\n})\nRadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName\n\nexport { RadioGroup, RadioGroupItem }\n","size_bytes":1467},"client/src/components/ui/menubar.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as MenubarPrimitive from \"@radix-ui/react-menubar\"\nimport { Check, ChevronRight, Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction MenubarMenu({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.Menu>) {\n  return <MenubarPrimitive.Menu {...props} />\n}\n\nfunction MenubarGroup({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.Group>) {\n  return <MenubarPrimitive.Group {...props} />\n}\n\nfunction MenubarPortal({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.Portal>) {\n  return <MenubarPrimitive.Portal {...props} />\n}\n\nfunction MenubarRadioGroup({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {\n  return <MenubarPrimitive.RadioGroup {...props} />\n}\n\nfunction MenubarSub({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.Sub>) {\n  return <MenubarPrimitive.Sub data-slot=\"menubar-sub\" {...props} />\n}\n\nconst Menubar = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"flex h-10 items-center space-x-1 rounded-md border bg-background p-1\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubar.displayName = MenubarPrimitive.Root.displayName\n\nconst MenubarTrigger = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName\n\nconst MenubarSubTrigger = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {\n    inset?: boolean\n  }\n>(({ className, inset, children, ...props }, ref) => (\n  <MenubarPrimitive.SubTrigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <ChevronRight className=\"ml-auto h-4 w-4\" />\n  </MenubarPrimitive.SubTrigger>\n))\nMenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName\n\nconst MenubarSubContent = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.SubContent>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.SubContent\n    ref={ref}\n    className={cn(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName\n\nconst MenubarContent = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>\n>(\n  (\n    { className, align = \"start\", alignOffset = -4, sideOffset = 8, ...props },\n    ref\n  ) => (\n    <MenubarPrimitive.Portal>\n      <MenubarPrimitive.Content\n        ref={ref}\n        align={align}\n        alignOffset={alignOffset}\n        sideOffset={sideOffset}\n        className={cn(\n          \"z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]\",\n          className\n        )}\n        {...props}\n      />\n    </MenubarPrimitive.Portal>\n  )\n)\nMenubarContent.displayName = MenubarPrimitive.Content.displayName\n\nconst MenubarItem = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <MenubarPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarItem.displayName = MenubarPrimitive.Item.displayName\n\nconst MenubarCheckboxItem = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>\n>(({ className, children, checked, ...props }, ref) => (\n  <MenubarPrimitive.CheckboxItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    checked={checked}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <MenubarPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </MenubarPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </MenubarPrimitive.CheckboxItem>\n))\nMenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName\n\nconst MenubarRadioItem = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.RadioItem>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>\n>(({ className, children, ...props }, ref) => (\n  <MenubarPrimitive.RadioItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <MenubarPrimitive.ItemIndicator>\n        <Circle className=\"h-2 w-2 fill-current\" />\n      </MenubarPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </MenubarPrimitive.RadioItem>\n))\nMenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName\n\nconst MenubarLabel = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <MenubarPrimitive.Label\n    ref={ref}\n    className={cn(\n      \"px-2 py-1.5 text-sm font-semibold\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarLabel.displayName = MenubarPrimitive.Label.displayName\n\nconst MenubarSeparator = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nMenubarSeparator.displayName = MenubarPrimitive.Separator.displayName\n\nconst MenubarShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nMenubarShortcut.displayname = \"MenubarShortcut\"\n\nexport {\n  Menubar,\n  MenubarMenu,\n  MenubarTrigger,\n  MenubarContent,\n  MenubarItem,\n  MenubarSeparator,\n  MenubarLabel,\n  MenubarCheckboxItem,\n  MenubarRadioGroup,\n  MenubarRadioItem,\n  MenubarPortal,\n  MenubarSubContent,\n  MenubarSubTrigger,\n  MenubarGroup,\n  MenubarSub,\n  MenubarShortcut,\n}\n","size_bytes":8605},"client/src/components/ui/skeleton.tsx":{"content":"import { cn } from \"@/lib/utils\"\n\nfunction Skeleton({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) {\n  return (\n    <div\n      className={cn(\"animate-pulse rounded-md bg-muted\", className)}\n      {...props}\n    />\n  )\n}\n\nexport { Skeleton }\n","size_bytes":261},"client/src/components/ui/separator.tsx":{"content":"import * as React from \"react\"\nimport * as SeparatorPrimitive from \"@radix-ui/react-separator\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Separator = React.forwardRef<\n  React.ElementRef<typeof SeparatorPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>\n>(\n  (\n    { className, orientation = \"horizontal\", decorative = true, ...props },\n    ref\n  ) => (\n    <SeparatorPrimitive.Root\n      ref={ref}\n      decorative={decorative}\n      orientation={orientation}\n      className={cn(\n        \"shrink-0 bg-border\",\n        orientation === \"horizontal\" ? \"h-[1px] w-full\" : \"h-full w-[1px]\",\n        className\n      )}\n      {...props}\n    />\n  )\n)\nSeparator.displayName = SeparatorPrimitive.Root.displayName\n\nexport { Separator }\n","size_bytes":756},"client/src/pages/dashboard.tsx":{"content":"import { MetricsCard } from \"@/components/metrics-card\";\nimport { TaskCard } from \"@/components/task-card\";\nimport { EventLogTable } from \"@/components/event-log-table\";\nimport { Activity, CheckCircle, Clock, Webhook } from \"lucide-react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport type { Task, GithubEvent } from \"@shared/schema\";\n\ninterface Metrics {\n  activeTasks: number;\n  successRate: string;\n  avgTime: string;\n  webhooks: number;\n}\n\nexport default function Dashboard() {\n  const { data: metrics } = useQuery<Metrics>({\n    queryKey: [\"/api/metrics\"],\n  });\n\n  const { data: tasks = [] } = useQuery<Task[]>({\n    queryKey: [\"/api/tasks/active\"],\n  });\n\n  const { data: events = [] } = useQuery<GithubEvent[]>({\n    queryKey: [\"/api/events/recent\"],\n  });\n\n  const metricsData = [\n    {\n      title: \"Active Tasks\",\n      value: metrics?.activeTasks?.toString() || \"0\",\n      icon: Activity,\n      trend: \"+2 from last hour\",\n    },\n    {\n      title: \"Success Rate\",\n      value: metrics?.successRate || \"0%\",\n      icon: CheckCircle,\n      trend: \"+2% this week\",\n    },\n    {\n      title: \"Avg Time\",\n      value: metrics?.avgTime || \"0m\",\n      icon: Clock,\n      trend: \"-0.5m improvement\",\n    },\n    {\n      title: \"Webhooks\",\n      value: metrics?.webhooks?.toString() || \"0\",\n      icon: Webhook,\n      trend: \"Today\",\n    },\n  ];\n\n  const formatTimestamp = (isoString: string) => {\n    const date = new Date(isoString);\n    const now = new Date();\n    const diffMs = now.getTime() - date.getTime();\n    const diffMins = Math.floor(diffMs / 60000);\n\n    if (diffMins < 1) return \"just now\";\n    if (diffMins < 60) return `${diffMins}m ago`;\n    const diffHours = Math.floor(diffMins / 60);\n    if (diffHours < 24) return `${diffHours}h ago`;\n    return `${Math.floor(diffHours / 24)}d ago`;\n  };\n\n  return (\n    <div className=\"space-y-6\">\n      <div>\n        <h1 className=\"text-2xl font-semibold\" data-testid=\"text-page-title\">\n          Dashboard\n        </h1>\n        <p className=\"text-sm text-muted-foreground mt-1\">\n          Monitor autonomous development workflows and task execution\n        </p>\n      </div>\n\n      <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4\">\n        {metricsData.map((metric) => (\n          <MetricsCard key={metric.title} {...metric} />\n        ))}\n      </div>\n\n      <div>\n        <h2 className=\"text-lg font-medium mb-3\">Active Tasks</h2>\n        {tasks.length === 0 ? (\n          <div className=\"text-center py-12 text-muted-foreground\">\n            No active tasks. Waiting for GitHub webhooks...\n          </div>\n        ) : (\n          <div className=\"grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-3 gap-4\">\n            {tasks.map((task) => (\n              <TaskCard\n                key={task.id}\n                id={task.id}\n                title={task.title}\n                status={task.status}\n                timestamp={formatTimestamp(task.createdAt)}\n                summary={task.summary}\n                progress={task.progress}\n                repository={task.repository}\n              />\n            ))}\n          </div>\n        )}\n      </div>\n\n      <EventLogTable events={events.map((e) => ({\n        ...e,\n        timestamp: formatTimestamp(e.timestamp),\n      }))} />\n    </div>\n  );\n}\n","size_bytes":3295},"design_guidelines.md":{"content":"# AI GitHub Agent Dashboard - Design Guidelines\n\n## Design Approach\n\n**Selected Framework:** Design System Approach inspired by **Linear, GitHub, and VS Code**\n\n**Rationale:** Developer productivity tool requiring clarity, information density, and functional excellence. The interface must communicate complex state, logs, and code diffs efficiently while maintaining visual hierarchy across real-time data streams.\n\n**Design Principles:**\n- Information density over decoration\n- Scannable data with clear visual hierarchy\n- Functional clarity for technical workflows\n- Spatial consistency for cognitive efficiency\n\n---\n\n## Typography System\n\n**Font Stack:**\n- **Primary:** Inter (UI, headings, labels) - Clean, technical aesthetic\n- **Monospace:** JetBrains Mono (code, logs, diffs) - High legibility for technical content\n\n**Type Scale:**\n- **Page Titles:** text-2xl font-semibold (Dashboard, Task Details)\n- **Section Headers:** text-lg font-medium (Active Tasks, Execution Log)\n- **Card Titles:** text-base font-medium (Task names, PR titles)\n- **Body/Labels:** text-sm (Status labels, metadata, descriptions)\n- **Code/Logs:** text-xs font-mono (Log streams, code snippets, diffs)\n- **Timestamps/Meta:** text-xs opacity-70 (Relative times, commit SHAs)\n\n---\n\n## Layout System\n\n**Spacing Primitives:** Use Tailwind units of **2, 3, 4, 6, 8, 12** exclusively\n- Component padding: p-4 to p-6\n- Section spacing: gap-4 to gap-6\n- Card spacing: p-4 internally, gap-3 between elements\n- Page margins: p-6 to p-8\n\n**Grid Structure:**\n- **Sidebar:** Fixed w-64 for navigation and context panel\n- **Main Content:** flex-1 with max-w-7xl container\n- **Multi-column layouts:** grid-cols-2 for task cards on large screens, single column on mobile\n\n---\n\n## Component Library\n\n### Navigation & Layout\n\n**Sidebar Navigation:**\n- Fixed left sidebar (w-64) with vertical navigation stack\n- Navigation items: px-3 py-2 with icons (16px) + labels\n- Active state: distinct background treatment\n- Sections: Dashboard, Active Tasks, History, Settings, GitHub Connection Status\n\n**Top Bar:**\n- Full-width header with breadcrumb navigation\n- Right-aligned: Refresh status indicator, GitHub account info, settings icon\n- Height: h-14 with border-b separator\n\n### Core Components\n\n**Task Cards:**\n- Elevated cards with subtle border and rounded corners (rounded-lg)\n- Header: Task title + status badge + timestamp in single row\n- Body: AI reasoning summary (2-3 lines truncated)\n- Footer: Progress indicator + action buttons (View Details, Cancel)\n- Status badges: Small pills (px-2 py-1 rounded-full text-xs) showing Planning/Executing/Complete states\n\n**Execution Log Panel:**\n- Full-height scrollable container with monospace text\n- Line numbers in gutter (w-12)\n- Log entries: timestamp + level indicator + message\n- Auto-scroll to bottom with scroll lock toggle\n- Syntax highlighting for errors (red accent), warnings (amber accent), success (green accent)\n\n**Diff Viewer:**\n- Split-pane layout (50/50) for before/after or unified diff view toggle\n- Line-by-line comparison with +/- indicators in gutter\n- Syntax highlighting for code\n- Collapsible unchanged sections\n- Header showing file path breadcrumb\n\n**AI Reasoning Chain:**\n- Vertical timeline/stepper layout\n- Each step: Circle indicator + timestamp + reasoning text + confidence score\n- Expandable sections for detailed context\n- Visual connection lines between steps\n\n**Repository Context Panel:**\n- Tree view of repository structure (collapsible folders)\n- File icons indicating type (folders, JS, Python, etc.)\n- Active files highlighted\n- Metadata panel: Branch name, last commit, open issues count\n\n### Data Display\n\n**Status Indicators:**\n- Running: Animated pulse effect on icon\n- Success: Checkmark icon\n- Failed: X icon with error badge\n- Queued: Clock icon\n- Badges use consistent sizing: h-6 with icon + label\n\n**Metrics Cards:**\n- Grid of 3-4 metric cards (grid-cols-4)\n- Large number (text-3xl font-bold)\n- Label below (text-sm)\n- Icon top-right corner\n- Examples: Active Tasks, Success Rate, Avg Execution Time, Webhooks Received\n\n**Event Log Table:**\n- Compact rows with alternating subtle background\n- Columns: Timestamp | Event Type | Repository | Action | Status\n- Sortable headers\n- Expandable row detail on click\n- Sticky header when scrolling\n\n### Interactive Elements\n\n**Action Buttons:**\n- Primary: Solid background, medium weight\n- Secondary: Border treatment\n- Icon buttons: Square (h-8 w-8) with centered icon\n- Button groups for related actions (Approve/Reject, Run/Cancel)\n\n**Input Forms:**\n- Repository selector: Searchable dropdown\n- Configuration inputs: Single-column form layout with clear labels above inputs\n- Spacing: gap-4 between form fields\n- Help text: text-xs below inputs\n\n---\n\n## Page Layouts\n\n### Dashboard (Home)\n**Structure:**\n1. Metrics row (grid-cols-4) - Task statistics\n2. Active Tasks section - Grid of task cards (grid-cols-2 lg:grid-cols-3)\n3. Recent Events - Table showing last 10 webhook events\n4. Quick Actions - Button row for common operations\n\n### Task Detail View\n**Two-column split:**\n- **Left (60%):** Execution log with live streaming\n- **Right (40%):** \n  - Task metadata card\n  - AI reasoning chain\n  - Repository context panel\n\n### Diff Review\n**Full-width layout:**\n- File selector tabs at top\n- Diff viewer taking full viewport height\n- Bottom action bar: Approve/Request Changes/Comment buttons\n\n### Settings\n**Single-column form:**\n- Grouped sections with clear headings\n- GitHub connection status with reconnect button\n- OpenAI API configuration\n- Webhook endpoint display (read-only with copy button)\n\n---\n\n## Key Interactions\n\n**Live Updates:**\n- Real-time log streaming with smooth auto-scroll\n- Task status updates without page refresh\n- Toast notifications for completed tasks (top-right, auto-dismiss)\n\n**Progressive Disclosure:**\n- Expandable sections for detailed logs\n- Collapsed code blocks with line count indicator\n- Drawer for repository file browser (slides from right)\n\n---\n\n## Accessibility\n\n- Consistent focus states on all interactive elements\n- Keyboard navigation through task cards and logs\n- ARIA labels for status indicators and icons\n- High contrast for code syntax and diff markers","size_bytes":6218},"client/src/lib/queryClient.ts":{"content":"import { QueryClient, QueryFunction } from \"@tanstack/react-query\";\n\nasync function throwIfResNotOk(res: Response) {\n  if (!res.ok) {\n    const text = (await res.text()) || res.statusText;\n    throw new Error(`${res.status}: ${text}`);\n  }\n}\n\nexport async function apiRequest(\n  method: string,\n  url: string,\n  data?: unknown | undefined,\n): Promise<Response> {\n  const res = await fetch(url, {\n    method,\n    headers: data ? { \"Content-Type\": \"application/json\" } : {},\n    body: data ? JSON.stringify(data) : undefined,\n    credentials: \"include\",\n  });\n\n  await throwIfResNotOk(res);\n  return res;\n}\n\ntype UnauthorizedBehavior = \"returnNull\" | \"throw\";\nexport const getQueryFn: <T>(options: {\n  on401: UnauthorizedBehavior;\n}) => QueryFunction<T> =\n  ({ on401: unauthorizedBehavior }) =>\n  async ({ queryKey }) => {\n    const res = await fetch(queryKey.join(\"/\") as string, {\n      credentials: \"include\",\n    });\n\n    if (unauthorizedBehavior === \"returnNull\" && res.status === 401) {\n      return null;\n    }\n\n    await throwIfResNotOk(res);\n    return await res.json();\n  };\n\nexport const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      queryFn: getQueryFn({ on401: \"throw\" }),\n      refetchInterval: false,\n      refetchOnWindowFocus: false,\n      staleTime: Infinity,\n      retry: false,\n    },\n    mutations: {\n      retry: false,\n    },\n  },\n});\n","size_bytes":1383},"client/src/components/app-sidebar.tsx":{"content":"import { Activity, GitBranch, History, Home, Settings, Zap } from \"lucide-react\";\nimport { Link, useLocation } from \"wouter\";\nimport {\n  Sidebar,\n  SidebarContent,\n  SidebarGroup,\n  SidebarGroupContent,\n  SidebarGroupLabel,\n  SidebarMenu,\n  SidebarMenuButton,\n  SidebarMenuItem,\n  SidebarHeader,\n  SidebarFooter,\n} from \"@/components/ui/sidebar\";\nimport { Badge } from \"@/components/ui/badge\";\n\nconst menuItems = [\n  {\n    title: \"Dashboard\",\n    url: \"/\",\n    icon: Home,\n  },\n  {\n    title: \"Active Tasks\",\n    url: \"/tasks\",\n    icon: Activity,\n    badge: 3,\n  },\n  {\n    title: \"History\",\n    url: \"/history\",\n    icon: History,\n  },\n  {\n    title: \"Settings\",\n    url: \"/settings\",\n    icon: Settings,\n  },\n];\n\nexport function AppSidebar() {\n  const [location] = useLocation();\n\n  return (\n    <Sidebar>\n      <SidebarHeader className=\"p-4 border-b border-sidebar-border\">\n        <div className=\"flex items-center gap-2\">\n          <div className=\"flex h-8 w-8 items-center justify-center rounded-md bg-sidebar-primary\">\n            <Zap className=\"h-4 w-4 text-sidebar-primary-foreground\" />\n          </div>\n          <div>\n            <div className=\"text-sm font-semibold text-sidebar-foreground\">AI GitHub Agent</div>\n            <div className=\"text-xs text-muted-foreground\">Autonomous Dev</div>\n          </div>\n        </div>\n      </SidebarHeader>\n      \n      <SidebarContent>\n        <SidebarGroup>\n          <SidebarGroupLabel>Navigation</SidebarGroupLabel>\n          <SidebarGroupContent>\n            <SidebarMenu>\n              {menuItems.map((item) => (\n                <SidebarMenuItem key={item.title}>\n                  <SidebarMenuButton\n                    asChild\n                    isActive={location === item.url}\n                    data-testid={`link-${item.title.toLowerCase().replace(/\\s+/g, '-')}`}\n                  >\n                    <Link href={item.url}>\n                      <item.icon className=\"h-4 w-4\" />\n                      <span>{item.title}</span>\n                      {item.badge && (\n                        <Badge variant=\"secondary\" className=\"ml-auto h-5 px-1.5 text-xs\">\n                          {item.badge}\n                        </Badge>\n                      )}\n                    </Link>\n                  </SidebarMenuButton>\n                </SidebarMenuItem>\n              ))}\n            </SidebarMenu>\n          </SidebarGroupContent>\n        </SidebarGroup>\n\n        <SidebarGroup>\n          <SidebarGroupLabel>Connection</SidebarGroupLabel>\n          <SidebarGroupContent className=\"px-3\">\n            <div className=\"space-y-2\">\n              <div className=\"flex items-center justify-between text-xs\">\n                <span className=\"text-muted-foreground\">GitHub</span>\n                <div className=\"flex items-center gap-1\">\n                  <div className=\"h-2 w-2 rounded-full bg-chart-2\" />\n                  <span className=\"text-foreground\">Connected</span>\n                </div>\n              </div>\n              <div className=\"flex items-center justify-between text-xs\">\n                <span className=\"text-muted-foreground\">OpenAI</span>\n                <div className=\"flex items-center gap-1\">\n                  <div className=\"h-2 w-2 rounded-full bg-chart-2\" />\n                  <span className=\"text-foreground\">Active</span>\n                </div>\n              </div>\n            </div>\n          </SidebarGroupContent>\n        </SidebarGroup>\n      </SidebarContent>\n\n      <SidebarFooter className=\"p-4 border-t border-sidebar-border\">\n        <div className=\"flex items-center gap-2\">\n          <GitBranch className=\"h-4 w-4 text-muted-foreground\" />\n          <div className=\"flex-1 text-xs text-muted-foreground truncate\">\n            octocat/demo-repo\n          </div>\n        </div>\n      </SidebarFooter>\n    </Sidebar>\n  );\n}\n","size_bytes":3840},"client/src/components/ui/sidebar.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, VariantProps } from \"class-variance-authority\"\nimport { PanelLeftIcon } from \"lucide-react\"\n\nimport { useIsMobile } from \"@/hooks/use-mobile\"\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\nimport { Input } from \"@/components/ui/input\"\nimport { Separator } from \"@/components/ui/separator\"\nimport {\n  Sheet,\n  SheetContent,\n  SheetDescription,\n  SheetHeader,\n  SheetTitle,\n} from \"@/components/ui/sheet\"\nimport { Skeleton } from \"@/components/ui/skeleton\"\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\"\n\nconst SIDEBAR_COOKIE_NAME = \"sidebar_state\"\nconst SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7\nconst SIDEBAR_WIDTH = \"16rem\"\nconst SIDEBAR_WIDTH_MOBILE = \"18rem\"\nconst SIDEBAR_WIDTH_ICON = \"3rem\"\nconst SIDEBAR_KEYBOARD_SHORTCUT = \"b\"\n\ntype SidebarContextProps = {\n  state: \"expanded\" | \"collapsed\"\n  open: boolean\n  setOpen: (open: boolean) => void\n  openMobile: boolean\n  setOpenMobile: (open: boolean) => void\n  isMobile: boolean\n  toggleSidebar: () => void\n}\n\nconst SidebarContext = React.createContext<SidebarContextProps | null>(null)\n\nfunction useSidebar() {\n  const context = React.useContext(SidebarContext)\n  if (!context) {\n    throw new Error(\"useSidebar must be used within a SidebarProvider.\")\n  }\n\n  return context\n}\n\nfunction SidebarProvider({\n  defaultOpen = true,\n  open: openProp,\n  onOpenChange: setOpenProp,\n  className,\n  style,\n  children,\n  ...props\n}: React.ComponentProps<\"div\"> & {\n  defaultOpen?: boolean\n  open?: boolean\n  onOpenChange?: (open: boolean) => void\n}) {\n  const isMobile = useIsMobile()\n  const [openMobile, setOpenMobile] = React.useState(false)\n\n  // This is the internal state of the sidebar.\n  // We use openProp and setOpenProp for control from outside the component.\n  const [_open, _setOpen] = React.useState(defaultOpen)\n  const open = openProp ?? _open\n  const setOpen = React.useCallback(\n    (value: boolean | ((value: boolean) => boolean)) => {\n      const openState = typeof value === \"function\" ? value(open) : value\n      if (setOpenProp) {\n        setOpenProp(openState)\n      } else {\n        _setOpen(openState)\n      }\n\n      // This sets the cookie to keep the sidebar state.\n      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`\n    },\n    [setOpenProp, open]\n  )\n\n  // Helper to toggle the sidebar.\n  const toggleSidebar = React.useCallback(() => {\n    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open)\n  }, [isMobile, setOpen, setOpenMobile])\n\n  // Adds a keyboard shortcut to toggle the sidebar.\n  React.useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (\n        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&\n        (event.metaKey || event.ctrlKey)\n      ) {\n        event.preventDefault()\n        toggleSidebar()\n      }\n    }\n\n    window.addEventListener(\"keydown\", handleKeyDown)\n    return () => window.removeEventListener(\"keydown\", handleKeyDown)\n  }, [toggleSidebar])\n\n  // We add a state so that we can do data-state=\"expanded\" or \"collapsed\".\n  // This makes it easier to style the sidebar with Tailwind classes.\n  const state = open ? \"expanded\" : \"collapsed\"\n\n  const contextValue = React.useMemo<SidebarContextProps>(\n    () => ({\n      state,\n      open,\n      setOpen,\n      isMobile,\n      openMobile,\n      setOpenMobile,\n      toggleSidebar,\n    }),\n    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]\n  )\n\n  return (\n    <SidebarContext.Provider value={contextValue}>\n      <TooltipProvider delayDuration={0}>\n        <div\n          data-slot=\"sidebar-wrapper\"\n          style={\n            {\n              \"--sidebar-width\": SIDEBAR_WIDTH,\n              \"--sidebar-width-icon\": SIDEBAR_WIDTH_ICON,\n              ...style,\n            } as React.CSSProperties\n          }\n          className={cn(\n            \"group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full\",\n            className\n          )}\n          {...props}\n        >\n          {children}\n        </div>\n      </TooltipProvider>\n    </SidebarContext.Provider>\n  )\n}\n\nfunction Sidebar({\n  side = \"left\",\n  variant = \"sidebar\",\n  collapsible = \"offcanvas\",\n  className,\n  children,\n  ...props\n}: React.ComponentProps<\"div\"> & {\n  side?: \"left\" | \"right\"\n  variant?: \"sidebar\" | \"floating\" | \"inset\"\n  collapsible?: \"offcanvas\" | \"icon\" | \"none\"\n}) {\n  const { isMobile, state, openMobile, setOpenMobile } = useSidebar()\n\n  if (collapsible === \"none\") {\n    return (\n      <div\n        data-slot=\"sidebar\"\n        className={cn(\n          \"bg-sidebar text-sidebar-foreground flex h-full w-[var(--sidebar-width)] flex-col\",\n          className\n        )}\n        {...props}\n      >\n        {children}\n      </div>\n    )\n  }\n\n  if (isMobile) {\n    return (\n      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>\n        <SheetContent\n          data-sidebar=\"sidebar\"\n          data-slot=\"sidebar\"\n          data-mobile=\"true\"\n          className=\"bg-sidebar text-sidebar-foreground w-[var(--sidebar-width)] p-0 [&>button]:hidden\"\n          style={\n            {\n              \"--sidebar-width\": SIDEBAR_WIDTH_MOBILE,\n            } as React.CSSProperties\n          }\n          side={side}\n        >\n          <SheetHeader className=\"sr-only\">\n            <SheetTitle>Sidebar</SheetTitle>\n            <SheetDescription>Displays the mobile sidebar.</SheetDescription>\n          </SheetHeader>\n          <div className=\"flex h-full w-full flex-col\">{children}</div>\n        </SheetContent>\n      </Sheet>\n    )\n  }\n\n  return (\n    <div\n      className=\"group peer text-sidebar-foreground hidden md:block\"\n      data-state={state}\n      data-collapsible={state === \"collapsed\" ? collapsible : \"\"}\n      data-variant={variant}\n      data-side={side}\n      data-slot=\"sidebar\"\n    >\n      {/* This is what handles the sidebar gap on desktop */}\n      <div\n        data-slot=\"sidebar-gap\"\n        className={cn(\n          \"relative w-[var(--sidebar-width)] bg-transparent transition-[width] duration-200 ease-linear\",\n          \"group-data-[collapsible=offcanvas]:w-0\",\n          \"group-data-[side=right]:rotate-180\",\n          variant === \"floating\" || variant === \"inset\"\n            ? \"group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+var(--spacing-4))]\"\n            : \"group-data-[collapsible=icon]:w-[var(--sidebar-width-icon)]\"\n        )}\n      />\n      <div\n        data-slot=\"sidebar-container\"\n        className={cn(\n          \"fixed inset-y-0 z-10 hidden h-svh w-[var(--sidebar-width)] transition-[left,right,width] duration-200 ease-linear md:flex\",\n          side === \"left\"\n            ? \"left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]\"\n            : \"right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]\",\n          // Adjust the padding for floating and inset variants.\n          variant === \"floating\" || variant === \"inset\"\n            ? \"p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+var(--spacing-4)+2px)]\"\n            : \"group-data-[collapsible=icon]:w-[var(--sidebar-width-icon)] group-data-[side=left]:border-r group-data-[side=right]:border-l\",\n          className\n        )}\n        {...props}\n      >\n        <div\n          data-sidebar=\"sidebar\"\n          data-slot=\"sidebar-inner\"\n          className=\"bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm\"\n        >\n          {children}\n        </div>\n      </div>\n    </div>\n  )\n}\n\nfunction SidebarTrigger({\n  className,\n  onClick,\n  ...props\n}: React.ComponentProps<typeof Button>) {\n  const { toggleSidebar } = useSidebar()\n\n  return (\n    <Button\n      data-sidebar=\"trigger\"\n      data-slot=\"sidebar-trigger\"\n      variant=\"ghost\"\n      size=\"icon\"\n      className={cn(\"h-7 w-7\", className)}\n      onClick={(event) => {\n        onClick?.(event)\n        toggleSidebar()\n      }}\n      {...props}\n    >\n      <PanelLeftIcon />\n      <span className=\"sr-only\">Toggle Sidebar</span>\n    </Button>\n  )\n}\n\nfunction SidebarRail({ className, ...props }: React.ComponentProps<\"button\">) {\n  const { toggleSidebar } = useSidebar()\n\n  // Note: Tailwind v3.4 doesn't support \"in-\" selectors. So the rail won't work perfectly.\n  return (\n    <button\n      data-sidebar=\"rail\"\n      data-slot=\"sidebar-rail\"\n      aria-label=\"Toggle Sidebar\"\n      tabIndex={-1}\n      onClick={toggleSidebar}\n      title=\"Toggle Sidebar\"\n      className={cn(\n        \"hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex\",\n        \"in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize\",\n        \"[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize\",\n        \"hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full\",\n        \"[[data-side=left][data-collapsible=offcanvas]_&]:-right-2\",\n        \"[[data-side=right][data-collapsible=offcanvas]_&]:-left-2\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarInset({ className, ...props }: React.ComponentProps<\"main\">) {\n  return (\n    <main\n      data-slot=\"sidebar-inset\"\n      className={cn(\n        \"bg-background relative flex w-full flex-1 flex-col\",\n        \"md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarInput({\n  className,\n  ...props\n}: React.ComponentProps<typeof Input>) {\n  return (\n    <Input\n      data-slot=\"sidebar-input\"\n      data-sidebar=\"input\"\n      className={cn(\"bg-background h-8 w-full shadow-none\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarHeader({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"sidebar-header\"\n      data-sidebar=\"header\"\n      className={cn(\"flex flex-col gap-2 p-2\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarFooter({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"sidebar-footer\"\n      data-sidebar=\"footer\"\n      className={cn(\"flex flex-col gap-2 p-2\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarSeparator({\n  className,\n  ...props\n}: React.ComponentProps<typeof Separator>) {\n  return (\n    <Separator\n      data-slot=\"sidebar-separator\"\n      data-sidebar=\"separator\"\n      className={cn(\"bg-sidebar-border mx-2 w-auto\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarContent({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"sidebar-content\"\n      data-sidebar=\"content\"\n      className={cn(\n        \"flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarGroup({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"sidebar-group\"\n      data-sidebar=\"group\"\n      className={cn(\"relative flex w-full min-w-0 flex-col p-2\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarGroupLabel({\n  className,\n  asChild = false,\n  ...props\n}: React.ComponentProps<\"div\"> & { asChild?: boolean }) {\n  const Comp = asChild ? Slot : \"div\"\n\n  return (\n    <Comp\n      data-slot=\"sidebar-group-label\"\n      data-sidebar=\"group-label\"\n      className={cn(\n        \"text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:h-4 [&>svg]:w-4 [&>svg]:shrink-0\",\n        \"group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarGroupAction({\n  className,\n  asChild = false,\n  ...props\n}: React.ComponentProps<\"button\"> & { asChild?: boolean }) {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      data-slot=\"sidebar-group-action\"\n      data-sidebar=\"group-action\"\n      className={cn(\n        \"text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0\",\n        // Increases the hit area of the button on mobile.\n        \"after:absolute after:-inset-2 md:after:hidden\",\n        \"group-data-[collapsible=icon]:hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarGroupContent({\n  className,\n  ...props\n}: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"sidebar-group-content\"\n      data-sidebar=\"group-content\"\n      className={cn(\"w-full text-sm\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarMenu({ className, ...props }: React.ComponentProps<\"ul\">) {\n  return (\n    <ul\n      data-slot=\"sidebar-menu\"\n      data-sidebar=\"menu\"\n      className={cn(\"flex w-full min-w-0 flex-col gap-1\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarMenuItem({ className, ...props }: React.ComponentProps<\"li\">) {\n  return (\n    <li\n      data-slot=\"sidebar-menu-item\"\n      data-sidebar=\"menu-item\"\n      className={cn(\"group/menu-item relative\", className)}\n      {...props}\n    />\n  )\n}\n\nconst sidebarMenuButtonVariants = cva(\n  \"peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:w-8! group-data-[collapsible=icon]:h-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0\",\n  {\n    variants: {\n      variant: {\n        default: \"hover:bg-sidebar-accent hover:text-sidebar-accent-foreground\",\n        outline:\n          \"bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]\",\n      },\n      size: {\n        default: \"h-8 text-sm\",\n        sm: \"h-7 text-xs\",\n        lg: \"h-12 text-sm group-data-[collapsible=icon]:p-0!\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nfunction SidebarMenuButton({\n  asChild = false,\n  isActive = false,\n  variant = \"default\",\n  size = \"default\",\n  tooltip,\n  className,\n  ...props\n}: React.ComponentProps<\"button\"> & {\n  asChild?: boolean\n  isActive?: boolean\n  tooltip?: string | React.ComponentProps<typeof TooltipContent>\n} & VariantProps<typeof sidebarMenuButtonVariants>) {\n  const Comp = asChild ? Slot : \"button\"\n  const { isMobile, state } = useSidebar()\n\n  const button = (\n    <Comp\n      data-slot=\"sidebar-menu-button\"\n      data-sidebar=\"menu-button\"\n      data-size={size}\n      data-active={isActive}\n      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}\n      {...props}\n    />\n  )\n\n  if (!tooltip) {\n    return button\n  }\n\n  if (typeof tooltip === \"string\") {\n    tooltip = {\n      children: tooltip,\n    }\n  }\n\n  return (\n    <Tooltip>\n      <TooltipTrigger asChild>{button}</TooltipTrigger>\n      <TooltipContent\n        side=\"right\"\n        align=\"center\"\n        hidden={state !== \"collapsed\" || isMobile}\n        {...tooltip}\n      />\n    </Tooltip>\n  )\n}\n\nfunction SidebarMenuAction({\n  className,\n  asChild = false,\n  showOnHover = false,\n  ...props\n}: React.ComponentProps<\"button\"> & {\n  asChild?: boolean\n  showOnHover?: boolean\n}) {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      data-slot=\"sidebar-menu-action\"\n      data-sidebar=\"menu-action\"\n      className={cn(\n        \"text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0\",\n        // Increases the hit area of the button on mobile.\n        \"after:absolute after:-inset-2 md:after:hidden\",\n        \"peer-data-[size=sm]/menu-button:top-1\",\n        \"peer-data-[size=default]/menu-button:top-1.5\",\n        \"peer-data-[size=lg]/menu-button:top-2.5\",\n        \"group-data-[collapsible=icon]:hidden\",\n        showOnHover &&\n          \"peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarMenuBadge({\n  className,\n  ...props\n}: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"sidebar-menu-badge\"\n      data-sidebar=\"menu-badge\"\n      className={cn(\n        \"text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none\",\n        \"peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground\",\n        \"peer-data-[size=sm]/menu-button:top-1\",\n        \"peer-data-[size=default]/menu-button:top-1.5\",\n        \"peer-data-[size=lg]/menu-button:top-2.5\",\n        \"group-data-[collapsible=icon]:hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarMenuSkeleton({\n  className,\n  showIcon = false,\n  ...props\n}: React.ComponentProps<\"div\"> & {\n  showIcon?: boolean\n}) {\n  // Random width between 50 to 90%.\n  const width = React.useMemo(() => {\n    return `${Math.floor(Math.random() * 40) + 50}%`\n  }, [])\n\n  return (\n    <div\n      data-slot=\"sidebar-menu-skeleton\"\n      data-sidebar=\"menu-skeleton\"\n      className={cn(\"flex h-8 items-center gap-2 rounded-md px-2\", className)}\n      {...props}\n    >\n      {showIcon && (\n        <Skeleton\n          className=\"size-4 rounded-md\"\n          data-sidebar=\"menu-skeleton-icon\"\n        />\n      )}\n      <Skeleton\n        className=\"h-4 max-w-[var(--skeleton-width)] flex-1\"\n        data-sidebar=\"menu-skeleton-text\"\n        style={\n          {\n            \"--skeleton-width\": width,\n          } as React.CSSProperties\n        }\n      />\n    </div>\n  )\n}\n\nfunction SidebarMenuSub({ className, ...props }: React.ComponentProps<\"ul\">) {\n  return (\n    <ul\n      data-slot=\"sidebar-menu-sub\"\n      data-sidebar=\"menu-sub\"\n      className={cn(\n        \"border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5\",\n        \"group-data-[collapsible=icon]:hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarMenuSubItem({\n  className,\n  ...props\n}: React.ComponentProps<\"li\">) {\n  return (\n    <li\n      data-slot=\"sidebar-menu-sub-item\"\n      data-sidebar=\"menu-sub-item\"\n      className={cn(\"group/menu-sub-item relative\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarMenuSubButton({\n  asChild = false,\n  size = \"md\",\n  isActive = false,\n  className,\n  ...props\n}: React.ComponentProps<\"a\"> & {\n  asChild?: boolean\n  size?: \"sm\" | \"md\"\n  isActive?: boolean\n}) {\n  const Comp = asChild ? Slot : \"a\"\n\n  return (\n    <Comp\n      data-slot=\"sidebar-menu-sub-button\"\n      data-sidebar=\"menu-sub-button\"\n      data-size={size}\n      data-active={isActive}\n      className={cn(\n        \"text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline outline-2 outline-transparent outline-offset-2 focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0\",\n        \"data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground\",\n        size === \"sm\" && \"text-xs\",\n        size === \"md\" && \"text-sm\",\n        \"group-data-[collapsible=icon]:hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport {\n  Sidebar,\n  SidebarContent,\n  SidebarFooter,\n  SidebarGroup,\n  SidebarGroupAction,\n  SidebarGroupContent,\n  SidebarGroupLabel,\n  SidebarHeader,\n  SidebarInput,\n  SidebarInset,\n  SidebarMenu,\n  SidebarMenuAction,\n  SidebarMenuBadge,\n  SidebarMenuButton,\n  SidebarMenuItem,\n  SidebarMenuSkeleton,\n  SidebarMenuSub,\n  SidebarMenuSubButton,\n  SidebarMenuSubItem,\n  SidebarProvider,\n  SidebarRail,\n  SidebarSeparator,\n  SidebarTrigger,\n  useSidebar,\n}\n","size_bytes":21846},"client/src/components/ui/toast.tsx":{"content":"import * as React from \"react\"\nimport * as ToastPrimitives from \"@radix-ui/react-toast\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ToastProvider = ToastPrimitives.Provider\n\nconst ToastViewport = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Viewport>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Viewport\n    ref={ref}\n    className={cn(\n      \"fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]\",\n      className\n    )}\n    {...props}\n  />\n))\nToastViewport.displayName = ToastPrimitives.Viewport.displayName\n\nconst toastVariants = cva(\n  \"group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full\",\n  {\n    variants: {\n      variant: {\n        default: \"border bg-background text-foreground\",\n        destructive:\n          \"destructive group border-destructive bg-destructive text-destructive-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nconst Toast = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Root>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &\n    VariantProps<typeof toastVariants>\n>(({ className, variant, ...props }, ref) => {\n  return (\n    <ToastPrimitives.Root\n      ref={ref}\n      className={cn(toastVariants({ variant }), className)}\n      {...props}\n    />\n  )\n})\nToast.displayName = ToastPrimitives.Root.displayName\n\nconst ToastAction = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Action>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Action\n    ref={ref}\n    className={cn(\n      \"inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive\",\n      className\n    )}\n    {...props}\n  />\n))\nToastAction.displayName = ToastPrimitives.Action.displayName\n\nconst ToastClose = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Close>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Close\n    ref={ref}\n    className={cn(\n      \"absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600\",\n      className\n    )}\n    toast-close=\"\"\n    {...props}\n  >\n    <X className=\"h-4 w-4\" />\n  </ToastPrimitives.Close>\n))\nToastClose.displayName = ToastPrimitives.Close.displayName\n\nconst ToastTitle = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Title>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Title\n    ref={ref}\n    className={cn(\"text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nToastTitle.displayName = ToastPrimitives.Title.displayName\n\nconst ToastDescription = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Description>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Description\n    ref={ref}\n    className={cn(\"text-sm opacity-90\", className)}\n    {...props}\n  />\n))\nToastDescription.displayName = ToastPrimitives.Description.displayName\n\ntype ToastProps = React.ComponentPropsWithoutRef<typeof Toast>\n\ntype ToastActionElement = React.ReactElement<typeof ToastAction>\n\nexport {\n  type ToastProps,\n  type ToastActionElement,\n  ToastProvider,\n  ToastViewport,\n  Toast,\n  ToastTitle,\n  ToastDescription,\n  ToastClose,\n  ToastAction,\n}\n","size_bytes":4845},"client/src/hooks/use-mobile.tsx":{"content":"import * as React from \"react\"\n\nconst MOBILE_BREAKPOINT = 768\n\nexport function useIsMobile() {\n  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)\n\n  React.useEffect(() => {\n    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)\n    const onChange = () => {\n      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\n    }\n    mql.addEventListener(\"change\", onChange)\n    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\n    return () => mql.removeEventListener(\"change\", onChange)\n  }, [])\n\n  return !!isMobile\n}\n","size_bytes":565},"client/src/components/examples/Settings.tsx":{"content":"import Settings from '../../pages/settings';\n\nexport default function SettingsExample() {\n  return <Settings />;\n}\n","size_bytes":115},"client/src/App.tsx":{"content":"import { Switch, Route } from \"wouter\";\nimport { queryClient } from \"./lib/queryClient\";\nimport { QueryClientProvider } from \"@tanstack/react-query\";\nimport { Toaster } from \"@/components/ui/toaster\";\nimport { TooltipProvider } from \"@/components/ui/tooltip\";\nimport { SidebarProvider, SidebarTrigger } from \"@/components/ui/sidebar\";\nimport { AppSidebar } from \"@/components/app-sidebar\";\nimport { ThemeToggle } from \"@/components/theme-toggle\";\nimport Dashboard from \"@/pages/dashboard\";\nimport TaskDetail from \"@/pages/task-detail\";\nimport Settings from \"@/pages/settings\";\nimport NotFound from \"@/pages/not-found\";\n\nfunction Router() {\n  return (\n    <Switch>\n      <Route path=\"/\" component={Dashboard} />\n      <Route path=\"/task/:id\" component={TaskDetail} />\n      <Route path=\"/settings\" component={Settings} />\n      <Route component={NotFound} />\n    </Switch>\n  );\n}\n\nexport default function App() {\n  const style = {\n    \"--sidebar-width\": \"16rem\",\n    \"--sidebar-width-icon\": \"3rem\",\n  };\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <TooltipProvider>\n        <SidebarProvider style={style as React.CSSProperties}>\n          <div className=\"flex h-screen w-full\">\n            <AppSidebar />\n            <div className=\"flex flex-col flex-1\">\n              <header className=\"flex items-center justify-between px-6 py-3 border-b border-border\">\n                <SidebarTrigger data-testid=\"button-sidebar-toggle\" />\n                <ThemeToggle />\n              </header>\n              <main className=\"flex-1 overflow-auto p-6\">\n                <Router />\n              </main>\n            </div>\n          </div>\n        </SidebarProvider>\n        <Toaster />\n      </TooltipProvider>\n    </QueryClientProvider>\n  );\n}\n","size_bytes":1754},"client/src/components/ui/command.tsx":{"content":"import * as React from \"react\"\nimport { type DialogProps } from \"@radix-ui/react-dialog\"\nimport { Command as CommandPrimitive } from \"cmdk\"\nimport { Search } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Dialog, DialogContent } from \"@/components/ui/dialog\"\n\nconst Command = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive\n    ref={ref}\n    className={cn(\n      \"flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nCommand.displayName = CommandPrimitive.displayName\n\nconst CommandDialog = ({ children, ...props }: DialogProps) => {\n  return (\n    <Dialog {...props}>\n      <DialogContent className=\"overflow-hidden p-0 shadow-lg\">\n        <Command className=\"[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5\">\n          {children}\n        </Command>\n      </DialogContent>\n    </Dialog>\n  )\n}\n\nconst CommandInput = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Input>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>\n>(({ className, ...props }, ref) => (\n  <div className=\"flex items-center border-b px-3\" cmdk-input-wrapper=\"\">\n    <Search className=\"mr-2 h-4 w-4 shrink-0 opacity-50\" />\n    <CommandPrimitive.Input\n      ref={ref}\n      className={cn(\n        \"flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    />\n  </div>\n))\n\nCommandInput.displayName = CommandPrimitive.Input.displayName\n\nconst CommandList = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.List\n    ref={ref}\n    className={cn(\"max-h-[300px] overflow-y-auto overflow-x-hidden\", className)}\n    {...props}\n  />\n))\n\nCommandList.displayName = CommandPrimitive.List.displayName\n\nconst CommandEmpty = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Empty>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>\n>((props, ref) => (\n  <CommandPrimitive.Empty\n    ref={ref}\n    className=\"py-6 text-center text-sm\"\n    {...props}\n  />\n))\n\nCommandEmpty.displayName = CommandPrimitive.Empty.displayName\n\nconst CommandGroup = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Group>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Group\n    ref={ref}\n    className={cn(\n      \"overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\n\nCommandGroup.displayName = CommandPrimitive.Group.displayName\n\nconst CommandSeparator = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 h-px bg-border\", className)}\n    {...props}\n  />\n))\nCommandSeparator.displayName = CommandPrimitive.Separator.displayName\n\nconst CommandItem = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n      className\n    )}\n    {...props}\n  />\n))\n\nCommandItem.displayName = CommandPrimitive.Item.displayName\n\nconst CommandShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nCommandShortcut.displayName = \"CommandShortcut\"\n\nexport {\n  Command,\n  CommandDialog,\n  CommandInput,\n  CommandList,\n  CommandEmpty,\n  CommandGroup,\n  CommandItem,\n  CommandShortcut,\n  CommandSeparator,\n}\n","size_bytes":4885},"client/src/components/ui/aspect-ratio.tsx":{"content":"import * as AspectRatioPrimitive from \"@radix-ui/react-aspect-ratio\"\n\nconst AspectRatio = AspectRatioPrimitive.Root\n\nexport { AspectRatio }\n","size_bytes":140},"client/src/components/ui/dropdown-menu.tsx":{"content":"import * as React from \"react\"\nimport * as DropdownMenuPrimitive from \"@radix-ui/react-dropdown-menu\"\nimport { Check, ChevronRight, Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst DropdownMenu = DropdownMenuPrimitive.Root\n\nconst DropdownMenuTrigger = DropdownMenuPrimitive.Trigger\n\nconst DropdownMenuGroup = DropdownMenuPrimitive.Group\n\nconst DropdownMenuPortal = DropdownMenuPrimitive.Portal\n\nconst DropdownMenuSub = DropdownMenuPrimitive.Sub\n\nconst DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup\n\nconst DropdownMenuSubTrigger = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {\n    inset?: boolean\n  }\n>(({ className, inset, children, ...props }, ref) => (\n  <DropdownMenuPrimitive.SubTrigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <ChevronRight className=\"ml-auto\" />\n  </DropdownMenuPrimitive.SubTrigger>\n))\nDropdownMenuSubTrigger.displayName =\n  DropdownMenuPrimitive.SubTrigger.displayName\n\nconst DropdownMenuSubContent = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>\n>(({ className, ...props }, ref) => (\n  <DropdownMenuPrimitive.SubContent\n    ref={ref}\n    className={cn(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]\",\n      className\n    )}\n    {...props}\n  />\n))\nDropdownMenuSubContent.displayName =\n  DropdownMenuPrimitive.SubContent.displayName\n\nconst DropdownMenuContent = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>\n>(({ className, sideOffset = 4, ...props }, ref) => (\n  <DropdownMenuPrimitive.Portal>\n    <DropdownMenuPrimitive.Content\n      ref={ref}\n      sideOffset={sideOffset}\n      className={cn(\n        \"z-50 max-h-[var(--radix-dropdown-menu-content-available-height)] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]\",\n        className\n      )}\n      {...props}\n    />\n  </DropdownMenuPrimitive.Portal>\n))\nDropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName\n\nconst DropdownMenuItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <DropdownMenuPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nDropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName\n\nconst DropdownMenuCheckboxItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>\n>(({ className, children, checked, ...props }, ref) => (\n  <DropdownMenuPrimitive.CheckboxItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    checked={checked}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <DropdownMenuPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </DropdownMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </DropdownMenuPrimitive.CheckboxItem>\n))\nDropdownMenuCheckboxItem.displayName =\n  DropdownMenuPrimitive.CheckboxItem.displayName\n\nconst DropdownMenuRadioItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>\n>(({ className, children, ...props }, ref) => (\n  <DropdownMenuPrimitive.RadioItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <DropdownMenuPrimitive.ItemIndicator>\n        <Circle className=\"h-2 w-2 fill-current\" />\n      </DropdownMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </DropdownMenuPrimitive.RadioItem>\n))\nDropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName\n\nconst DropdownMenuLabel = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <DropdownMenuPrimitive.Label\n    ref={ref}\n    className={cn(\n      \"px-2 py-1.5 text-sm font-semibold\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nDropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName\n\nconst DropdownMenuSeparator = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <DropdownMenuPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nDropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName\n\nconst DropdownMenuShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\"ml-auto text-xs tracking-widest opacity-60\", className)}\n      {...props}\n    />\n  )\n}\nDropdownMenuShortcut.displayName = \"DropdownMenuShortcut\"\n\nexport {\n  DropdownMenu,\n  DropdownMenuTrigger,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuCheckboxItem,\n  DropdownMenuRadioItem,\n  DropdownMenuLabel,\n  DropdownMenuSeparator,\n  DropdownMenuShortcut,\n  DropdownMenuGroup,\n  DropdownMenuPortal,\n  DropdownMenuSub,\n  DropdownMenuSubContent,\n  DropdownMenuSubTrigger,\n  DropdownMenuRadioGroup,\n}\n","size_bytes":7609},"shared/db-schema.ts":{"content":"import { pgTable, text, timestamp, integer, jsonb, boolean, serial, uuid, index } from \"drizzle-orm/pg-core\";\nimport { relations } from \"drizzle-orm\";\n\nexport const tasks = pgTable(\"tasks\", {\n  id: uuid(\"id\").primaryKey().defaultRandom(),\n  title: text(\"title\").notNull(),\n  status: text(\"status\").notNull(),\n  repository: text(\"repository\").notNull(),\n  branch: text(\"branch\"),\n  summary: text(\"summary\").notNull(),\n  createdAt: timestamp(\"created_at\").notNull().defaultNow(),\n  updatedAt: timestamp(\"updated_at\").notNull().defaultNow(),\n  progress: integer(\"progress\").notNull().default(0),\n  eventId: uuid(\"event_id\"),\n}, (table) => ({\n  statusIdx: index(\"status_idx\").on(table.status),\n  repoIdx: index(\"repo_idx\").on(table.repository),\n}));\n\nexport const taskLogs = pgTable(\"task_logs\", {\n  id: uuid(\"id\").primaryKey().defaultRandom(),\n  taskId: uuid(\"task_id\").notNull().references(() => tasks.id, { onDelete: \"cascade\" }),\n  timestamp: text(\"timestamp\").notNull(),\n  level: text(\"level\").notNull(),\n  message: text(\"message\").notNull(),\n  createdAt: timestamp(\"created_at\").notNull().defaultNow(),\n}, (table) => ({\n  taskIdx: index(\"task_logs_task_idx\").on(table.taskId),\n}));\n\nexport const reasoningSteps = pgTable(\"reasoning_steps\", {\n  id: uuid(\"id\").primaryKey().defaultRandom(),\n  taskId: uuid(\"task_id\").notNull().references(() => tasks.id, { onDelete: \"cascade\" }),\n  timestamp: text(\"timestamp\").notNull(),\n  description: text(\"description\").notNull(),\n  confidence: integer(\"confidence\"),\n  completed: boolean(\"completed\").notNull().default(false),\n  createdAt: timestamp(\"created_at\").notNull().defaultNow(),\n}, (table) => ({\n  taskIdx: index(\"reasoning_steps_task_idx\").on(table.taskId),\n}));\n\nexport const fileDiffs = pgTable(\"file_diffs\", {\n  id: uuid(\"id\").primaryKey().defaultRandom(),\n  taskId: uuid(\"task_id\").notNull().references(() => tasks.id, { onDelete: \"cascade\" }),\n  path: text(\"path\").notNull(),\n  lines: jsonb(\"lines\").notNull(),\n  createdAt: timestamp(\"created_at\").notNull().defaultNow(),\n}, (table) => ({\n  taskIdx: index(\"file_diffs_task_idx\").on(table.taskId),\n}));\n\nexport const githubEvents = pgTable(\"github_events\", {\n  id: uuid(\"id\").primaryKey().defaultRandom(),\n  timestamp: timestamp(\"timestamp\").notNull().defaultNow(),\n  type: text(\"type\").notNull(),\n  repository: text(\"repository\").notNull(),\n  action: text(\"action\").notNull(),\n  status: text(\"status\").notNull(),\n  payload: jsonb(\"payload\"),\n  taskId: uuid(\"task_id\"),\n}, (table) => ({\n  typeIdx: index(\"github_events_type_idx\").on(table.type),\n  repoIdx: index(\"github_events_repo_idx\").on(table.repository),\n  timestampIdx: index(\"github_events_timestamp_idx\").on(table.timestamp),\n}));\n\nexport const settings = pgTable(\"settings\", {\n  id: serial(\"id\").primaryKey(),\n  aiEndpoint: text(\"ai_endpoint\").notNull(),\n  aiKey: text(\"ai_key\").notNull(),\n  aiModel: text(\"ai_model\").notNull(),\n  aiMaxTokens: integer(\"ai_max_tokens\").notNull().default(4096),\n  aiTemperature: integer(\"ai_temperature\").notNull().default(70),\n  githubToken: text(\"github_token\").notNull(),\n  githubWebhookSecret: text(\"github_webhook_secret\"),\n  autoApprove: boolean(\"auto_approve\").notNull().default(false),\n  updatedAt: timestamp(\"updated_at\").notNull().defaultNow(),\n});\n\nexport const repositoryContexts = pgTable(\"repository_contexts\", {\n  id: uuid(\"id\").primaryKey().defaultRandom(),\n  repository: text(\"repository\").notNull().unique(),\n  architecture: jsonb(\"architecture\"),\n  dependencies: jsonb(\"dependencies\"),\n  fileStructure: jsonb(\"file_structure\"),\n  branches: jsonb(\"branches\"),\n  recentCommits: jsonb(\"recent_commits\"),\n  openIssues: jsonb(\"open_issues\"),\n  semanticSummary: text(\"semantic_summary\"),\n  createdAt: timestamp(\"created_at\").notNull().defaultNow(),\n  updatedAt: timestamp(\"updated_at\").notNull().defaultNow(),\n}, (table) => ({\n  repoIdx: index(\"repo_contexts_repo_idx\").on(table.repository),\n}));\n\nexport const containerRunners = pgTable(\"container_runners\", {\n  id: uuid(\"id\").primaryKey().defaultRandom(),\n  taskId: uuid(\"task_id\").notNull().references(() => tasks.id, { onDelete: \"cascade\" }),\n  status: text(\"status\").notNull(),\n  containerId: text(\"container_id\"),\n  startedAt: timestamp(\"started_at\").notNull().defaultNow(),\n  completedAt: timestamp(\"completed_at\"),\n  telemetry: jsonb(\"telemetry\"),\n  artifacts: jsonb(\"artifacts\"),\n}, (table) => ({\n  taskIdx: index(\"container_runners_task_idx\").on(table.taskId),\n  statusIdx: index(\"container_runners_status_idx\").on(table.status),\n}));\n\nexport const mcpConnections = pgTable(\"mcp_connections\", {\n  id: uuid(\"id\").primaryKey().defaultRandom(),\n  type: text(\"type\").notNull(),\n  name: text(\"name\").notNull(),\n  config: jsonb(\"config\").notNull(),\n  status: text(\"status\").notNull(),\n  lastUsed: timestamp(\"last_used\"),\n  createdAt: timestamp(\"created_at\").notNull().defaultNow(),\n}, (table) => ({\n  typeIdx: index(\"mcp_connections_type_idx\").on(table.type),\n}));\n\nexport const tasksRelations = relations(tasks, ({ many, one }) => ({\n  logs: many(taskLogs),\n  reasoning: many(reasoningSteps),\n  diffs: many(fileDiffs),\n  runners: many(containerRunners),\n  event: one(githubEvents, {\n    fields: [tasks.eventId],\n    references: [githubEvents.id],\n  }),\n}));\n\nexport const githubEventsRelations = relations(githubEvents, ({ one }) => ({\n  task: one(tasks, {\n    fields: [githubEvents.taskId],\n    references: [tasks.id],\n  }),\n}));\n\nexport const taskLogsRelations = relations(taskLogs, ({ one }) => ({\n  task: one(tasks, {\n    fields: [taskLogs.taskId],\n    references: [tasks.id],\n  }),\n}));\n\nexport const reasoningStepsRelations = relations(reasoningSteps, ({ one }) => ({\n  task: one(tasks, {\n    fields: [reasoningSteps.taskId],\n    references: [tasks.id],\n  }),\n}));\n\nexport const fileDiffsRelations = relations(fileDiffs, ({ one }) => ({\n  task: one(tasks, {\n    fields: [fileDiffs.taskId],\n    references: [tasks.id],\n  }),\n}));\n\nexport const containerRunnersRelations = relations(containerRunners, ({ one }) => ({\n  task: one(tasks, {\n    fields: [containerRunners.taskId],\n    references: [tasks.id],\n  }),\n}));\n","size_bytes":6082},"client/src/components/ui/resizable.tsx":{"content":"\"use client\"\n\nimport { GripVertical } from \"lucide-react\"\nimport * as ResizablePrimitive from \"react-resizable-panels\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ResizablePanelGroup = ({\n  className,\n  ...props\n}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (\n  <ResizablePrimitive.PanelGroup\n    className={cn(\n      \"flex h-full w-full data-[panel-group-direction=vertical]:flex-col\",\n      className\n    )}\n    {...props}\n  />\n)\n\nconst ResizablePanel = ResizablePrimitive.Panel\n\nconst ResizableHandle = ({\n  withHandle,\n  className,\n  ...props\n}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {\n  withHandle?: boolean\n}) => (\n  <ResizablePrimitive.PanelResizeHandle\n    className={cn(\n      \"relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90\",\n      className\n    )}\n    {...props}\n  >\n    {withHandle && (\n      <div className=\"z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border\">\n        <GripVertical className=\"h-2.5 w-2.5\" />\n      </div>\n    )}\n  </ResizablePrimitive.PanelResizeHandle>\n)\n\nexport { ResizablePanelGroup, ResizablePanel, ResizableHandle }\n","size_bytes":1723},"client/src/components/ui/input.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Input = React.forwardRef<HTMLInputElement, React.ComponentProps<\"input\">>(\n  ({ className, type, ...props }, ref) => {\n    // h-9 to match icon buttons and default buttons.\n    return (\n      <input\n        type={type}\n        className={cn(\n          \"flex h-9 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n          className\n        )}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nInput.displayName = \"Input\"\n\nexport { Input }\n","size_bytes":844},"client/src/components/ui/checkbox.tsx":{"content":"import * as React from \"react\"\nimport * as CheckboxPrimitive from \"@radix-ui/react-checkbox\"\nimport { Check } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Checkbox = React.forwardRef<\n  React.ElementRef<typeof CheckboxPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <CheckboxPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground\",\n      className\n    )}\n    {...props}\n  >\n    <CheckboxPrimitive.Indicator\n      className={cn(\"flex items-center justify-center text-current\")}\n    >\n      <Check className=\"h-4 w-4\" />\n    </CheckboxPrimitive.Indicator>\n  </CheckboxPrimitive.Root>\n))\nCheckbox.displayName = CheckboxPrimitive.Root.displayName\n\nexport { Checkbox }\n","size_bytes":1056},"server/index.ts":{"content":"import express, { type Request, Response, NextFunction } from \"express\";\nimport { registerRoutes } from \"./routes\";\nimport { setupVite, serveStatic, log } from \"./vite\";\n\nconst app = express();\n\ndeclare module 'http' {\n  interface IncomingMessage {\n    rawBody: unknown\n  }\n}\napp.use(express.json({\n  verify: (req, _res, buf) => {\n    req.rawBody = buf;\n  }\n}));\napp.use(express.urlencoded({ extended: false }));\n\napp.use((req, res, next) => {\n  const start = Date.now();\n  const path = req.path;\n  let capturedJsonResponse: Record<string, any> | undefined = undefined;\n\n  const originalResJson = res.json;\n  res.json = function (bodyJson, ...args) {\n    capturedJsonResponse = bodyJson;\n    return originalResJson.apply(res, [bodyJson, ...args]);\n  };\n\n  res.on(\"finish\", () => {\n    const duration = Date.now() - start;\n    if (path.startsWith(\"/api\")) {\n      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;\n      if (capturedJsonResponse) {\n        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;\n      }\n\n      if (logLine.length > 80) {\n        logLine = logLine.slice(0, 79) + \"\";\n      }\n\n      log(logLine);\n    }\n  });\n\n  next();\n});\n\n(async () => {\n  const server = await registerRoutes(app);\n\n  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {\n    const status = err.status || err.statusCode || 500;\n    const message = err.message || \"Internal Server Error\";\n\n    res.status(status).json({ message });\n    throw err;\n  });\n\n  // importantly only setup vite in development and after\n  // setting up all the other routes so the catch-all route\n  // doesn't interfere with the other routes\n  if (app.get(\"env\") === \"development\") {\n    await setupVite(app, server);\n  } else {\n    serveStatic(app);\n  }\n\n  // ALWAYS serve the app on the port specified in the environment variable PORT\n  // Other ports are firewalled. Default to 5000 if not specified.\n  // this serves both the API and the client.\n  // It is the only port that is not firewalled.\n  const port = parseInt(process.env.PORT || '5000', 10);\n  server.listen({\n    port,\n    host: \"0.0.0.0\",\n    reusePort: true,\n  }, () => {\n    log(`serving on port ${port}`);\n  });\n})();\n","size_bytes":2210},"client/src/index.css":{"content":"@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n/* LIGHT MODE */\n:root {\n  --button-outline: rgba(0,0,0, .10);\n  --badge-outline: rgba(0,0,0, .05);\n  --opaque-button-border-intensity: -8;\n  --elevate-1: rgba(0,0,0, .03);\n  --elevate-2: rgba(0,0,0, .08);\n  --background: 0 0% 100%;\n  --foreground: 0 0% 0%;\n  --border: 0 0% 96.47%;\n  --card: 0 0% 96.47%;\n  --card-foreground: 0 0% 0%;\n  --card-border: 0 0% 93%;\n  --sidebar: 180 6.6667% 97.0588%;\n  --sidebar-foreground: 210 25% 7.8431%;\n  --sidebar-border: 205.0000 25.0000% 90.5882%;\n  --sidebar-primary: 203.8863 88.2845% 53.1373%;\n  --sidebar-primary-foreground: 0 0% 100%;\n  --sidebar-accent: 211.5789 51.3514% 92.7451%;\n  --sidebar-accent-foreground: 203.8863 88.2845% 53.1373%;\n  --sidebar-ring: 202.8169 89.1213% 53.1373%;\n  --popover: 0 0% 100%;\n  --popover-foreground: 0 0% 0%;\n  --popover-border: 0 0% 96%;\n  --primary: 96 85.19% 73.53%;\n  --primary-foreground: 0 0% 0%;\n  --secondary: 0 0% 0%;\n  --secondary-foreground: 0 0% 100%;\n  --muted: 0 0% 96.08%;\n  --muted-foreground: 0 0% 52.94%;\n  --accent: 254.21 100% 92.55%;\n  --accent-foreground: 0 0% 0%;\n  --destructive: 2.04 74.62% 61.37%;\n  --destructive-foreground: 0 0% 100%;\n  --input: 0 0% 0%;\n  --ring: 0 0% 0%;\n  --chart-1: 203.8863 88.2845% 53.1373%;\n  --chart-2: 159.7826 100% 36.0784%;\n  --chart-3: 42.0290 92.8251% 56.2745%;\n  --chart-4: 147.1429 78.5047% 41.9608%;\n  --chart-5: 341.4894 75.2000% 50.9804%;\n  --font-sans: 'Space Grotesk', sans-serif;\n  --font-serif: 'Geist', sans-serif;\n  --font-mono: 'Geist Mono', monospace;\n  --radius: 0rem;\n  --shadow-2xs: 0px 2px 0px 0px hsl(202.8169 89.1213% 53.1373% / 0.00);\n  --shadow-xs: 0px 2px 0px 0px hsl(202.8169 89.1213% 53.1373% / 0.00);\n  --shadow-sm: 0px 2px 0px 0px hsl(202.8169 89.1213% 53.1373% / 0.00), 0px 1px 2px -1px hsl(202.8169 89.1213% 53.1373% / 0.00);\n  --shadow: 0px 2px 0px 0px hsl(202.8169 89.1213% 53.1373% / 0.00), 0px 1px 2px -1px hsl(202.8169 89.1213% 53.1373% / 0.00);\n  --shadow-md: 0px 2px 0px 0px hsl(202.8169 89.1213% 53.1373% / 0.00), 0px 2px 4px -1px hsl(202.8169 89.1213% 53.1373% / 0.00);\n  --shadow-lg: 0px 2px 0px 0px hsl(202.8169 89.1213% 53.1373% / 0.00), 0px 4px 6px -1px hsl(202.8169 89.1213% 53.1373% / 0.00);\n  --shadow-xl: 0px 2px 0px 0px hsl(202.8169 89.1213% 53.1373% / 0.00), 0px 8px 10px -1px hsl(202.8169 89.1213% 53.1373% / 0.00);\n  --shadow-2xl: 0px 2px 0px 0px hsl(202.8169 89.1213% 53.1373% / 0.00);\n  --tracking-normal: 0em;\n  --spacing: 0.25rem;\n\n/* Fallback for older browsers */\n  --sidebar-primary-border: hsl(var(--sidebar-primary));\n  --sidebar-primary-border: hsl(from hsl(var(--sidebar-primary)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n\n  /* Fallback for older browsers */\n  --sidebar-accent-border: hsl(var(--sidebar-accent));\n  --sidebar-accent-border: hsl(from hsl(var(--sidebar-accent)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n\n  /* Fallback for older browsers */\n  --primary-border: hsl(var(--primary));\n  --primary-border: hsl(from hsl(var(--primary)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n\n  /* Fallback for older browsers */\n  --secondary-border: hsl(var(--secondary));\n  --secondary-border: hsl(from hsl(var(--secondary)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n\n  /* Fallback for older browsers */\n  --muted-border: hsl(var(--muted));\n  --muted-border: hsl(from hsl(var(--muted)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n\n  /* Fallback for older browsers */\n  --accent-border: hsl(var(--accent));\n  --accent-border: hsl(from hsl(var(--accent)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n\n  /* Fallback for older browsers */\n  --destructive-border: hsl(var(--destructive));\n  --destructive-border: hsl(from hsl(var(--destructive)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n}\n\n.dark {\n  --button-outline: rgba(255,255,255, .10);\n  --badge-outline: rgba(255,255,255, .05);\n  --opaque-button-border-intensity: 9;\n  --elevate-1: rgba(255,255,255, .04);\n  --elevate-2: rgba(255,255,255, .09);\n  --background: 0 0% 0%;\n  --foreground: 200 6.6667% 91.1765%;\n  --border: 210 5.2632% 14.9020%;\n  --card: 228 9.8039% 10%;\n  --card-foreground: 0 0% 85.0980%;\n  --card-border: 205.71 15.79% 26.08%;\n  --sidebar: 228 9.8039% 10%;\n  --sidebar-foreground: 0 0% 85.0980%;\n  --sidebar-border: 205.7143 15.7895% 26.0784%;\n  --sidebar-primary: 202.8169 89.1213% 53.1373%;\n  --sidebar-primary-foreground: 0 0% 100%;\n  --sidebar-accent: 205.7143 70% 7.8431%;\n  --sidebar-accent-foreground: 203.7736 87.6033% 52.5490%;\n  --sidebar-ring: 202.8169 89.1213% 53.1373%;\n  --popover: 0 0% 0%;\n  --popover-foreground: 200 6.6667% 91.1765%;\n  --popover-border: 0 0% 9.41%;\n  --primary: 203.7736 87.6033% 52.5490%;\n  --primary-foreground: 0 0% 100%;\n  --secondary: 195.0000 15.3846% 94.9020%;\n  --secondary-foreground: 210 25% 7.8431%;\n  --muted: 0 0% 9.4118%;\n  --muted-foreground: 210 3.3898% 46.2745%;\n  --accent: 205.7143 70% 7.8431%;\n  --accent-foreground: 203.7736 87.6033% 52.5490%;\n  --destructive: 356.3033 90.5579% 54.3137%;\n  --destructive-foreground: 0 0% 100%;\n  --input: 207.6923 27.6596% 18.4314%;\n  --ring: 202.8169 89.1213% 53.1373%;\n  --chart-1: 203.8863 88.2845% 53.1373%;\n  --chart-2: 159.7826 100% 36.0784%;\n  --chart-3: 42.0290 92.8251% 56.2745%;\n  --chart-4: 147.1429 78.5047% 41.9608%;\n  --chart-5: 341.4894 75.2000% 50.9804%;\n  --shadow-2xs: 0px 2px 0px 0px hsl(202.8169 89.1213% 53.1373% / 0.00);\n  --shadow-xs: 0px 2px 0px 0px hsl(202.8169 89.1213% 53.1373% / 0.00);\n  --shadow-sm: 0px 2px 0px 0px hsl(202.8169 89.1213% 53.1373% / 0.00), 0px 1px 2px -1px hsl(202.8169 89.1213% 53.1373% / 0.00);\n  --shadow: 0px 2px 0px 0px hsl(202.8169 89.1213% 53.1373% / 0.00), 0px 1px 2px -1px hsl(202.8169 89.1213% 53.1373% / 0.00);\n  --shadow-md: 0px 2px 0px 0px hsl(202.8169 89.1213% 53.1373% / 0.00), 0px 2px 4px -1px hsl(202.8169 89.1213% 53.1373% / 0.00);\n  --shadow-lg: 0px 2px 0px 0px hsl(202.8169 89.1213% 53.1373% / 0.00), 0px 4px 6px -1px hsl(202.8169 89.1213% 53.1373% / 0.00);\n  --shadow-xl: 0px 2px 0px 0px hsl(202.8169 89.1213% 53.1373% / 0.00), 0px 8px 10px -1px hsl(202.8169 89.1213% 53.1373% / 0.00);\n  --shadow-2xl: 0px 2px 0px 0px hsl(202.8169 89.1213% 53.1373% / 0.00);\n\n/* Fallback for older browsers */\n  --sidebar-primary-border: hsl(var(--sidebar-primary));\n  --sidebar-primary-border: hsl(from hsl(var(--sidebar-primary)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n\n  /* Fallback for older browsers */\n  --sidebar-accent-border: hsl(var(--sidebar-accent));\n  --sidebar-accent-border: hsl(from hsl(var(--sidebar-accent)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n\n  /* Fallback for older browsers */\n  --primary-border: hsl(var(--primary));\n  --primary-border: hsl(from hsl(var(--primary)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n\n  /* Fallback for older browsers */\n  --secondary-border: hsl(var(--secondary));\n  --secondary-border: hsl(from hsl(var(--secondary)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n\n  /* Fallback for older browsers */\n  --muted-border: hsl(var(--muted));\n  --muted-border: hsl(from hsl(var(--muted)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n\n  /* Fallback for older browsers */\n  --accent-border: hsl(var(--accent));\n  --accent-border: hsl(from hsl(var(--accent)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n\n  /* Fallback for older browsers */\n  --destructive-border: hsl(var(--destructive));\n  --destructive-border: hsl(from hsl(var(--destructive)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n  --radius: 1.3rem;\n  --spacing: 0.25rem;\n  --font-mono: Menlo, monospace;\n  --font-sans: Open Sans, sans-serif;\n  --font-serif: Georgia, serif;\n  --tracking-normal: 0em;\n}\n\n@layer base {\n  * {\n    @apply border-border;\n  }\n\n  body {\n    @apply font-sans antialiased bg-background text-foreground;\n  }\n}\n\n/**\n * Using the elevate system.\n * Automatic contrast adjustment.\n *\n * <element className=\"hover-elevate\" />\n * <element className=\"active-elevate-2\" />\n *\n * // Using the tailwind utility when a data attribute is \"on\"\n * <element className=\"toggle-elevate data-[state=on]:toggle-elevated\" />\n * // Or manually controlling the toggle state\n * <element className=\"toggle-elevate toggle-elevated\" />\n *\n * Elevation systems have to handle many states.\n * - not-hovered, vs. hovered vs. active  (three mutually exclusive states)\n * - toggled or not\n * - focused or not (this is not handled with these utilities)\n *\n * Even without handling focused or not, this is six possible combinations that\n * need to be distinguished from eachother visually.\n */\n@layer utilities {\n\n  /* Hide ugly search cancel button in Chrome until we can style it properly */\n  input[type=\"search\"]::-webkit-search-cancel-button {\n    @apply hidden;\n  }\n\n  /* Placeholder styling for contentEditable div */\n  [contenteditable][data-placeholder]:empty::before {\n    content: attr(data-placeholder);\n    color: hsl(var(--muted-foreground));\n    pointer-events: none;\n  }\n\n  /* .no-default-hover-elevate/no-default-active-elevate is an escape hatch so consumers of\n   * buttons/badges can remove the automatic brightness adjustment on interactions\n   * and program their own. */\n  .no-default-hover-elevate {}\n\n  .no-default-active-elevate {}\n\n\n  /**\n   * Toggleable backgrounds go behind the content. Hoverable/active goes on top.\n   * This way they can stack/compound. Both will overlap the parent's borders!\n   * So borders will be automatically adjusted both on toggle, and hover/active,\n   * and they will be compounded.\n   */\n  .toggle-elevate::before,\n  .toggle-elevate-2::before {\n    content: \"\";\n    pointer-events: none;\n    position: absolute;\n    inset: 0px;\n    /*border-radius: inherit;   match rounded corners */\n    border-radius: inherit;\n    z-index: -1;\n    /* sits behind content but above backdrop */\n  }\n\n  .toggle-elevate.toggle-elevated::before {\n    background-color: var(--elevate-2);\n  }\n\n  /* If there's a 1px border, adjust the inset so that it covers that parent's border */\n  .border.toggle-elevate::before {\n    inset: -1px;\n  }\n\n  /* Does not work on elements with overflow:hidden! */\n  .hover-elevate:not(.no-default-hover-elevate),\n  .active-elevate:not(.no-default-active-elevate),\n  .hover-elevate-2:not(.no-default-hover-elevate),\n  .active-elevate-2:not(.no-default-active-elevate) {\n    position: relative;\n    z-index: 0;\n  }\n\n  .hover-elevate:not(.no-default-hover-elevate)::after,\n  .active-elevate:not(.no-default-active-elevate)::after,\n  .hover-elevate-2:not(.no-default-hover-elevate)::after,\n  .active-elevate-2:not(.no-default-active-elevate)::after {\n    content: \"\";\n    pointer-events: none;\n    position: absolute;\n    inset: 0px;\n    /*border-radius: inherit;   match rounded corners */\n    border-radius: inherit;\n    z-index: 999;\n    /* sits in front of content */\n  }\n\n  .hover-elevate:hover:not(.no-default-hover-elevate)::after,\n  .active-elevate:active:not(.no-default-active-elevate)::after {\n    background-color: var(--elevate-1);\n  }\n\n  .hover-elevate-2:hover:not(.no-default-hover-elevate)::after,\n  .active-elevate-2:active:not(.no-default-active-elevate)::after {\n    background-color: var(--elevate-2);\n  }\n\n  /* If there's a 1px border, adjust the inset so that it covers that parent's border */\n  .border.hover-elevate:not(.no-hover-interaction-elevate)::after,\n  .border.active-elevate:not(.no-active-interaction-elevate)::after,\n  .border.hover-elevate-2:not(.no-hover-interaction-elevate)::after,\n  .border.active-elevate-2:not(.no-active-interaction-elevate)::after,\n  .border.hover-elevate:not(.no-hover-interaction-elevate)::after {\n    inset: -1px;\n  }\n}\n","size_bytes":11779},"client/src/components/ui/sheet.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as SheetPrimitive from \"@radix-ui/react-dialog\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Sheet = SheetPrimitive.Root\n\nconst SheetTrigger = SheetPrimitive.Trigger\n\nconst SheetClose = SheetPrimitive.Close\n\nconst SheetPortal = SheetPrimitive.Portal\n\nconst SheetOverlay = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Overlay\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  />\n))\nSheetOverlay.displayName = SheetPrimitive.Overlay.displayName\n\nconst sheetVariants = cva(\n  \"fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500\",\n  {\n    variants: {\n      side: {\n        top: \"inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top\",\n        bottom:\n          \"inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom\",\n        left: \"inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm\",\n        right:\n          \"inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm\",\n      },\n    },\n    defaultVariants: {\n      side: \"right\",\n    },\n  }\n)\n\ninterface SheetContentProps\n  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,\n    VariantProps<typeof sheetVariants> {}\n\nconst SheetContent = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Content>,\n  SheetContentProps\n>(({ side = \"right\", className, children, ...props }, ref) => (\n  <SheetPortal>\n    <SheetOverlay />\n    <SheetPrimitive.Content\n      ref={ref}\n      className={cn(sheetVariants({ side }), className)}\n      {...props}\n    >\n      {children}\n      <SheetPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary\">\n        <X className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Close</span>\n      </SheetPrimitive.Close>\n    </SheetPrimitive.Content>\n  </SheetPortal>\n))\nSheetContent.displayName = SheetPrimitive.Content.displayName\n\nconst SheetHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-2 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nSheetHeader.displayName = \"SheetHeader\"\n\nconst SheetFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nSheetFooter.displayName = \"SheetFooter\"\n\nconst SheetTitle = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Title\n    ref={ref}\n    className={cn(\"text-lg font-semibold text-foreground\", className)}\n    {...props}\n  />\n))\nSheetTitle.displayName = SheetPrimitive.Title.displayName\n\nconst SheetDescription = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nSheetDescription.displayName = SheetPrimitive.Description.displayName\n\nexport {\n  Sheet,\n  SheetPortal,\n  SheetOverlay,\n  SheetTrigger,\n  SheetClose,\n  SheetContent,\n  SheetHeader,\n  SheetFooter,\n  SheetTitle,\n  SheetDescription,\n}\n","size_bytes":4281},"client/src/components/ui/select.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as SelectPrimitive from \"@radix-ui/react-select\"\nimport { Check, ChevronDown, ChevronUp } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Select = SelectPrimitive.Root\n\nconst SelectGroup = SelectPrimitive.Group\n\nconst SelectValue = SelectPrimitive.Value\n\nconst SelectTrigger = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"flex h-9 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <SelectPrimitive.Icon asChild>\n      <ChevronDown className=\"h-4 w-4 opacity-50\" />\n    </SelectPrimitive.Icon>\n  </SelectPrimitive.Trigger>\n))\nSelectTrigger.displayName = SelectPrimitive.Trigger.displayName\n\nconst SelectScrollUpButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollUpButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className\n    )}\n    {...props}\n  >\n    <ChevronUp className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollUpButton>\n))\nSelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName\n\nconst SelectScrollDownButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollDownButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className\n    )}\n    {...props}\n  >\n    <ChevronDown className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollDownButton>\n))\nSelectScrollDownButton.displayName =\n  SelectPrimitive.ScrollDownButton.displayName\n\nconst SelectContent = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>\n>(({ className, children, position = \"popper\", ...props }, ref) => (\n  <SelectPrimitive.Portal>\n    <SelectPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"relative z-50 max-h-[--radix-select-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-select-content-transform-origin]\",\n        position === \"popper\" &&\n          \"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1\",\n        className\n      )}\n      position={position}\n      {...props}\n    >\n      <SelectScrollUpButton />\n      <SelectPrimitive.Viewport\n        className={cn(\n          \"p-1\",\n          position === \"popper\" &&\n            \"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]\"\n        )}\n      >\n        {children}\n      </SelectPrimitive.Viewport>\n      <SelectScrollDownButton />\n    </SelectPrimitive.Content>\n  </SelectPrimitive.Portal>\n))\nSelectContent.displayName = SelectPrimitive.Content.displayName\n\nconst SelectLabel = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Label\n    ref={ref}\n    className={cn(\"py-1.5 pl-8 pr-2 text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nSelectLabel.displayName = SelectPrimitive.Label.displayName\n\nconst SelectItem = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <SelectPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </SelectPrimitive.ItemIndicator>\n    </span>\n\n    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>\n  </SelectPrimitive.Item>\n))\nSelectItem.displayName = SelectPrimitive.Item.displayName\n\nconst SelectSeparator = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nSelectSeparator.displayName = SelectPrimitive.Separator.displayName\n\nexport {\n  Select,\n  SelectGroup,\n  SelectValue,\n  SelectTrigger,\n  SelectContent,\n  SelectLabel,\n  SelectItem,\n  SelectSeparator,\n  SelectScrollUpButton,\n  SelectScrollDownButton,\n}\n","size_bytes":5741},"server/routes.ts":{"content":"import type { Express } from \"express\";\nimport { createServer, type Server } from \"http\";\nimport { storage } from \"./storage\";\nimport { AIService } from \"./services/ai\";\nimport { GitHubService } from \"./services/github\";\nimport { RepositoryContextService } from \"./services/repository-context\";\nimport { MCPClientManager } from \"./services/mcp-client\";\nimport {\n  insertTaskSchema,\n  insertGithubEventSchema,\n  settingsSchema,\n  mcpServerConfigSchema,\n  mcpToolExecutionRequestSchema,\n  insertMCPConnectionSchema,\n  type LogEntry,\n  type ReasoningStep,\n} from \"@shared/schema\";\nimport { randomUUID } from \"crypto\";\n\n// SSE clients for real-time log streaming\nconst sseClients = new Map<string, Set<any>>();\n\nlet aiService: AIService | null = null;\nlet githubService: GitHubService | null = null;\nlet repositoryContextService: RepositoryContextService | null = null;\nconst mcpClientManager = new MCPClientManager();\n\n// Initialize services with settings if available\nasync function initializeServices() {\n  const settings = await storage.getSettings();\n  if (settings?.ai) {\n    aiService = new AIService(settings.ai, storage);\n  }\n  if (settings?.github) {\n    githubService = new GitHubService(settings.github);\n  }\n  if (githubService) {\n    repositoryContextService = new RepositoryContextService(storage, githubService, aiService || undefined);\n  }\n}\n\nexport async function registerRoutes(app: Express): Promise<Server> {\n  await initializeServices();\n\n  // Middleware to parse JSON\n  app.use(\"/api/webhook\", (req, res, next) => {\n    let rawBody = \"\";\n    req.on(\"data\", (chunk) => {\n      rawBody += chunk.toString();\n    });\n    req.on(\"end\", () => {\n      (req as any).rawBody = rawBody;\n      try {\n        req.body = JSON.parse(rawBody);\n      } catch {\n        req.body = {};\n      }\n      next();\n    });\n  });\n\n  // === WEBHOOK ENDPOINT ===\n  app.post(\"/api/webhook\", async (req, res) => {\n    try {\n      const signature = req.headers[\"x-hub-signature-256\"] as string;\n      const event = req.headers[\"x-github-event\"] as string;\n      \n      // Verify webhook if secret is configured\n      if (githubService && signature) {\n        const isValid = await githubService.verifyWebhook(\n          (req as any).rawBody,\n          signature\n        );\n        if (!isValid) {\n          return res.status(401).json({ error: \"Invalid signature\" });\n        }\n      }\n\n      // Create event log\n      const githubEvent = await storage.createEvent({\n        type: event === \"pull_request\" ? \"pull_request\" : \n              event === \"push\" ? \"push\" :\n              event === \"issues\" ? \"issue\" : \"comment\",\n        repository: req.body.repository?.full_name || \"unknown\",\n        action: req.body.action || event,\n        status: \"pending\",\n        payload: req.body,\n      });\n\n      // If AI service is available, create task automatically\n      if (aiService) {\n        // Generate task plan from AI\n        const plan = await aiService.generateTaskPlan(\n          event,\n          githubEvent.repository,\n          githubEvent.action,\n          req.body\n        );\n\n        const task = await storage.createTask({\n          title: plan.title,\n          summary: plan.summary,\n          repository: githubEvent.repository,\n          status: \"queued\",\n          progress: 0,\n          eventId: githubEvent.id,\n        });\n\n        await storage.updateEvent(githubEvent.id, { taskId: task.id });\n\n        // Start processing task asynchronously\n        processTask(task.id, plan.steps).catch(console.error);\n      }\n\n      res.json({ success: true, eventId: githubEvent.id });\n    } catch (error: any) {\n      console.error(\"Webhook error:\", error);\n      res.status(500).json({ error: error.message });\n    }\n  });\n\n  // === TASKS ENDPOINTS ===\n  app.get(\"/api/tasks\", async (_req, res) => {\n    const tasks = await storage.getAllTasks();\n    res.json(tasks);\n  });\n\n  app.get(\"/api/tasks/active\", async (_req, res) => {\n    const tasks = await storage.getActiveTasks();\n    res.json(tasks);\n  });\n\n  app.get(\"/api/tasks/:id\", async (req, res) => {\n    const task = await storage.getTask(req.params.id);\n    if (!task) {\n      return res.status(404).json({ error: \"Task not found\" });\n    }\n    res.json(task);\n  });\n\n  app.post(\"/api/tasks\", async (req, res) => {\n    try {\n      const validatedData = insertTaskSchema.parse(req.body);\n      const task = await storage.createTask(validatedData);\n      res.json(task);\n    } catch (error: any) {\n      res.status(400).json({ error: error.message });\n    }\n  });\n\n  app.patch(\"/api/tasks/:id\", async (req, res) => {\n    const task = await storage.updateTask(req.params.id, req.body);\n    if (!task) {\n      return res.status(404).json({ error: \"Task not found\" });\n    }\n    res.json(task);\n  });\n\n  // === DIFF ENDPOINTS ===\n  app.get(\"/api/tasks/:id/diffs\", async (req, res) => {\n    try {\n      const task = await storage.getTask(req.params.id);\n      if (!task) {\n        return res.status(404).json({ error: \"Task not found\" });\n      }\n      res.json(task.diffs || []);\n    } catch (error: any) {\n      console.error(\"Error getting diffs:\", error);\n      res.status(500).json({ error: error.message });\n    }\n  });\n\n  app.post(\"/api/tasks/:id/diffs/apply\", async (req, res) => {\n    try {\n      const task = await storage.getTask(req.params.id);\n      if (!task) {\n        return res.status(404).json({ error: \"Task not found\" });\n      }\n\n      if (!githubService) {\n        return res.status(503).json({ error: \"GitHub service not initialized. Please configure GitHub settings.\" });\n      }\n\n      if (!task.diffs || task.diffs.length === 0) {\n        return res.status(400).json({ error: \"No diffs to apply for this task\" });\n      }\n\n      const { repository, branch } = task;\n      const [owner, repo] = repository.split(\"/\");\n\n      if (!owner || !repo) {\n        return res.status(400).json({ error: \"Invalid repository format\" });\n      }\n\n      const results = [];\n      for (const diff of task.diffs) {\n        try {\n          const currentContent = await githubService.getFileContent(owner, repo, diff.path, branch);\n          \n          if (aiService) {\n            const validation = await aiService.validateDiffSafety(diff, currentContent);\n            \n            if (!validation.safe) {\n              results.push({\n                path: diff.path,\n                success: false,\n                error: `Safety validation failed: ${validation.issues.join(\", \")}`,\n                warnings: validation.warnings,\n              });\n              continue;\n            }\n          }\n\n          await addLog(task.id, \"info\", `Applying diff to ${diff.path}...`);\n          results.push({\n            path: diff.path,\n            success: true,\n            message: \"Diff validated and ready to apply (actual GitHub commit not implemented)\",\n          });\n        } catch (error: any) {\n          console.error(`Error applying diff for ${diff.path}:`, error);\n          results.push({\n            path: diff.path,\n            success: false,\n            error: error.message,\n          });\n        }\n      }\n\n      const allSuccessful = results.every((r) => r.success);\n      res.json({\n        success: allSuccessful,\n        results,\n        message: allSuccessful \n          ? \"All diffs validated successfully\" \n          : \"Some diffs failed validation\",\n      });\n    } catch (error: any) {\n      console.error(\"Error applying diffs:\", error);\n      res.status(500).json({ error: error.message });\n    }\n  });\n\n  app.post(\"/api/tasks/:id/diffs/validate\", async (req, res) => {\n    try {\n      const task = await storage.getTask(req.params.id);\n      if (!task) {\n        return res.status(404).json({ error: \"Task not found\" });\n      }\n\n      if (!githubService) {\n        return res.status(503).json({ error: \"GitHub service not initialized.\" });\n      }\n\n      if (!task.diffs || task.diffs.length === 0) {\n        return res.status(400).json({ error: \"No diffs to validate for this task\" });\n      }\n\n      const { repository, branch } = task;\n      const [owner, repo] = repository.split(\"/\");\n\n      if (!owner || !repo) {\n        return res.status(400).json({ error: \"Invalid repository format\" });\n      }\n\n      const validations = [];\n      for (const diff of task.diffs) {\n        try {\n          const currentContent = await githubService.getFileContent(owner, repo, diff.path, branch);\n          \n          let validation: { safe: boolean; issues: string[]; warnings: string[] } = { safe: true, issues: [], warnings: [] };\n          if (aiService) {\n            validation = await aiService.validateDiffSafety(diff, currentContent);\n          }\n\n          validations.push({\n            path: diff.path,\n            ...validation,\n          });\n        } catch (error: any) {\n          validations.push({\n            path: diff.path,\n            safe: false,\n            issues: [error.message],\n            warnings: [],\n          });\n        }\n      }\n\n      const allSafe = validations.every((v) => v.safe);\n      res.json({\n        safe: allSafe,\n        validations,\n      });\n    } catch (error: any) {\n      console.error(\"Error validating diffs:\", error);\n      res.status(500).json({ error: error.message });\n    }\n  });\n\n  app.get(\"/api/tasks/:id/diffs/:diffIndex/explain\", async (req, res) => {\n    try {\n      const task = await storage.getTask(req.params.id);\n      if (!task) {\n        return res.status(404).json({ error: \"Task not found\" });\n      }\n\n      const diffIndex = parseInt(req.params.diffIndex, 10);\n      if (isNaN(diffIndex) || diffIndex < 0 || !task.diffs || diffIndex >= task.diffs.length) {\n        return res.status(400).json({ error: \"Invalid diff index\" });\n      }\n\n      const diff = task.diffs[diffIndex];\n\n      if (!aiService) {\n        return res.status(503).json({ error: \"AI service not initialized.\" });\n      }\n\n      const explanation = await aiService.explainDiff(diff);\n      res.json(explanation);\n    } catch (error: any) {\n      console.error(\"Error explaining diff:\", error);\n      res.status(500).json({ error: error.message });\n    }\n  });\n\n  // === EVENTS ENDPOINTS ===\n  app.get(\"/api/events\", async (_req, res) => {\n    const events = await storage.getAllEvents();\n    res.json(events);\n  });\n\n  app.get(\"/api/events/recent\", async (req, res) => {\n    const limit = parseInt(req.query.limit as string) || 10;\n    const events = await storage.getRecentEvents(limit);\n    res.json(events);\n  });\n\n  // === SETTINGS ENDPOINTS ===\n  app.get(\"/api/settings\", async (_req, res) => {\n    const settings = await storage.getSettings();\n    if (!settings) {\n      return res.json({\n        ai: {\n          apiEndpoint: \"https://api.openai.com/v1\",\n          apiKey: \"\",\n          model: \"gpt-4\",\n          maxTokens: 4096,\n          temperature: 0.7,\n        },\n        github: {\n          token: \"\",\n        },\n        autoApprove: false,\n      });\n    }\n    // Don't send API keys to frontend\n    res.json({\n      ...settings,\n      ai: { ...settings.ai, apiKey: settings.ai.apiKey ? \"***\" : \"\" },\n      github: { ...settings.github, token: settings.github.token ? \"***\" : \"\" },\n    });\n  });\n\n  app.post(\"/api/settings\", async (req, res) => {\n    try {\n      const validatedSettings = settingsSchema.parse(req.body);\n      const settings = await storage.updateSettings(validatedSettings);\n      \n      // Reinitialize services with new settings\n      if (settings.ai) {\n        aiService = new AIService(settings.ai, storage);\n      }\n      if (settings.github) {\n        githubService = new GitHubService(settings.github);\n      }\n      if (githubService) {\n        repositoryContextService = new RepositoryContextService(storage, githubService, aiService || undefined);\n      }\n\n      res.json({ success: true });\n    } catch (error: any) {\n      res.status(400).json({ error: error.message });\n    }\n  });\n\n  // === AI PROVIDER ENDPOINTS ===\n  app.get(\"/api/ai/providers\", async (_req, res) => {\n    try {\n      if (!aiService) {\n        return res.status(503).json({ error: \"AI service not initialized. Please configure AI settings.\" });\n      }\n\n      const providerManager = aiService.getProviderManager();\n      if (!providerManager) {\n        return res.json([]);\n      }\n\n      const providers = providerManager.getProviders();\n      res.json(providers);\n    } catch (error: any) {\n      console.error(\"Error getting providers:\", error);\n      res.status(500).json({ error: error.message });\n    }\n  });\n\n  app.get(\"/api/ai/metrics\", async (_req, res) => {\n    try {\n      if (!aiService) {\n        return res.status(503).json({ error: \"AI service not initialized. Please configure AI settings.\" });\n      }\n\n      const providerManager = aiService.getProviderManager();\n      if (!providerManager) {\n        return res.json([]);\n      }\n\n      const metrics = providerManager.getMetrics();\n      res.json(metrics);\n    } catch (error: any) {\n      console.error(\"Error getting metrics:\", error);\n      res.status(500).json({ error: error.message });\n    }\n  });\n\n  app.post(\"/api/ai/providers/:name/test\", async (req, res) => {\n    try {\n      const { name } = req.params;\n\n      if (!aiService) {\n        return res.status(503).json({ error: \"AI service not initialized. Please configure AI settings.\" });\n      }\n\n      const providerManager = aiService.getProviderManager();\n      if (!providerManager) {\n        return res.status(503).json({ error: \"No providers configured\" });\n      }\n\n      const result = await providerManager.testProvider(name);\n      res.json(result);\n    } catch (error: any) {\n      console.error(`Error testing provider ${req.params.name}:`, error);\n      res.status(500).json({ error: error.message });\n    }\n  });\n\n  // === REPOSITORY CONTEXT ENDPOINTS ===\n  app.get(\"/api/repositories/:owner/:repo/context\", async (req, res) => {\n    try {\n      const { owner, repo } = req.params;\n      const repository = `${owner}/${repo}`;\n\n      if (!repositoryContextService) {\n        return res.status(503).json({ error: \"Repository context service not initialized. Please configure GitHub settings.\" });\n      }\n\n      const context = await repositoryContextService.getOrCreateContext(repository);\n      res.json(context);\n    } catch (error: any) {\n      console.error(\"Error getting repository context:\", error);\n      res.status(500).json({ error: error.message });\n    }\n  });\n\n  app.post(\"/api/repositories/:owner/:repo/context/refresh\", async (req, res) => {\n    try {\n      const { owner, repo } = req.params;\n      const repository = `${owner}/${repo}`;\n\n      if (!repositoryContextService) {\n        return res.status(503).json({ error: \"Repository context service not initialized. Please configure GitHub settings.\" });\n      }\n\n      const context = await repositoryContextService.refreshContext(repository);\n      res.json(context);\n    } catch (error: any) {\n      console.error(\"Error refreshing repository context:\", error);\n      res.status(500).json({ error: error.message });\n    }\n  });\n\n  app.get(\"/api/repositories/:owner/:repo/context/summary\", async (req, res) => {\n    try {\n      const { owner, repo } = req.params;\n      const repository = `${owner}/${repo}`;\n\n      if (!repositoryContextService) {\n        return res.status(503).json({ error: \"Repository context service not initialized. Please configure GitHub settings.\" });\n      }\n\n      const summary = await repositoryContextService.getSemanticSummary(repository);\n      res.json({ summary });\n    } catch (error: any) {\n      console.error(\"Error getting semantic summary:\", error);\n      res.status(500).json({ error: error.message });\n    }\n  });\n\n  // === MCP SERVER ENDPOINTS ===\n  app.post(\"/api/mcp/servers\", async (req, res) => {\n    try {\n      const serverConfig = mcpServerConfigSchema.parse(req.body);\n\n      const connection = await storage.createMCPConnection({\n        type: serverConfig.type,\n        name: serverConfig.name,\n        config: serverConfig as any,\n        status: \"initializing\",\n      });\n\n      try {\n        const client = await mcpClientManager.createClient(connection.id, serverConfig);\n        \n        await storage.updateMCPConnection(connection.id, {\n          status: \"connected\",\n          lastUsed: new Date().toISOString(),\n        });\n\n        res.json({\n          ...connection,\n          status: \"connected\",\n          capabilities: client.getCapabilities(),\n        });\n      } catch (error: any) {\n        await storage.updateMCPConnection(connection.id, {\n          status: \"error\",\n        });\n        \n        throw error;\n      }\n    } catch (error: any) {\n      console.error(\"Error creating MCP server:\", error);\n      res.status(500).json({ error: error.message });\n    }\n  });\n\n  app.get(\"/api/mcp/servers\", async (_req, res) => {\n    try {\n      const connections = await storage.getAllMCPConnections();\n      \n      const connectionsWithStatus = connections.map((conn) => {\n        const client = mcpClientManager.getClient(conn.id);\n        return {\n          ...conn,\n          initialized: client?.isInitialized() || false,\n          capabilities: client?.getCapabilities(),\n        };\n      });\n\n      res.json(connectionsWithStatus);\n    } catch (error: any) {\n      console.error(\"Error listing MCP servers:\", error);\n      res.status(500).json({ error: error.message });\n    }\n  });\n\n  app.get(\"/api/mcp/servers/:id\", async (req, res) => {\n    try {\n      const connection = await storage.getMCPConnection(req.params.id);\n      if (!connection) {\n        return res.status(404).json({ error: \"MCP server not found\" });\n      }\n\n      const client = mcpClientManager.getClient(connection.id);\n      \n      res.json({\n        ...connection,\n        initialized: client?.isInitialized() || false,\n        capabilities: client?.getCapabilities(),\n      });\n    } catch (error: any) {\n      console.error(\"Error getting MCP server:\", error);\n      res.status(500).json({ error: error.message });\n    }\n  });\n\n  app.get(\"/api/mcp/servers/:id/tools\", async (req, res) => {\n    try {\n      const connection = await storage.getMCPConnection(req.params.id);\n      if (!connection) {\n        return res.status(404).json({ error: \"MCP server not found\" });\n      }\n\n      const client = mcpClientManager.getClient(connection.id);\n      if (!client) {\n        return res.status(503).json({ error: \"MCP server not initialized\" });\n      }\n\n      const tools = await client.listTools();\n      \n      await storage.updateMCPConnection(connection.id, {\n        lastUsed: new Date().toISOString(),\n      });\n\n      res.json({ tools });\n    } catch (error: any) {\n      console.error(\"Error listing MCP tools:\", error);\n      res.status(500).json({ error: error.message });\n    }\n  });\n\n  app.post(\"/api/mcp/servers/:id/tools/:toolName\", async (req, res) => {\n    try {\n      const { id, toolName } = req.params;\n      \n      const connection = await storage.getMCPConnection(id);\n      if (!connection) {\n        return res.status(404).json({ error: \"MCP server not found\" });\n      }\n\n      const client = mcpClientManager.getClient(id);\n      if (!client) {\n        return res.status(503).json({ error: \"MCP server not initialized\" });\n      }\n\n      const executionRequest = mcpToolExecutionRequestSchema.parse({\n        toolName,\n        params: req.body,\n      });\n\n      const result = await client.callTool(executionRequest.toolName, executionRequest.params);\n\n      await storage.updateMCPConnection(id, {\n        lastUsed: new Date().toISOString(),\n      });\n\n      res.json(result);\n    } catch (error: any) {\n      console.error(\"Error executing MCP tool:\", error);\n      res.status(500).json({ error: error.message });\n    }\n  });\n\n  app.get(\"/api/mcp/servers/:id/resources\", async (req, res) => {\n    try {\n      const connection = await storage.getMCPConnection(req.params.id);\n      if (!connection) {\n        return res.status(404).json({ error: \"MCP server not found\" });\n      }\n\n      const client = mcpClientManager.getClient(connection.id);\n      if (!client) {\n        return res.status(503).json({ error: \"MCP server not initialized\" });\n      }\n\n      const resources = await client.getResources();\n\n      await storage.updateMCPConnection(connection.id, {\n        lastUsed: new Date().toISOString(),\n      });\n\n      res.json({ resources });\n    } catch (error: any) {\n      console.error(\"Error listing MCP resources:\", error);\n      res.status(500).json({ error: error.message });\n    }\n  });\n\n  app.get(\"/api/mcp/servers/:id/prompts\", async (req, res) => {\n    try {\n      const connection = await storage.getMCPConnection(req.params.id);\n      if (!connection) {\n        return res.status(404).json({ error: \"MCP server not found\" });\n      }\n\n      const client = mcpClientManager.getClient(connection.id);\n      if (!client) {\n        return res.status(503).json({ error: \"MCP server not initialized\" });\n      }\n\n      const prompts = await client.getPromptTemplates();\n\n      await storage.updateMCPConnection(connection.id, {\n        lastUsed: new Date().toISOString(),\n      });\n\n      res.json({ prompts });\n    } catch (error: any) {\n      console.error(\"Error listing MCP prompts:\", error);\n      res.status(500).json({ error: error.message });\n    }\n  });\n\n  app.delete(\"/api/mcp/servers/:id\", async (req, res) => {\n    try {\n      const connection = await storage.getMCPConnection(req.params.id);\n      if (!connection) {\n        return res.status(404).json({ error: \"MCP server not found\" });\n      }\n\n      await mcpClientManager.closeClient(connection.id);\n      \n      const deleted = await storage.deleteMCPConnection(connection.id);\n      \n      if (!deleted) {\n        return res.status(404).json({ error: \"Failed to delete MCP server\" });\n      }\n\n      res.json({ success: true, message: \"MCP server deleted successfully\" });\n    } catch (error: any) {\n      console.error(\"Error deleting MCP server:\", error);\n      res.status(500).json({ error: error.message });\n    }\n  });\n\n  // === SSE ENDPOINT FOR REAL-TIME LOGS ===\n  app.get(\"/api/tasks/:id/logs/stream\", (req, res) => {\n    const taskId = req.params.id;\n\n    res.writeHead(200, {\n      \"Content-Type\": \"text/event-stream\",\n      \"Cache-Control\": \"no-cache\",\n      Connection: \"keep-alive\",\n    });\n\n    // Send initial logs\n    storage.getTask(taskId).then((task) => {\n      if (task) {\n        task.logs.forEach((log) => {\n          res.write(`data: ${JSON.stringify(log)}\\n\\n`);\n        });\n      }\n    });\n\n    // Add client to SSE clients for this task\n    if (!sseClients.has(taskId)) {\n      sseClients.set(taskId, new Set());\n    }\n    sseClients.get(taskId)!.add(res);\n\n    // Remove client on disconnect\n    req.on(\"close\", () => {\n      const clients = sseClients.get(taskId);\n      if (clients) {\n        clients.delete(res);\n        if (clients.size === 0) {\n          sseClients.delete(taskId);\n        }\n      }\n    });\n  });\n\n  // === METRICS ENDPOINT ===\n  app.get(\"/api/metrics\", async (_req, res) => {\n    const allTasks = await storage.getAllTasks();\n    const activeTasks = allTasks.filter(\n      (t) => t.status === \"executing\" || t.status === \"planning\" || t.status === \"queued\"\n    );\n    const completedTasks = allTasks.filter((t) => t.status === \"completed\");\n    const totalTasks = allTasks.length;\n\n    const successRate = totalTasks > 0 \n      ? Math.round((completedTasks.length / totalTasks) * 100)\n      : 0;\n\n    const avgTime = completedTasks.length > 0\n      ? completedTasks.reduce((acc, task) => {\n          const created = new Date(task.createdAt).getTime();\n          const updated = new Date(task.updatedAt).getTime();\n          return acc + (updated - created) / 1000 / 60;\n        }, 0) / completedTasks.length\n      : 0;\n\n    const events = await storage.getAllEvents();\n    const todayEvents = events.filter((e) => {\n      const eventDate = new Date(e.timestamp);\n      const today = new Date();\n      return eventDate.toDateString() === today.toDateString();\n    });\n\n    res.json({\n      activeTasks: activeTasks.length,\n      successRate: `${successRate}%`,\n      avgTime: `${avgTime.toFixed(1)}m`,\n      webhooks: todayEvents.length,\n    });\n  });\n\n  const httpServer = createServer(app);\n  return httpServer;\n}\n\n// Helper function to broadcast logs to SSE clients\nfunction broadcastLog(taskId: string, log: LogEntry) {\n  const clients = sseClients.get(taskId);\n  if (clients) {\n    const data = JSON.stringify(log);\n    clients.forEach((client) => {\n      client.write(`data: ${data}\\n\\n`);\n    });\n  }\n}\n\n// Helper function to add log and broadcast\nasync function addLog(taskId: string, level: LogEntry[\"level\"], message: string) {\n  const log: LogEntry = {\n    id: randomUUID(),\n    timestamp: new Date().toLocaleTimeString(\"en-US\", { hour12: false }),\n    level,\n    message,\n  };\n  await storage.addTaskLog(taskId, log);\n  broadcastLog(taskId, log);\n}\n\n// Task processing simulation\nasync function processTask(taskId: string, steps: string[]) {\n  await addLog(taskId, \"info\", `Task ${taskId} started`);\n  \n  // Update to planning\n  await storage.updateTask(taskId, { status: \"planning\", progress: 10 });\n  await addLog(taskId, \"info\", \"Analyzing task requirements...\");\n\n  // Add reasoning steps\n  for (let i = 0; i < steps.length; i++) {\n    const step = steps[i];\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n\n    if (aiService) {\n      try {\n        const reasoning = await aiService.explainReasoning(step, `Step ${i + 1} of ${steps.length}`);\n        const reasoningStep: ReasoningStep = {\n          id: randomUUID(),\n          timestamp: new Date().toLocaleTimeString(\"en-US\", { hour12: false }),\n          description: reasoning.description,\n          confidence: reasoning.confidence,\n          completed: true,\n        };\n        await storage.addTaskReasoning(taskId, reasoningStep);\n        await addLog(taskId, \"success\", `Reasoning: ${reasoning.description}`);\n      } catch (error) {\n        await addLog(taskId, \"warn\", `Could not generate reasoning for: ${step}`);\n      }\n    }\n\n    await storage.updateTask(taskId, {\n      progress: 10 + Math.round((i / steps.length) * 40),\n    });\n  }\n\n  // Execute\n  await storage.updateTask(taskId, { status: \"executing\", progress: 50 });\n  await addLog(taskId, \"info\", \"Executing planned changes...\");\n\n  await new Promise((resolve) => setTimeout(resolve, 2000));\n  await addLog(taskId, \"success\", \"Simulated code modifications applied\");\n  await storage.updateTask(taskId, { progress: 80 });\n\n  await new Promise((resolve) => setTimeout(resolve, 1000));\n  await addLog(taskId, \"info\", \"Running test suite...\");\n  await new Promise((resolve) => setTimeout(resolve, 1500));\n  await addLog(taskId, \"success\", \"All tests passed (simulation)\");\n\n  // Complete\n  await storage.updateTask(taskId, { status: \"completed\", progress: 100 });\n  await addLog(taskId, \"success\", \"Task completed successfully\");\n}\n","size_bytes":26843},"client/src/lib/utils.ts":{"content":"import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n","size_bytes":166},"client/src/components/examples/StatusBadge.tsx":{"content":"import { StatusBadge } from '../status-badge';\n\nexport default function StatusBadgeExample() {\n  return (\n    <div className=\"flex gap-2 p-4\">\n      <StatusBadge status=\"planning\" />\n      <StatusBadge status=\"executing\" />\n      <StatusBadge status=\"completed\" />\n      <StatusBadge status=\"failed\" />\n      <StatusBadge status=\"queued\" />\n    </div>\n  );\n}\n","size_bytes":359},"server/services/mcp-client.ts":{"content":"import type {\n  MCPServerConfig,\n  MCPTool,\n  MCPResource,\n  MCPPromptTemplate,\n  MCPToolExecutionResult,\n} from \"@shared/schema\";\nimport { spawn, type ChildProcess } from \"child_process\";\nimport { randomUUID } from \"crypto\";\n\ninterface JSONRPCRequest {\n  jsonrpc: \"2.0\";\n  id: string | number;\n  method: string;\n  params?: any;\n}\n\ninterface JSONRPCResponse {\n  jsonrpc: \"2.0\";\n  id: string | number;\n  result?: any;\n  error?: {\n    code: number;\n    message: string;\n    data?: any;\n  };\n}\n\ninterface JSONRPCNotification {\n  jsonrpc: \"2.0\";\n  method: string;\n  params?: any;\n}\n\ninterface MCPServerCapabilities {\n  tools?: boolean;\n  resources?: boolean;\n  prompts?: boolean;\n}\n\ninterface MCPInitializeResult {\n  protocolVersion: string;\n  capabilities: MCPServerCapabilities;\n  serverInfo: {\n    name: string;\n    version: string;\n  };\n}\n\nexport class MCPClient {\n  private config: MCPServerConfig;\n  private process?: ChildProcess;\n  private messageBuffer: string = \"\";\n  private pendingRequests: Map<string | number, {\n    resolve: (value: any) => void;\n    reject: (error: any) => void;\n  }> = new Map();\n  private requestIdCounter: number = 0;\n  private tools: MCPTool[] = [];\n  private resources: MCPResource[] = [];\n  private promptTemplates: MCPPromptTemplate[] = [];\n  private capabilities?: MCPServerCapabilities;\n  private initialized: boolean = false;\n\n  constructor(config: MCPServerConfig) {\n    this.config = config;\n  }\n\n  async initialize(): Promise<MCPInitializeResult> {\n    if (this.initialized) {\n      throw new Error(\"MCP client already initialized\");\n    }\n\n    if (this.config.command) {\n      this.process = spawn(this.config.command, this.config.args || [], {\n        env: { ...process.env, ...this.config.env },\n        stdio: [\"pipe\", \"pipe\", \"pipe\"],\n      });\n\n      if (!this.process.stdin || !this.process.stdout || !this.process.stderr) {\n        throw new Error(\"Failed to establish MCP server process streams\");\n      }\n\n      this.process.stdout.on(\"data\", (data: Buffer) => {\n        this.handleStdout(data.toString());\n      });\n\n      this.process.stderr.on(\"data\", (data: Buffer) => {\n        console.error(`[MCP ${this.config.name}] stderr:`, data.toString());\n      });\n\n      this.process.on(\"error\", (error) => {\n        console.error(`[MCP ${this.config.name}] Process error:`, error);\n        this.rejectAllPendingRequests(error);\n      });\n\n      this.process.on(\"exit\", (code, signal) => {\n        console.log(`[MCP ${this.config.name}] Process exited: code=${code}, signal=${signal}`);\n        this.rejectAllPendingRequests(new Error(`Process exited with code ${code}`));\n      });\n    }\n\n    const initResult = await this.sendRequest<MCPInitializeResult>(\"initialize\", {\n      protocolVersion: \"2024-11-05\",\n      capabilities: {\n        tools: true,\n        resources: true,\n        prompts: true,\n      },\n      clientInfo: {\n        name: \"ai-github-agent\",\n        version: \"1.0.0\",\n      },\n    });\n\n    this.capabilities = initResult.capabilities;\n    this.initialized = true;\n\n    await this.sendNotification(\"initialized\", {});\n\n    if (this.capabilities?.tools) {\n      await this.refreshTools();\n    }\n\n    if (this.capabilities?.resources) {\n      await this.refreshResources();\n    }\n\n    if (this.capabilities?.prompts) {\n      await this.refreshPromptTemplates();\n    }\n\n    return initResult;\n  }\n\n  async listTools(): Promise<MCPTool[]> {\n    if (!this.capabilities?.tools) {\n      return [];\n    }\n    return this.tools;\n  }\n\n  async callTool(toolName: string, params?: Record<string, any>): Promise<MCPToolExecutionResult> {\n    if (!this.initialized) {\n      throw new Error(\"MCP client not initialized. Call initialize() first.\");\n    }\n\n    if (!this.capabilities?.tools) {\n      throw new Error(\"MCP server does not support tools\");\n    }\n\n    const startTime = Date.now();\n    try {\n      const result = await this.sendRequest(\"tools/call\", {\n        name: toolName,\n        arguments: params || {},\n      });\n\n      const executionTime = Date.now() - startTime;\n\n      return {\n        success: true,\n        result: result.content || result,\n        executionTime,\n      };\n    } catch (error: any) {\n      const executionTime = Date.now() - startTime;\n      return {\n        success: false,\n        error: error.message || \"Tool execution failed\",\n        executionTime,\n      };\n    }\n  }\n\n  async getResources(): Promise<MCPResource[]> {\n    if (!this.capabilities?.resources) {\n      return [];\n    }\n    return this.resources;\n  }\n\n  async readResource(uri: string): Promise<any> {\n    if (!this.initialized) {\n      throw new Error(\"MCP client not initialized. Call initialize() first.\");\n    }\n\n    if (!this.capabilities?.resources) {\n      throw new Error(\"MCP server does not support resources\");\n    }\n\n    const result = await this.sendRequest(\"resources/read\", { uri });\n    return result.contents;\n  }\n\n  async getPromptTemplates(): Promise<MCPPromptTemplate[]> {\n    if (!this.capabilities?.prompts) {\n      return [];\n    }\n    return this.promptTemplates;\n  }\n\n  async getPromptTemplate(name: string, args?: Record<string, string>): Promise<any> {\n    if (!this.initialized) {\n      throw new Error(\"MCP client not initialized. Call initialize() first.\");\n    }\n\n    if (!this.capabilities?.prompts) {\n      throw new Error(\"MCP server does not support prompts\");\n    }\n\n    const result = await this.sendRequest(\"prompts/get\", {\n      name,\n      arguments: args || {},\n    });\n\n    return result.messages;\n  }\n\n  async close(): Promise<void> {\n    if (this.process) {\n      this.process.kill();\n      this.process = undefined;\n    }\n\n    this.rejectAllPendingRequests(new Error(\"MCP client closed\"));\n    this.initialized = false;\n    this.tools = [];\n    this.resources = [];\n    this.promptTemplates = [];\n    this.capabilities = undefined;\n  }\n\n  private async refreshTools(): Promise<void> {\n    try {\n      const result = await this.sendRequest<{ tools: MCPTool[] }>(\"tools/list\", {});\n      this.tools = result.tools || [];\n    } catch (error) {\n      console.error(`[MCP ${this.config.name}] Failed to refresh tools:`, error);\n      this.tools = [];\n    }\n  }\n\n  private async refreshResources(): Promise<void> {\n    try {\n      const result = await this.sendRequest<{ resources: MCPResource[] }>(\"resources/list\", {});\n      this.resources = result.resources || [];\n    } catch (error) {\n      console.error(`[MCP ${this.config.name}] Failed to refresh resources:`, error);\n      this.resources = [];\n    }\n  }\n\n  private async refreshPromptTemplates(): Promise<void> {\n    try {\n      const result = await this.sendRequest<{ prompts: MCPPromptTemplate[] }>(\"prompts/list\", {});\n      this.promptTemplates = result.prompts || [];\n    } catch (error) {\n      console.error(`[MCP ${this.config.name}] Failed to refresh prompts:`, error);\n      this.promptTemplates = [];\n    }\n  }\n\n  private async sendRequest<T = any>(method: string, params?: any): Promise<T> {\n    const id = ++this.requestIdCounter;\n    const request: JSONRPCRequest = {\n      jsonrpc: \"2.0\",\n      id,\n      method,\n      params,\n    };\n\n    return new Promise((resolve, reject) => {\n      this.pendingRequests.set(id, { resolve, reject });\n\n      const message = JSON.stringify(request) + \"\\n\";\n      \n      if (this.process?.stdin) {\n        this.process.stdin.write(message);\n      } else {\n        this.pendingRequests.delete(id);\n        reject(new Error(\"MCP server process not running\"));\n      }\n\n      setTimeout(() => {\n        if (this.pendingRequests.has(id)) {\n          this.pendingRequests.delete(id);\n          reject(new Error(`Request timeout: ${method}`));\n        }\n      }, 30000);\n    });\n  }\n\n  private async sendNotification(method: string, params?: any): Promise<void> {\n    const notification: JSONRPCNotification = {\n      jsonrpc: \"2.0\",\n      method,\n      params,\n    };\n\n    const message = JSON.stringify(notification) + \"\\n\";\n\n    if (this.process?.stdin) {\n      this.process.stdin.write(message);\n    } else {\n      throw new Error(\"MCP server process not running\");\n    }\n  }\n\n  private handleStdout(data: string): void {\n    this.messageBuffer += data;\n\n    const lines = this.messageBuffer.split(\"\\n\");\n    this.messageBuffer = lines.pop() || \"\";\n\n    for (const line of lines) {\n      if (line.trim()) {\n        try {\n          const message = JSON.parse(line);\n          this.handleMessage(message);\n        } catch (error) {\n          console.error(`[MCP ${this.config.name}] Failed to parse message:`, line, error);\n        }\n      }\n    }\n  }\n\n  private handleMessage(message: JSONRPCResponse | JSONRPCNotification): void {\n    if (\"id\" in message) {\n      const pending = this.pendingRequests.get(message.id);\n      if (pending) {\n        this.pendingRequests.delete(message.id);\n        \n        if (message.error) {\n          pending.reject(new Error(message.error.message));\n        } else {\n          pending.resolve(message.result);\n        }\n      }\n    } else {\n      this.handleNotification(message as JSONRPCNotification);\n    }\n  }\n\n  private handleNotification(notification: JSONRPCNotification): void {\n    console.log(`[MCP ${this.config.name}] Notification:`, notification.method, notification.params);\n\n    switch (notification.method) {\n      case \"tools/list_changed\":\n        this.refreshTools().catch(console.error);\n        break;\n      case \"resources/list_changed\":\n        this.refreshResources().catch(console.error);\n        break;\n      case \"prompts/list_changed\":\n        this.refreshPromptTemplates().catch(console.error);\n        break;\n    }\n  }\n\n  private rejectAllPendingRequests(error: Error): void {\n    for (const [id, pending] of this.pendingRequests.entries()) {\n      pending.reject(error);\n      this.pendingRequests.delete(id);\n    }\n  }\n\n  getConfig(): MCPServerConfig {\n    return { ...this.config };\n  }\n\n  isInitialized(): boolean {\n    return this.initialized;\n  }\n\n  getCapabilities(): MCPServerCapabilities | undefined {\n    return this.capabilities;\n  }\n}\n\nexport class MCPClientManager {\n  private clients: Map<string, MCPClient> = new Map();\n\n  async createClient(id: string, config: MCPServerConfig): Promise<MCPClient> {\n    if (this.clients.has(id)) {\n      throw new Error(`MCP client with id ${id} already exists`);\n    }\n\n    const client = new MCPClient(config);\n    await client.initialize();\n    this.clients.set(id, client);\n\n    return client;\n  }\n\n  getClient(id: string): MCPClient | undefined {\n    return this.clients.get(id);\n  }\n\n  getAllClients(): Map<string, MCPClient> {\n    return new Map(this.clients);\n  }\n\n  async closeClient(id: string): Promise<boolean> {\n    const client = this.clients.get(id);\n    if (!client) {\n      return false;\n    }\n\n    await client.close();\n    this.clients.delete(id);\n    return true;\n  }\n\n  async closeAllClients(): Promise<void> {\n    const closePromises = Array.from(this.clients.keys()).map(id => this.closeClient(id));\n    await Promise.all(closePromises);\n  }\n\n  listClients(): Array<{ id: string; config: MCPServerConfig; initialized: boolean }> {\n    return Array.from(this.clients.entries()).map(([id, client]) => ({\n      id,\n      config: client.getConfig(),\n      initialized: client.isInitialized(),\n    }));\n  }\n}\n","size_bytes":11251},"client/src/components/ui/card.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Card = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"shadcn-card rounded-xl border bg-card border-card-border text-card-foreground shadow-sm\",\n      className\n    )}\n    {...props}\n  />\n));\nCard.displayName = \"Card\"\n\nconst CardHeader = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex flex-col space-y-1.5 p-6\", className)}\n    {...props}\n  />\n));\nCardHeader.displayName = \"CardHeader\"\n\nconst CardTitle = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"text-2xl font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nCardTitle.displayName = \"CardTitle\"\n\nconst CardDescription = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n));\nCardDescription.displayName = \"CardDescription\"\n\nconst CardContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />\n))\nCardContent.displayName = \"CardContent\"\n\nconst CardFooter = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex items-center p-6 pt-0\", className)}\n    {...props}\n  />\n))\nCardFooter.displayName = \"CardFooter\"\nexport {\n  Card,\n  CardHeader,\n  CardFooter,\n  CardTitle,\n  CardDescription,\n  CardContent,\n}\n","size_bytes":1904},"client/src/components/ui/toggle-group.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as ToggleGroupPrimitive from \"@radix-ui/react-toggle-group\"\nimport { type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\nimport { toggleVariants } from \"@/components/ui/toggle\"\n\nconst ToggleGroupContext = React.createContext<\n  VariantProps<typeof toggleVariants>\n>({\n  size: \"default\",\n  variant: \"default\",\n})\n\nconst ToggleGroup = React.forwardRef<\n  React.ElementRef<typeof ToggleGroupPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &\n    VariantProps<typeof toggleVariants>\n>(({ className, variant, size, children, ...props }, ref) => (\n  <ToggleGroupPrimitive.Root\n    ref={ref}\n    className={cn(\"flex items-center justify-center gap-1\", className)}\n    {...props}\n  >\n    <ToggleGroupContext.Provider value={{ variant, size }}>\n      {children}\n    </ToggleGroupContext.Provider>\n  </ToggleGroupPrimitive.Root>\n))\n\nToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName\n\nconst ToggleGroupItem = React.forwardRef<\n  React.ElementRef<typeof ToggleGroupPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &\n    VariantProps<typeof toggleVariants>\n>(({ className, children, variant, size, ...props }, ref) => {\n  const context = React.useContext(ToggleGroupContext)\n\n  return (\n    <ToggleGroupPrimitive.Item\n      ref={ref}\n      className={cn(\n        toggleVariants({\n          variant: context.variant || variant,\n          size: context.size || size,\n        }),\n        className\n      )}\n      {...props}\n    >\n      {children}\n    </ToggleGroupPrimitive.Item>\n  )\n})\n\nToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName\n\nexport { ToggleGroup, ToggleGroupItem }\n","size_bytes":1753},"client/src/components/ui/avatar.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as AvatarPrimitive from \"@radix-ui/react-avatar\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Avatar = React.forwardRef<\n  React.ElementRef<typeof AvatarPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <AvatarPrimitive.Root\n    ref={ref}\n    className={cn(`\n      after:content-[''] after:block after:absolute after:inset-0 after:rounded-full after:pointer-events-none after:border after:border-black/10 dark:after:border-white/10\n      relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full`,\n      className\n    )}\n    {...props}\n  />\n))\nAvatar.displayName = AvatarPrimitive.Root.displayName\n\nconst AvatarImage = React.forwardRef<\n  React.ElementRef<typeof AvatarPrimitive.Image>,\n  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>\n>(({ className, ...props }, ref) => (\n  <AvatarPrimitive.Image\n    ref={ref}\n    className={cn(\"aspect-square h-full w-full\", className)}\n    {...props}\n  />\n))\nAvatarImage.displayName = AvatarPrimitive.Image.displayName\n\nconst AvatarFallback = React.forwardRef<\n  React.ElementRef<typeof AvatarPrimitive.Fallback>,\n  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>\n>(({ className, ...props }, ref) => (\n  <AvatarPrimitive.Fallback\n    ref={ref}\n    className={cn(\n      \"flex h-full w-full items-center justify-center rounded-full bg-muted\",\n      className\n    )}\n    {...props}\n  />\n))\nAvatarFallback.displayName = AvatarPrimitive.Fallback.displayName\n\nexport { Avatar, AvatarImage, AvatarFallback }\n","size_bytes":1592},"client/src/components/ui/dialog.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as DialogPrimitive from \"@radix-ui/react-dialog\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Dialog = DialogPrimitive.Root\n\nconst DialogTrigger = DialogPrimitive.Trigger\n\nconst DialogPortal = DialogPrimitive.Portal\n\nconst DialogClose = DialogPrimitive.Close\n\nconst DialogOverlay = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Overlay\n    ref={ref}\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogOverlay.displayName = DialogPrimitive.Overlay.displayName\n\nconst DialogContent = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <DialogPortal>\n    <DialogOverlay />\n    <DialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\n        className\n      )}\n      {...props}\n    >\n      {children}\n      <DialogPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground\">\n        <X className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Close</span>\n      </DialogPrimitive.Close>\n    </DialogPrimitive.Content>\n  </DialogPortal>\n))\nDialogContent.displayName = DialogPrimitive.Content.displayName\n\nconst DialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-1.5 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogHeader.displayName = \"DialogHeader\"\n\nconst DialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogFooter.displayName = \"DialogFooter\"\n\nconst DialogTitle = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Title\n    ref={ref}\n    className={cn(\n      \"text-lg font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogTitle.displayName = DialogPrimitive.Title.displayName\n\nconst DialogDescription = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nDialogDescription.displayName = DialogPrimitive.Description.displayName\n\nexport {\n  Dialog,\n  DialogPortal,\n  DialogOverlay,\n  DialogClose,\n  DialogTrigger,\n  DialogContent,\n  DialogHeader,\n  DialogFooter,\n  DialogTitle,\n  DialogDescription,\n}\n","size_bytes":3848},"server/services/repository-context.ts":{"content":"import type { IStorage } from \"../storage\";\nimport type { RepositoryContext, InsertRepositoryContext } from \"@shared/schema\";\nimport { GitHubService } from \"./github\";\nimport { AIService } from \"./ai\";\n\ninterface FileInfo {\n  path: string;\n  type: string;\n  size: number;\n  sha: string;\n}\n\ninterface ArchitectureInfo {\n  framework?: string;\n  language?: string;\n  buildSystem?: string;\n  testFramework?: string;\n  directories: Record<string, string>;\n  patterns: string[];\n}\n\ninterface DependencyInfo {\n  name: string;\n  version: string;\n  type: \"production\" | \"development\" | \"peer\";\n}\n\ninterface CommitInfo {\n  sha: string;\n  message: string;\n  author: string;\n  date: string;\n}\n\ninterface BranchInfo {\n  name: string;\n  sha: string;\n  protected: boolean;\n}\n\ninterface IssueInfo {\n  number: number;\n  title: string;\n  state: string;\n  labels: string[];\n}\n\nexport class RepositoryContextService {\n  private storage: IStorage;\n  private githubService: GitHubService;\n  private aiService: AIService | null;\n\n  constructor(storage: IStorage, githubService: GitHubService, aiService?: AIService) {\n    this.storage = storage;\n    this.githubService = githubService;\n    this.aiService = aiService || null;\n  }\n\n  async getOrCreateContext(repository: string): Promise<RepositoryContext> {\n    let context = await this.storage.getRepositoryContext(repository);\n    \n    if (!context) {\n      const insertContext: InsertRepositoryContext = {\n        repository,\n      };\n      context = await this.storage.createRepositoryContext(insertContext);\n    }\n\n    return context;\n  }\n\n  async updateArchitecture(repository: string, files: FileInfo[]): Promise<void> {\n    const architecture = await this.analyzeArchitecture(files);\n    await this.storage.updateRepositoryContext(repository, { architecture });\n  }\n\n  async updateDependencies(repository: string, owner: string, repo: string): Promise<void> {\n    const dependencies = await this.analyzeDependencies(owner, repo);\n    await this.storage.updateRepositoryContext(repository, { dependencies });\n  }\n\n  async addCommit(repository: string, commit: CommitInfo): Promise<void> {\n    const context = await this.getOrCreateContext(repository);\n    const recentCommits = context.recentCommits || [];\n    \n    const updated = [commit, ...recentCommits.slice(0, 49)];\n    await this.storage.updateRepositoryContext(repository, { \n      recentCommits: updated as Array<Record<string, any>>\n    });\n  }\n\n  async refreshContext(repository: string): Promise<RepositoryContext> {\n    const [owner, repo] = repository.split(\"/\");\n    if (!owner || !repo) {\n      throw new Error(\"Invalid repository format. Expected 'owner/repo'\");\n    }\n\n    const context = await this.getOrCreateContext(repository);\n\n    try {\n      const [repoInfo, files, branches] = await Promise.all([\n        this.githubService.getRepository(owner, repo),\n        this.fetchAllFiles(owner, repo),\n        this.fetchBranches(owner, repo),\n      ]);\n\n      const [architecture, dependencies, commits, issues] = await Promise.all([\n        this.analyzeArchitecture(files),\n        this.analyzeDependencies(owner, repo),\n        this.fetchRecentCommits(owner, repo),\n        this.fetchOpenIssues(owner, repo),\n      ]);\n\n      const fileStructure = files.map((f) => f.path);\n\n      await this.storage.updateRepositoryContext(repository, {\n        architecture,\n        dependencies,\n        fileStructure,\n        branches: branches as Array<Record<string, any>>,\n        recentCommits: commits as Array<Record<string, any>>,\n        openIssues: issues as Array<Record<string, any>>,\n      });\n\n      if (this.aiService) {\n        const summary = await this.generateSemanticSummary(repository, {\n          architecture,\n          dependencies,\n          fileStructure,\n          recentCommits: commits,\n        });\n        await this.storage.updateRepositoryContext(repository, { semanticSummary: summary });\n      }\n\n      return (await this.storage.getRepositoryContext(repository))!;\n    } catch (error) {\n      console.error(`Error refreshing context for ${repository}:`, error);\n      throw error;\n    }\n  }\n\n  async getSemanticSummary(repository: string): Promise<string> {\n    const context = await this.storage.getRepositoryContext(repository);\n    \n    if (context?.semanticSummary) {\n      return context.semanticSummary;\n    }\n\n    if (!this.aiService) {\n      return \"AI service not configured. Unable to generate semantic summary.\";\n    }\n\n    const summary = await this.generateSemanticSummary(repository, {\n      architecture: context?.architecture,\n      dependencies: context?.dependencies,\n      fileStructure: context?.fileStructure,\n      recentCommits: context?.recentCommits,\n    });\n\n    await this.storage.updateRepositoryContext(repository, { semanticSummary: summary });\n    return summary;\n  }\n\n  private async fetchAllFiles(owner: string, repo: string, path: string = \"\"): Promise<FileInfo[]> {\n    try {\n      const items = await this.githubService.listFiles(owner, repo, path);\n      const files: FileInfo[] = [];\n\n      for (const item of items) {\n        if (item.type === \"file\") {\n          files.push({\n            path: item.path,\n            type: item.type,\n            size: item.size,\n            sha: item.sha,\n          });\n        } else if (item.type === \"dir\") {\n          const subFiles = await this.fetchAllFiles(owner, repo, item.path);\n          files.push(...subFiles);\n        }\n      }\n\n      return files;\n    } catch (error) {\n      console.error(`Error fetching files for ${owner}/${repo}:`, error);\n      return [];\n    }\n  }\n\n  private async fetchBranches(owner: string, repo: string): Promise<BranchInfo[]> {\n    try {\n      const response = await fetch(\n        `https://api.github.com/repos/${owner}/${repo}/branches`,\n        {\n          headers: {\n            Accept: \"application/vnd.github+json\",\n            Authorization: `Bearer ${(this.githubService as any).settings.token}`,\n          },\n        }\n      );\n      \n      if (!response.ok) return [];\n      \n      const branches = await response.json();\n      return branches.map((b: any) => ({\n        name: b.name,\n        sha: b.commit.sha,\n        protected: b.protected || false,\n      }));\n    } catch (error) {\n      console.error(`Error fetching branches:`, error);\n      return [];\n    }\n  }\n\n  private async fetchRecentCommits(owner: string, repo: string, limit: number = 50): Promise<CommitInfo[]> {\n    try {\n      const response = await fetch(\n        `https://api.github.com/repos/${owner}/${repo}/commits?per_page=${limit}`,\n        {\n          headers: {\n            Accept: \"application/vnd.github+json\",\n            Authorization: `Bearer ${(this.githubService as any).settings.token}`,\n          },\n        }\n      );\n      \n      if (!response.ok) return [];\n      \n      const commits = await response.json();\n      return commits.map((c: any) => ({\n        sha: c.sha,\n        message: c.commit.message,\n        author: c.commit.author.name,\n        date: c.commit.author.date,\n      }));\n    } catch (error) {\n      console.error(`Error fetching commits:`, error);\n      return [];\n    }\n  }\n\n  private async fetchOpenIssues(owner: string, repo: string): Promise<IssueInfo[]> {\n    try {\n      const response = await fetch(\n        `https://api.github.com/repos/${owner}/${repo}/issues?state=open&per_page=100`,\n        {\n          headers: {\n            Accept: \"application/vnd.github+json\",\n            Authorization: `Bearer ${(this.githubService as any).settings.token}`,\n          },\n        }\n      );\n      \n      if (!response.ok) return [];\n      \n      const issues = await response.json();\n      return issues\n        .filter((i: any) => !i.pull_request)\n        .map((i: any) => ({\n          number: i.number,\n          title: i.title,\n          state: i.state,\n          labels: i.labels.map((l: any) => l.name),\n        }));\n    } catch (error) {\n      console.error(`Error fetching issues:`, error);\n      return [];\n    }\n  }\n\n  private async analyzeArchitecture(files: FileInfo[]): Promise<Record<string, any>> {\n    const architecture: ArchitectureInfo = {\n      directories: {},\n      patterns: [],\n    };\n\n    const paths = files.map((f) => f.path);\n    const directories = new Set<string>();\n    \n    for (const path of paths) {\n      const parts = path.split(\"/\");\n      for (let i = 1; i < parts.length; i++) {\n        directories.add(parts.slice(0, i).join(\"/\"));\n      }\n    }\n\n    if (paths.some((p) => p.includes(\"package.json\"))) {\n      architecture.language = \"JavaScript/TypeScript\";\n      architecture.buildSystem = \"npm/yarn\";\n    }\n    if (paths.some((p) => p.includes(\"requirements.txt\") || p.includes(\"setup.py\"))) {\n      architecture.language = \"Python\";\n    }\n    if (paths.some((p) => p.includes(\"go.mod\"))) {\n      architecture.language = \"Go\";\n    }\n    if (paths.some((p) => p.includes(\"Cargo.toml\"))) {\n      architecture.language = \"Rust\";\n      architecture.buildSystem = \"Cargo\";\n    }\n\n    if (paths.some((p) => p.includes(\"vite.config\"))) {\n      architecture.framework = \"Vite\";\n    } else if (paths.some((p) => p.includes(\"next.config\"))) {\n      architecture.framework = \"Next.js\";\n    } else if (paths.some((p) => p.includes(\"nuxt.config\"))) {\n      architecture.framework = \"Nuxt\";\n    }\n\n    if (paths.some((p) => p.includes(\"jest.config\") || p.includes(\"vitest.config\"))) {\n      architecture.testFramework = paths.some((p) => p.includes(\"vitest\")) ? \"Vitest\" : \"Jest\";\n    }\n\n    for (const dir of Array.from(directories)) {\n      const dirName = dir.split(\"/\").pop() || \"\";\n      if ([\"src\", \"lib\", \"app\", \"pages\", \"components\"].includes(dirName)) {\n        architecture.directories[dir] = \"Source code\";\n      } else if ([\"test\", \"tests\", \"__tests__\"].includes(dirName)) {\n        architecture.directories[dir] = \"Tests\";\n      } else if ([\"docs\", \"documentation\"].includes(dirName)) {\n        architecture.directories[dir] = \"Documentation\";\n      } else if ([\"config\", \"configs\"].includes(dirName)) {\n        architecture.directories[dir] = \"Configuration\";\n      }\n    }\n\n    if (paths.some((p) => p.match(/.*\\.(test|spec)\\.(ts|js|tsx|jsx)$/))) {\n      architecture.patterns.push(\"Unit tests\");\n    }\n    if (paths.some((p) => p.includes(\"e2e\") || p.includes(\"cypress\"))) {\n      architecture.patterns.push(\"E2E tests\");\n    }\n    if (paths.some((p) => p.includes(\"docker\"))) {\n      architecture.patterns.push(\"Docker containerization\");\n    }\n    if (paths.some((p) => p.includes(\".github/workflows\"))) {\n      architecture.patterns.push(\"GitHub Actions CI/CD\");\n    }\n\n    return architecture as Record<string, any>;\n  }\n\n  private async analyzeDependencies(owner: string, repo: string): Promise<Record<string, any>> {\n    const dependencies: Record<string, DependencyInfo[]> = {\n      production: [],\n      development: [],\n    };\n\n    try {\n      const packageJson = await this.githubService.getFileContent(owner, repo, \"package.json\");\n      const pkg = JSON.parse(packageJson);\n\n      if (pkg.dependencies) {\n        for (const [name, version] of Object.entries(pkg.dependencies)) {\n          dependencies.production.push({\n            name,\n            version: version as string,\n            type: \"production\",\n          });\n        }\n      }\n\n      if (pkg.devDependencies) {\n        for (const [name, version] of Object.entries(pkg.devDependencies)) {\n          dependencies.development.push({\n            name,\n            version: version as string,\n            type: \"development\",\n          });\n        }\n      }\n    } catch (error) {\n    }\n\n    try {\n      const requirementsTxt = await this.githubService.getFileContent(owner, repo, \"requirements.txt\");\n      const lines = requirementsTxt.split(\"\\n\").filter((line) => line.trim() && !line.startsWith(\"#\"));\n      \n      for (const line of lines) {\n        const match = line.match(/^([a-zA-Z0-9_-]+)([=<>!]+)?([\\d.]+)?/);\n        if (match) {\n          dependencies.production.push({\n            name: match[1],\n            version: match[3] || \"latest\",\n            type: \"production\",\n          });\n        }\n      }\n    } catch (error) {\n    }\n\n    try {\n      const goMod = await this.githubService.getFileContent(owner, repo, \"go.mod\");\n      const lines = goMod.split(\"\\n\");\n      \n      for (const line of lines) {\n        const match = line.match(/^\\s+([a-zA-Z0-9_.\\/-]+)\\s+v?([\\d.]+)/);\n        if (match) {\n          dependencies.production.push({\n            name: match[1],\n            version: match[2],\n            type: \"production\",\n          });\n        }\n      }\n    } catch (error) {\n    }\n\n    return dependencies;\n  }\n\n  private async generateSemanticSummary(\n    repository: string,\n    context: {\n      architecture?: Record<string, any>;\n      dependencies?: Record<string, any>;\n      fileStructure?: string[];\n      recentCommits?: Array<Record<string, any>>;\n    }\n  ): Promise<string> {\n    if (!this.aiService) {\n      return \"AI service not available\";\n    }\n\n    const prompt = `Analyze this repository and provide a concise semantic summary:\n\nRepository: ${repository}\n\nArchitecture:\n${JSON.stringify(context.architecture, null, 2)}\n\nDependencies:\n${JSON.stringify(context.dependencies, null, 2)}\n\nFile Structure (first 100 files):\n${context.fileStructure?.slice(0, 100).join(\"\\n\") || \"Not available\"}\n\nRecent Commits (first 10):\n${context.recentCommits?.slice(0, 10).map((c: any) => `- ${c.message}`).join(\"\\n\") || \"Not available\"}\n\nProvide a summary that includes:\n1. Primary purpose of the repository\n2. Key technologies and frameworks used\n3. Architecture pattern (if identifiable)\n4. Recent development focus based on commits\n5. Potential areas for improvement\n\nKeep the summary concise (3-5 paragraphs).`;\n\n    try {\n      const result = await this.aiService.continueConversation(\n        `repo-summary-${repository}`,\n        prompt,\n        {}\n      );\n\n      return result.response;\n    } catch (error) {\n      console.error(\"Error generating semantic summary:\", error);\n      return \"Failed to generate semantic summary\";\n    }\n  }\n}\n","size_bytes":14051},"server/services/github.ts":{"content":"import type { GithubSettings } from \"@shared/schema\";\n\ninterface GitHubFile {\n  name: string;\n  path: string;\n  sha: string;\n  size: number;\n  type: \"file\" | \"dir\";\n  content?: string;\n}\n\ninterface GitHubRepository {\n  name: string;\n  full_name: string;\n  description: string;\n  default_branch: string;\n}\n\nexport class GitHubService {\n  private settings: GithubSettings;\n  private baseURL = \"https://api.github.com\";\n\n  constructor(settings: GithubSettings) {\n    this.settings = settings;\n  }\n\n  updateSettings(settings: GithubSettings) {\n    this.settings = settings;\n  }\n\n  async getRepository(owner: string, repo: string): Promise<GitHubRepository> {\n    const response = await this.request(`/repos/${owner}/${repo}`);\n    return response;\n  }\n\n  async getFileContent(\n    owner: string,\n    repo: string,\n    path: string,\n    ref?: string\n  ): Promise<string> {\n    const url = `/repos/${owner}/${repo}/contents/${path}${ref ? `?ref=${ref}` : \"\"}`;\n    const response = await this.request(url);\n\n    if (response.content) {\n      // GitHub returns base64 encoded content\n      return Buffer.from(response.content, \"base64\").toString(\"utf-8\");\n    }\n\n    throw new Error(\"File content not available\");\n  }\n\n  async listFiles(\n    owner: string,\n    repo: string,\n    path: string = \"\",\n    ref?: string\n  ): Promise<GitHubFile[]> {\n    const url = `/repos/${owner}/${repo}/contents/${path}${ref ? `?ref=${ref}` : \"\"}`;\n    const response = await this.request(url);\n    return Array.isArray(response) ? response : [response];\n  }\n\n  async createComment(\n    owner: string,\n    repo: string,\n    issueNumber: number,\n    body: string\n  ): Promise<void> {\n    await this.request(`/repos/${owner}/${repo}/issues/${issueNumber}/comments`, {\n      method: \"POST\",\n      body: JSON.stringify({ body }),\n    });\n  }\n\n  async createPullRequestComment(\n    owner: string,\n    repo: string,\n    pullNumber: number,\n    body: string,\n    path?: string,\n    position?: number\n  ): Promise<void> {\n    const comment: any = { body };\n    \n    if (path && position) {\n      comment.path = path;\n      comment.position = position;\n      await this.request(\n        `/repos/${owner}/${repo}/pulls/${pullNumber}/comments`,\n        {\n          method: \"POST\",\n          body: JSON.stringify(comment),\n        }\n      );\n    } else {\n      await this.createComment(owner, repo, pullNumber, body);\n    }\n  }\n\n  async getBranch(owner: string, repo: string, branch: string) {\n    return this.request(`/repos/${owner}/${repo}/branches/${branch}`);\n  }\n\n  async createBranch(\n    owner: string,\n    repo: string,\n    branchName: string,\n    fromBranch: string = \"main\"\n  ): Promise<void> {\n    const baseBranch = await this.getBranch(owner, repo, fromBranch);\n    const sha = baseBranch.commit.sha;\n\n    await this.request(`/repos/${owner}/${repo}/git/refs`, {\n      method: \"POST\",\n      body: JSON.stringify({\n        ref: `refs/heads/${branchName}`,\n        sha,\n      }),\n    });\n  }\n\n  async verifyWebhook(payload: string, signature: string): Promise<boolean> {\n    if (!this.settings.webhookSecret) {\n      return true; // No secret configured, accept all\n    }\n\n    const crypto = await import(\"crypto\");\n    const hmac = crypto.createHmac(\"sha256\", this.settings.webhookSecret);\n    const digest = \"sha256=\" + hmac.update(payload).digest(\"hex\");\n    \n    return crypto.timingSafeEqual(\n      Buffer.from(signature),\n      Buffer.from(digest)\n    );\n  }\n\n  private async request(path: string, options: RequestInit = {}): Promise<any> {\n    const url = `${this.baseURL}${path}`;\n    \n    const response = await fetch(url, {\n      ...options,\n      headers: {\n        Accept: \"application/vnd.github+json\",\n        Authorization: `Bearer ${this.settings.token}`,\n        \"X-GitHub-Api-Version\": \"2022-11-28\",\n        ...options.headers,\n      },\n    });\n\n    if (!response.ok) {\n      throw new Error(`GitHub API request failed: ${response.statusText}`);\n    }\n\n    return response.json();\n  }\n}\n","size_bytes":3980},"client/src/components/ui/navigation-menu.tsx":{"content":"import * as React from \"react\"\nimport * as NavigationMenuPrimitive from \"@radix-ui/react-navigation-menu\"\nimport { cva } from \"class-variance-authority\"\nimport { ChevronDown } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst NavigationMenu = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>\n>(({ className, children, ...props }, ref) => (\n  <NavigationMenuPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative z-10 flex max-w-max flex-1 items-center justify-center\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <NavigationMenuViewport />\n  </NavigationMenuPrimitive.Root>\n))\nNavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName\n\nconst NavigationMenuList = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.List\n    ref={ref}\n    className={cn(\n      \"group flex flex-1 list-none items-center justify-center space-x-1\",\n      className\n    )}\n    {...props}\n  />\n))\nNavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName\n\nconst NavigationMenuItem = NavigationMenuPrimitive.Item\n\nconst navigationMenuTriggerStyle = cva(\n  \"group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[state=open]:text-accent-foreground data-[state=open]:bg-accent/50 data-[state=open]:hover:bg-accent data-[state=open]:focus:bg-accent\"\n)\n\nconst NavigationMenuTrigger = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <NavigationMenuPrimitive.Trigger\n    ref={ref}\n    className={cn(navigationMenuTriggerStyle(), \"group\", className)}\n    {...props}\n  >\n    {children}{\" \"}\n    <ChevronDown\n      className=\"relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180\"\n      aria-hidden=\"true\"\n    />\n  </NavigationMenuPrimitive.Trigger>\n))\nNavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName\n\nconst NavigationMenuContent = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.Content\n    ref={ref}\n    className={cn(\n      \"left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto \",\n      className\n    )}\n    {...props}\n  />\n))\nNavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName\n\nconst NavigationMenuLink = NavigationMenuPrimitive.Link\n\nconst NavigationMenuViewport = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>\n>(({ className, ...props }, ref) => (\n  <div className={cn(\"absolute left-0 top-full flex justify-center\")}>\n    <NavigationMenuPrimitive.Viewport\n      className={cn(\n        \"origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]\",\n        className\n      )}\n      ref={ref}\n      {...props}\n    />\n  </div>\n))\nNavigationMenuViewport.displayName =\n  NavigationMenuPrimitive.Viewport.displayName\n\nconst NavigationMenuIndicator = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.Indicator\n    ref={ref}\n    className={cn(\n      \"top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in\",\n      className\n    )}\n    {...props}\n  >\n    <div className=\"relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md\" />\n  </NavigationMenuPrimitive.Indicator>\n))\nNavigationMenuIndicator.displayName =\n  NavigationMenuPrimitive.Indicator.displayName\n\nexport {\n  navigationMenuTriggerStyle,\n  NavigationMenu,\n  NavigationMenuList,\n  NavigationMenuItem,\n  NavigationMenuContent,\n  NavigationMenuTrigger,\n  NavigationMenuLink,\n  NavigationMenuIndicator,\n  NavigationMenuViewport,\n}\n","size_bytes":5128},"client/src/components/ui/toaster.tsx":{"content":"import { useToast } from \"@/hooks/use-toast\"\nimport {\n  Toast,\n  ToastClose,\n  ToastDescription,\n  ToastProvider,\n  ToastTitle,\n  ToastViewport,\n} from \"@/components/ui/toast\"\n\nexport function Toaster() {\n  const { toasts } = useToast()\n\n  return (\n    <ToastProvider>\n      {toasts.map(function ({ id, title, description, action, ...props }) {\n        return (\n          <Toast key={id} {...props}>\n            <div className=\"grid gap-1\">\n              {title && <ToastTitle>{title}</ToastTitle>}\n              {description && (\n                <ToastDescription>{description}</ToastDescription>\n              )}\n            </div>\n            {action}\n            <ToastClose />\n          </Toast>\n        )\n      })}\n      <ToastViewport />\n    </ToastProvider>\n  )\n}\n","size_bytes":772},"client/src/hooks/use-toast.ts":{"content":"import * as React from \"react\"\n\nimport type {\n  ToastActionElement,\n  ToastProps,\n} from \"@/components/ui/toast\"\n\nconst TOAST_LIMIT = 1\nconst TOAST_REMOVE_DELAY = 1000000\n\ntype ToasterToast = ToastProps & {\n  id: string\n  title?: React.ReactNode\n  description?: React.ReactNode\n  action?: ToastActionElement\n}\n\nconst actionTypes = {\n  ADD_TOAST: \"ADD_TOAST\",\n  UPDATE_TOAST: \"UPDATE_TOAST\",\n  DISMISS_TOAST: \"DISMISS_TOAST\",\n  REMOVE_TOAST: \"REMOVE_TOAST\",\n} as const\n\nlet count = 0\n\nfunction genId() {\n  count = (count + 1) % Number.MAX_SAFE_INTEGER\n  return count.toString()\n}\n\ntype ActionType = typeof actionTypes\n\ntype Action =\n  | {\n      type: ActionType[\"ADD_TOAST\"]\n      toast: ToasterToast\n    }\n  | {\n      type: ActionType[\"UPDATE_TOAST\"]\n      toast: Partial<ToasterToast>\n    }\n  | {\n      type: ActionType[\"DISMISS_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n  | {\n      type: ActionType[\"REMOVE_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n\ninterface State {\n  toasts: ToasterToast[]\n}\n\nconst toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()\n\nconst addToRemoveQueue = (toastId: string) => {\n  if (toastTimeouts.has(toastId)) {\n    return\n  }\n\n  const timeout = setTimeout(() => {\n    toastTimeouts.delete(toastId)\n    dispatch({\n      type: \"REMOVE_TOAST\",\n      toastId: toastId,\n    })\n  }, TOAST_REMOVE_DELAY)\n\n  toastTimeouts.set(toastId, timeout)\n}\n\nexport const reducer = (state: State, action: Action): State => {\n  switch (action.type) {\n    case \"ADD_TOAST\":\n      return {\n        ...state,\n        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\n      }\n\n    case \"UPDATE_TOAST\":\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === action.toast.id ? { ...t, ...action.toast } : t\n        ),\n      }\n\n    case \"DISMISS_TOAST\": {\n      const { toastId } = action\n\n      // ! Side effects ! - This could be extracted into a dismissToast() action,\n      // but I'll keep it here for simplicity\n      if (toastId) {\n        addToRemoveQueue(toastId)\n      } else {\n        state.toasts.forEach((toast) => {\n          addToRemoveQueue(toast.id)\n        })\n      }\n\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === toastId || toastId === undefined\n            ? {\n                ...t,\n                open: false,\n              }\n            : t\n        ),\n      }\n    }\n    case \"REMOVE_TOAST\":\n      if (action.toastId === undefined) {\n        return {\n          ...state,\n          toasts: [],\n        }\n      }\n      return {\n        ...state,\n        toasts: state.toasts.filter((t) => t.id !== action.toastId),\n      }\n  }\n}\n\nconst listeners: Array<(state: State) => void> = []\n\nlet memoryState: State = { toasts: [] }\n\nfunction dispatch(action: Action) {\n  memoryState = reducer(memoryState, action)\n  listeners.forEach((listener) => {\n    listener(memoryState)\n  })\n}\n\ntype Toast = Omit<ToasterToast, \"id\">\n\nfunction toast({ ...props }: Toast) {\n  const id = genId()\n\n  const update = (props: ToasterToast) =>\n    dispatch({\n      type: \"UPDATE_TOAST\",\n      toast: { ...props, id },\n    })\n  const dismiss = () => dispatch({ type: \"DISMISS_TOAST\", toastId: id })\n\n  dispatch({\n    type: \"ADD_TOAST\",\n    toast: {\n      ...props,\n      id,\n      open: true,\n      onOpenChange: (open) => {\n        if (!open) dismiss()\n      },\n    },\n  })\n\n  return {\n    id: id,\n    dismiss,\n    update,\n  }\n}\n\nfunction useToast() {\n  const [state, setState] = React.useState<State>(memoryState)\n\n  React.useEffect(() => {\n    listeners.push(setState)\n    return () => {\n      const index = listeners.indexOf(setState)\n      if (index > -1) {\n        listeners.splice(index, 1)\n      }\n    }\n  }, [state])\n\n  return {\n    ...state,\n    toast,\n    dismiss: (toastId?: string) => dispatch({ type: \"DISMISS_TOAST\", toastId }),\n  }\n}\n\nexport { useToast, toast }\n","size_bytes":3895},"client/src/components/ui/breadcrumb.tsx":{"content":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { ChevronRight, MoreHorizontal } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Breadcrumb = React.forwardRef<\n  HTMLElement,\n  React.ComponentPropsWithoutRef<\"nav\"> & {\n    separator?: React.ReactNode\n  }\n>(({ ...props }, ref) => <nav ref={ref} aria-label=\"breadcrumb\" {...props} />)\nBreadcrumb.displayName = \"Breadcrumb\"\n\nconst BreadcrumbList = React.forwardRef<\n  HTMLOListElement,\n  React.ComponentPropsWithoutRef<\"ol\">\n>(({ className, ...props }, ref) => (\n  <ol\n    ref={ref}\n    className={cn(\n      \"flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5\",\n      className\n    )}\n    {...props}\n  />\n))\nBreadcrumbList.displayName = \"BreadcrumbList\"\n\nconst BreadcrumbItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentPropsWithoutRef<\"li\">\n>(({ className, ...props }, ref) => (\n  <li\n    ref={ref}\n    className={cn(\"inline-flex items-center gap-1.5\", className)}\n    {...props}\n  />\n))\nBreadcrumbItem.displayName = \"BreadcrumbItem\"\n\nconst BreadcrumbLink = React.forwardRef<\n  HTMLAnchorElement,\n  React.ComponentPropsWithoutRef<\"a\"> & {\n    asChild?: boolean\n  }\n>(({ asChild, className, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"a\"\n\n  return (\n    <Comp\n      ref={ref}\n      className={cn(\"transition-colors hover:text-foreground\", className)}\n      {...props}\n    />\n  )\n})\nBreadcrumbLink.displayName = \"BreadcrumbLink\"\n\nconst BreadcrumbPage = React.forwardRef<\n  HTMLSpanElement,\n  React.ComponentPropsWithoutRef<\"span\">\n>(({ className, ...props }, ref) => (\n  <span\n    ref={ref}\n    role=\"link\"\n    aria-disabled=\"true\"\n    aria-current=\"page\"\n    className={cn(\"font-normal text-foreground\", className)}\n    {...props}\n  />\n))\nBreadcrumbPage.displayName = \"BreadcrumbPage\"\n\nconst BreadcrumbSeparator = ({\n  children,\n  className,\n  ...props\n}: React.ComponentProps<\"li\">) => (\n  <li\n    role=\"presentation\"\n    aria-hidden=\"true\"\n    className={cn(\"[&>svg]:w-3.5 [&>svg]:h-3.5\", className)}\n    {...props}\n  >\n    {children ?? <ChevronRight />}\n  </li>\n)\nBreadcrumbSeparator.displayName = \"BreadcrumbSeparator\"\n\nconst BreadcrumbEllipsis = ({\n  className,\n  ...props\n}: React.ComponentProps<\"span\">) => (\n  <span\n    role=\"presentation\"\n    aria-hidden=\"true\"\n    className={cn(\"flex h-9 w-9 items-center justify-center\", className)}\n    {...props}\n  >\n    <MoreHorizontal className=\"h-4 w-4\" />\n    <span className=\"sr-only\">More</span>\n  </span>\n)\nBreadcrumbEllipsis.displayName = \"BreadcrumbElipssis\"\n\nexport {\n  Breadcrumb,\n  BreadcrumbList,\n  BreadcrumbItem,\n  BreadcrumbLink,\n  BreadcrumbPage,\n  BreadcrumbSeparator,\n  BreadcrumbEllipsis,\n}\n","size_bytes":2712},"client/src/components/ui/context-menu.tsx":{"content":"import * as React from \"react\"\nimport * as ContextMenuPrimitive from \"@radix-ui/react-context-menu\"\nimport { Check, ChevronRight, Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ContextMenu = ContextMenuPrimitive.Root\n\nconst ContextMenuTrigger = ContextMenuPrimitive.Trigger\n\nconst ContextMenuGroup = ContextMenuPrimitive.Group\n\nconst ContextMenuPortal = ContextMenuPrimitive.Portal\n\nconst ContextMenuSub = ContextMenuPrimitive.Sub\n\nconst ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup\n\nconst ContextMenuSubTrigger = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {\n    inset?: boolean\n  }\n>(({ className, inset, children, ...props }, ref) => (\n  <ContextMenuPrimitive.SubTrigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <ChevronRight className=\"ml-auto h-4 w-4\" />\n  </ContextMenuPrimitive.SubTrigger>\n))\nContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName\n\nconst ContextMenuSubContent = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>\n>(({ className, ...props }, ref) => (\n  <ContextMenuPrimitive.SubContent\n    ref={ref}\n    className={cn(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-context-menu-content-transform-origin]\",\n      className\n    )}\n    {...props}\n  />\n))\nContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName\n\nconst ContextMenuContent = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <ContextMenuPrimitive.Portal>\n    <ContextMenuPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"z-50 max-h-[--radix-context-menu-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-context-menu-content-transform-origin]\",\n        className\n      )}\n      {...props}\n    />\n  </ContextMenuPrimitive.Portal>\n))\nContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName\n\nconst ContextMenuItem = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <ContextMenuPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName\n\nconst ContextMenuCheckboxItem = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>\n>(({ className, children, checked, ...props }, ref) => (\n  <ContextMenuPrimitive.CheckboxItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    checked={checked}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <ContextMenuPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </ContextMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </ContextMenuPrimitive.CheckboxItem>\n))\nContextMenuCheckboxItem.displayName =\n  ContextMenuPrimitive.CheckboxItem.displayName\n\nconst ContextMenuRadioItem = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>\n>(({ className, children, ...props }, ref) => (\n  <ContextMenuPrimitive.RadioItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <ContextMenuPrimitive.ItemIndicator>\n        <Circle className=\"h-2 w-2 fill-current\" />\n      </ContextMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </ContextMenuPrimitive.RadioItem>\n))\nContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName\n\nconst ContextMenuLabel = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <ContextMenuPrimitive.Label\n    ref={ref}\n    className={cn(\n      \"px-2 py-1.5 text-sm font-semibold text-foreground\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName\n\nconst ContextMenuSeparator = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <ContextMenuPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-border\", className)}\n    {...props}\n  />\n))\nContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName\n\nconst ContextMenuShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nContextMenuShortcut.displayName = \"ContextMenuShortcut\"\n\nexport {\n  ContextMenu,\n  ContextMenuTrigger,\n  ContextMenuContent,\n  ContextMenuItem,\n  ContextMenuCheckboxItem,\n  ContextMenuRadioItem,\n  ContextMenuLabel,\n  ContextMenuSeparator,\n  ContextMenuShortcut,\n  ContextMenuGroup,\n  ContextMenuPortal,\n  ContextMenuSub,\n  ContextMenuSubContent,\n  ContextMenuSubTrigger,\n  ContextMenuRadioGroup,\n}\n","size_bytes":7428},"client/src/components/theme-toggle.tsx":{"content":"import { Moon, Sun } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport { useEffect, useState } from \"react\";\n\nexport function ThemeToggle() {\n  const [theme, setTheme] = useState<\"light\" | \"dark\">(\"light\");\n\n  useEffect(() => {\n    const savedTheme = localStorage.getItem(\"theme\") as \"light\" | \"dark\" | null;\n    const prefersDark = window.matchMedia(\"(prefers-color-scheme: dark)\").matches;\n    const initialTheme = savedTheme || (prefersDark ? \"dark\" : \"light\");\n    \n    setTheme(initialTheme);\n    document.documentElement.classList.toggle(\"dark\", initialTheme === \"dark\");\n  }, []);\n\n  const toggleTheme = () => {\n    const newTheme = theme === \"light\" ? \"dark\" : \"light\";\n    setTheme(newTheme);\n    localStorage.setItem(\"theme\", newTheme);\n    document.documentElement.classList.toggle(\"dark\", newTheme === \"dark\");\n  };\n\n  return (\n    <Button\n      variant=\"ghost\"\n      size=\"icon\"\n      onClick={toggleTheme}\n      data-testid=\"button-theme-toggle\"\n    >\n      {theme === \"light\" ? (\n        <Moon className=\"h-4 w-4\" />\n      ) : (\n        <Sun className=\"h-4 w-4\" />\n      )}\n    </Button>\n  );\n}\n","size_bytes":1137},"client/src/components/ui/label.tsx":{"content":"import * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst labelVariants = cva(\n  \"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\"\n)\n\nconst Label = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &\n    VariantProps<typeof labelVariants>\n>(({ className, ...props }, ref) => (\n  <LabelPrimitive.Root\n    ref={ref}\n    className={cn(labelVariants(), className)}\n    {...props}\n  />\n))\nLabel.displayName = LabelPrimitive.Root.displayName\n\nexport { Label }\n","size_bytes":710},"client/src/components/ui/scroll-area.tsx":{"content":"import * as React from \"react\"\nimport * as ScrollAreaPrimitive from \"@radix-ui/react-scroll-area\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ScrollArea = React.forwardRef<\n  React.ElementRef<typeof ScrollAreaPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>\n>(({ className, children, ...props }, ref) => (\n  <ScrollAreaPrimitive.Root\n    ref={ref}\n    className={cn(\"relative overflow-hidden\", className)}\n    {...props}\n  >\n    <ScrollAreaPrimitive.Viewport className=\"h-full w-full rounded-[inherit]\">\n      {children}\n    </ScrollAreaPrimitive.Viewport>\n    <ScrollBar />\n    <ScrollAreaPrimitive.Corner />\n  </ScrollAreaPrimitive.Root>\n))\nScrollArea.displayName = ScrollAreaPrimitive.Root.displayName\n\nconst ScrollBar = React.forwardRef<\n  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,\n  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>\n>(({ className, orientation = \"vertical\", ...props }, ref) => (\n  <ScrollAreaPrimitive.ScrollAreaScrollbar\n    ref={ref}\n    orientation={orientation}\n    className={cn(\n      \"flex touch-none select-none transition-colors\",\n      orientation === \"vertical\" &&\n        \"h-full w-2.5 border-l border-l-transparent p-[1px]\",\n      orientation === \"horizontal\" &&\n        \"h-2.5 flex-col border-t border-t-transparent p-[1px]\",\n      className\n    )}\n    {...props}\n  >\n    <ScrollAreaPrimitive.ScrollAreaThumb className=\"relative flex-1 rounded-full bg-border\" />\n  </ScrollAreaPrimitive.ScrollAreaScrollbar>\n))\nScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName\n\nexport { ScrollArea, ScrollBar }\n","size_bytes":1642},"tailwind.config.ts":{"content":"import type { Config } from \"tailwindcss\";\n\nexport default {\n  darkMode: [\"class\"],\n  content: [\"./client/index.html\", \"./client/src/**/*.{js,jsx,ts,tsx}\"],\n  theme: {\n    extend: {\n      borderRadius: {\n        lg: \".5625rem\", /* 9px */\n        md: \".375rem\", /* 6px */\n        sm: \".1875rem\", /* 3px */\n      },\n      colors: {\n        // Flat / base colors (regular buttons)\n        background: \"hsl(var(--background) / <alpha-value>)\",\n        foreground: \"hsl(var(--foreground) / <alpha-value>)\",\n        border: \"hsl(var(--border) / <alpha-value>)\",\n        input: \"hsl(var(--input) / <alpha-value>)\",\n        card: {\n          DEFAULT: \"hsl(var(--card) / <alpha-value>)\",\n          foreground: \"hsl(var(--card-foreground) / <alpha-value>)\",\n          border: \"hsl(var(--card-border) / <alpha-value>)\",\n        },\n        popover: {\n          DEFAULT: \"hsl(var(--popover) / <alpha-value>)\",\n          foreground: \"hsl(var(--popover-foreground) / <alpha-value>)\",\n          border: \"hsl(var(--popover-border) / <alpha-value>)\",\n        },\n        primary: {\n          DEFAULT: \"hsl(var(--primary) / <alpha-value>)\",\n          foreground: \"hsl(var(--primary-foreground) / <alpha-value>)\",\n          border: \"var(--primary-border)\",\n        },\n        secondary: {\n          DEFAULT: \"hsl(var(--secondary) / <alpha-value>)\",\n          foreground: \"hsl(var(--secondary-foreground) / <alpha-value>)\",\n          border: \"var(--secondary-border)\",\n        },\n        muted: {\n          DEFAULT: \"hsl(var(--muted) / <alpha-value>)\",\n          foreground: \"hsl(var(--muted-foreground) / <alpha-value>)\",\n          border: \"var(--muted-border)\",\n        },\n        accent: {\n          DEFAULT: \"hsl(var(--accent) / <alpha-value>)\",\n          foreground: \"hsl(var(--accent-foreground) / <alpha-value>)\",\n          border: \"var(--accent-border)\",\n        },\n        destructive: {\n          DEFAULT: \"hsl(var(--destructive) / <alpha-value>)\",\n          foreground: \"hsl(var(--destructive-foreground) / <alpha-value>)\",\n          border: \"var(--destructive-border)\",\n        },\n        ring: \"hsl(var(--ring) / <alpha-value>)\",\n        chart: {\n          \"1\": \"hsl(var(--chart-1) / <alpha-value>)\",\n          \"2\": \"hsl(var(--chart-2) / <alpha-value>)\",\n          \"3\": \"hsl(var(--chart-3) / <alpha-value>)\",\n          \"4\": \"hsl(var(--chart-4) / <alpha-value>)\",\n          \"5\": \"hsl(var(--chart-5) / <alpha-value>)\",\n        },\n        sidebar: {\n          ring: \"hsl(var(--sidebar-ring) / <alpha-value>)\",\n          DEFAULT: \"hsl(var(--sidebar) / <alpha-value>)\",\n          foreground: \"hsl(var(--sidebar-foreground) / <alpha-value>)\",\n          border: \"hsl(var(--sidebar-border) / <alpha-value>)\",\n        },\n        \"sidebar-primary\": {\n          DEFAULT: \"hsl(var(--sidebar-primary) / <alpha-value>)\",\n          foreground: \"hsl(var(--sidebar-primary-foreground) / <alpha-value>)\",\n          border: \"var(--sidebar-primary-border)\",\n        },\n        \"sidebar-accent\": {\n          DEFAULT: \"hsl(var(--sidebar-accent) / <alpha-value>)\",\n          foreground: \"hsl(var(--sidebar-accent-foreground) / <alpha-value>)\",\n          border: \"var(--sidebar-accent-border)\"\n        },\n        status: {\n          online: \"rgb(34 197 94)\",\n          away: \"rgb(245 158 11)\",\n          busy: \"rgb(239 68 68)\",\n          offline: \"rgb(156 163 175)\",\n        },\n      },\n      fontFamily: {\n        sans: [\"var(--font-sans)\"],\n        serif: [\"var(--font-serif)\"],\n        mono: [\"var(--font-mono)\"],\n      },\n      keyframes: {\n        \"accordion-down\": {\n          from: { height: \"0\" },\n          to: { height: \"var(--radix-accordion-content-height)\" },\n        },\n        \"accordion-up\": {\n          from: { height: \"var(--radix-accordion-content-height)\" },\n          to: { height: \"0\" },\n        },\n      },\n      animation: {\n        \"accordion-down\": \"accordion-down 0.2s ease-out\",\n        \"accordion-up\": \"accordion-up 0.2s ease-out\",\n      },\n    },\n  },\n  plugins: [require(\"tailwindcss-animate\"), require(\"@tailwindcss/typography\")],\n} satisfies Config;\n","size_bytes":4050},"client/src/components/execution-log-panel.tsx":{"content":"import { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Lock, Unlock } from \"lucide-react\";\nimport { useState, useEffect, useRef } from \"react\";\n\ntype LogLevel = \"info\" | \"warn\" | \"error\" | \"success\";\n\ninterface LogEntry {\n  id: string;\n  timestamp: string;\n  level: LogLevel;\n  message: string;\n}\n\ninterface ExecutionLogPanelProps {\n  logs: LogEntry[];\n  title?: string;\n}\n\nconst levelStyles = {\n  info: \"text-foreground\",\n  warn: \"text-chart-3\",\n  error: \"text-destructive\",\n  success: \"text-chart-2\",\n};\n\nexport function ExecutionLogPanel({ logs, title = \"Execution Log\" }: ExecutionLogPanelProps) {\n  const [autoScroll, setAutoScroll] = useState(true);\n  const scrollRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    if (autoScroll && scrollRef.current) {\n      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;\n    }\n  }, [logs, autoScroll]);\n\n  return (\n    <Card className=\"flex flex-col h-full\" data-testid=\"card-execution-log\">\n      <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-3\">\n        <CardTitle className=\"text-lg font-medium\">{title}</CardTitle>\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={() => setAutoScroll(!autoScroll)}\n          data-testid=\"button-toggle-autoscroll\"\n        >\n          {autoScroll ? (\n            <>\n              <Lock className=\"h-3 w-3 mr-1\" />\n              Auto-scroll\n            </>\n          ) : (\n            <>\n              <Unlock className=\"h-3 w-3 mr-1\" />\n              Scroll unlocked\n            </>\n          )}\n        </Button>\n      </CardHeader>\n      \n      <CardContent className=\"flex-1 overflow-hidden p-0\">\n        <div\n          ref={scrollRef}\n          className=\"h-full overflow-y-auto font-mono text-xs leading-relaxed\"\n          data-testid=\"text-log-content\"\n        >\n          {logs.map((log, index) => (\n            <div\n              key={log.id}\n              className=\"flex gap-3 px-6 py-1 hover-elevate\"\n              data-testid={`log-entry-${index}`}\n            >\n              <span className=\"text-muted-foreground w-12 flex-shrink-0 text-right\">\n                {index + 1}\n              </span>\n              <span className=\"text-muted-foreground w-20 flex-shrink-0\">\n                {log.timestamp}\n              </span>\n              <span className={`flex-1 ${levelStyles[log.level]}`}>\n                {log.message}\n              </span>\n            </div>\n          ))}\n        </div>\n      </CardContent>\n    </Card>\n  );\n}\n","size_bytes":2598},"client/src/components/ui/switch.tsx":{"content":"import * as React from \"react\"\nimport * as SwitchPrimitives from \"@radix-ui/react-switch\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Switch = React.forwardRef<\n  React.ElementRef<typeof SwitchPrimitives.Root>,\n  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>\n>(({ className, ...props }, ref) => (\n  <SwitchPrimitives.Root\n    className={cn(\n      \"peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  >\n    <SwitchPrimitives.Thumb\n      className={cn(\n        \"pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0\"\n      )}\n    />\n  </SwitchPrimitives.Root>\n))\nSwitch.displayName = SwitchPrimitives.Root.displayName\n\nexport { Switch }\n","size_bytes":1139},"client/src/components/event-log-table.tsx":{"content":"import { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { GitPullRequest, GitCommit, MessageSquare, AlertCircle } from \"lucide-react\";\n\ntype EventType = \"pull_request\" | \"push\" | \"issue\" | \"comment\";\n\ninterface EventLog {\n  id: string;\n  timestamp: string;\n  type: EventType;\n  repository: string;\n  action: string;\n  status: \"success\" | \"pending\" | \"failed\";\n}\n\ninterface EventLogTableProps {\n  events: EventLog[];\n}\n\nconst eventIcons = {\n  pull_request: GitPullRequest,\n  push: GitCommit,\n  issue: AlertCircle,\n  comment: MessageSquare,\n};\n\nconst statusVariants = {\n  success: \"secondary\" as const,\n  pending: \"outline\" as const,\n  failed: \"destructive\" as const,\n};\n\nexport function EventLogTable({ events }: EventLogTableProps) {\n  return (\n    <Card data-testid=\"card-event-log\">\n      <CardHeader>\n        <CardTitle className=\"text-lg font-medium\">Recent Events</CardTitle>\n      </CardHeader>\n      <CardContent className=\"p-0\">\n        <div className=\"overflow-x-auto\">\n          <table className=\"w-full\">\n            <thead className=\"border-b border-border bg-muted/30\">\n              <tr>\n                <th className=\"text-left text-xs font-medium text-muted-foreground p-3\">\n                  Time\n                </th>\n                <th className=\"text-left text-xs font-medium text-muted-foreground p-3\">\n                  Type\n                </th>\n                <th className=\"text-left text-xs font-medium text-muted-foreground p-3\">\n                  Repository\n                </th>\n                <th className=\"text-left text-xs font-medium text-muted-foreground p-3\">\n                  Action\n                </th>\n                <th className=\"text-left text-xs font-medium text-muted-foreground p-3\">\n                  Status\n                </th>\n              </tr>\n            </thead>\n            <tbody>\n              {events.map((event, index) => {\n                const Icon = eventIcons[event.type];\n                return (\n                  <tr\n                    key={event.id}\n                    className=\"border-b border-border hover-elevate\"\n                    data-testid={`event-row-${index}`}\n                  >\n                    <td className=\"p-3 text-xs text-muted-foreground\">\n                      {event.timestamp}\n                    </td>\n                    <td className=\"p-3\">\n                      <div className=\"flex items-center gap-2\">\n                        <Icon className=\"h-3 w-3 text-muted-foreground\" />\n                        <span className=\"text-sm capitalize\">{event.type.replace('_', ' ')}</span>\n                      </div>\n                    </td>\n                    <td className=\"p-3 text-sm font-mono\">{event.repository}</td>\n                    <td className=\"p-3 text-sm\">{event.action}</td>\n                    <td className=\"p-3\">\n                      <Badge variant={statusVariants[event.status]} className=\"capitalize\">\n                        {event.status}\n                      </Badge>\n                    </td>\n                  </tr>\n                );\n              })}\n            </tbody>\n          </table>\n        </div>\n      </CardContent>\n    </Card>\n  );\n}\n","size_bytes":3253},"client/src/components/examples/EventLogTable.tsx":{"content":"import { EventLogTable } from '../event-log-table';\n\nconst mockEvents = [\n  {\n    id: \"evt-1\",\n    timestamp: \"2m ago\",\n    type: \"pull_request\" as const,\n    repository: \"acme/web-app\",\n    action: \"opened #234\",\n    status: \"success\" as const,\n  },\n  {\n    id: \"evt-2\",\n    timestamp: \"5m ago\",\n    type: \"push\" as const,\n    repository: \"acme/api-server\",\n    action: \"feature/auth-v2\",\n    status: \"pending\" as const,\n  },\n  {\n    id: \"evt-3\",\n    timestamp: \"8m ago\",\n    type: \"issue\" as const,\n    repository: \"acme/web-app\",\n    action: \"created #89\",\n    status: \"failed\" as const,\n  },\n];\n\nexport default function EventLogTableExample() {\n  return <EventLogTable events={mockEvents} />;\n}\n","size_bytes":699},"client/src/components/examples/TaskCard.tsx":{"content":"import { TaskCard } from '../task-card';\n\nexport default function TaskCardExample() {\n  return (\n    <TaskCard\n      id=\"task-1\"\n      title=\"Refactor authentication middleware\"\n      status=\"executing\"\n      timestamp=\"2m ago\"\n      summary=\"Analyzing current auth flow, identifying security improvements, and planning modular refactoring approach\"\n      progress={65}\n      repository=\"acme/web-app\"\n    />\n  );\n}\n","size_bytes":416},"client/src/components/ui/textarea.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Textarea = React.forwardRef<\n  HTMLTextAreaElement,\n  React.ComponentProps<\"textarea\">\n>(({ className, ...props }, ref) => {\n  return (\n    <textarea\n      className={cn(\n        \"flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n        className\n      )}\n      ref={ref}\n      {...props}\n    />\n  )\n})\nTextarea.displayName = \"Textarea\"\n\nexport { Textarea }\n","size_bytes":689},"client/src/components/ui/form.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport {\n  Controller,\n  FormProvider,\n  useFormContext,\n  type ControllerProps,\n  type FieldPath,\n  type FieldValues,\n} from \"react-hook-form\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Label } from \"@/components/ui/label\"\n\nconst Form = FormProvider\n\ntype FormFieldContextValue<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n> = {\n  name: TName\n}\n\nconst FormFieldContext = React.createContext<FormFieldContextValue>(\n  {} as FormFieldContextValue\n)\n\nconst FormField = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n>({\n  ...props\n}: ControllerProps<TFieldValues, TName>) => {\n  return (\n    <FormFieldContext.Provider value={{ name: props.name }}>\n      <Controller {...props} />\n    </FormFieldContext.Provider>\n  )\n}\n\nconst useFormField = () => {\n  const fieldContext = React.useContext(FormFieldContext)\n  const itemContext = React.useContext(FormItemContext)\n  const { getFieldState, formState } = useFormContext()\n\n  const fieldState = getFieldState(fieldContext.name, formState)\n\n  if (!fieldContext) {\n    throw new Error(\"useFormField should be used within <FormField>\")\n  }\n\n  const { id } = itemContext\n\n  return {\n    id,\n    name: fieldContext.name,\n    formItemId: `${id}-form-item`,\n    formDescriptionId: `${id}-form-item-description`,\n    formMessageId: `${id}-form-item-message`,\n    ...fieldState,\n  }\n}\n\ntype FormItemContextValue = {\n  id: string\n}\n\nconst FormItemContext = React.createContext<FormItemContextValue>(\n  {} as FormItemContextValue\n)\n\nconst FormItem = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const id = React.useId()\n\n  return (\n    <FormItemContext.Provider value={{ id }}>\n      <div ref={ref} className={cn(\"space-y-2\", className)} {...props} />\n    </FormItemContext.Provider>\n  )\n})\nFormItem.displayName = \"FormItem\"\n\nconst FormLabel = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>\n>(({ className, ...props }, ref) => {\n  const { error, formItemId } = useFormField()\n\n  return (\n    <Label\n      ref={ref}\n      className={cn(error && \"text-destructive\", className)}\n      htmlFor={formItemId}\n      {...props}\n    />\n  )\n})\nFormLabel.displayName = \"FormLabel\"\n\nconst FormControl = React.forwardRef<\n  React.ElementRef<typeof Slot>,\n  React.ComponentPropsWithoutRef<typeof Slot>\n>(({ ...props }, ref) => {\n  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()\n\n  return (\n    <Slot\n      ref={ref}\n      id={formItemId}\n      aria-describedby={\n        !error\n          ? `${formDescriptionId}`\n          : `${formDescriptionId} ${formMessageId}`\n      }\n      aria-invalid={!!error}\n      {...props}\n    />\n  )\n})\nFormControl.displayName = \"FormControl\"\n\nconst FormDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => {\n  const { formDescriptionId } = useFormField()\n\n  return (\n    <p\n      ref={ref}\n      id={formDescriptionId}\n      className={cn(\"text-sm text-muted-foreground\", className)}\n      {...props}\n    />\n  )\n})\nFormDescription.displayName = \"FormDescription\"\n\nconst FormMessage = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, children, ...props }, ref) => {\n  const { error, formMessageId } = useFormField()\n  const body = error ? String(error?.message ?? \"\") : children\n\n  if (!body) {\n    return null\n  }\n\n  return (\n    <p\n      ref={ref}\n      id={formMessageId}\n      className={cn(\"text-sm font-medium text-destructive\", className)}\n      {...props}\n    >\n      {body}\n    </p>\n  )\n})\nFormMessage.displayName = \"FormMessage\"\n\nexport {\n  useFormField,\n  Form,\n  FormItem,\n  FormLabel,\n  FormControl,\n  FormDescription,\n  FormMessage,\n  FormField,\n}\n","size_bytes":4120},"client/src/components/ai-reasoning-chain.tsx":{"content":"import { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { CheckCircle, Circle } from \"lucide-react\";\n\ninterface ReasoningStep {\n  id: string;\n  timestamp: string;\n  description: string;\n  confidence?: number;\n  completed: boolean;\n}\n\ninterface AIReasoningChainProps {\n  steps: ReasoningStep[];\n}\n\nexport function AIReasoningChain({ steps }: AIReasoningChainProps) {\n  return (\n    <Card data-testid=\"card-ai-reasoning\">\n      <CardHeader>\n        <CardTitle className=\"text-lg font-medium\">AI Reasoning Chain</CardTitle>\n      </CardHeader>\n      <CardContent>\n        <div className=\"space-y-4\">\n          {steps.map((step, index) => (\n            <div key={step.id} className=\"flex gap-3\" data-testid={`reasoning-step-${index}`}>\n              <div className=\"flex flex-col items-center\">\n                <div className=\"flex h-8 w-8 items-center justify-center rounded-full border-2 border-border bg-background\">\n                  {step.completed ? (\n                    <CheckCircle className=\"h-4 w-4 text-chart-2\" />\n                  ) : (\n                    <Circle className=\"h-4 w-4 text-muted-foreground\" />\n                  )}\n                </div>\n                {index < steps.length - 1 && (\n                  <div className=\"w-0.5 h-full bg-border mt-1\" />\n                )}\n              </div>\n              \n              <div className=\"flex-1 pb-4\">\n                <div className=\"flex items-center gap-2 mb-1\">\n                  <span className=\"text-xs text-muted-foreground\">{step.timestamp}</span>\n                  {step.confidence && (\n                    <Badge variant=\"secondary\" className=\"text-xs\">\n                      {step.confidence}% confidence\n                    </Badge>\n                  )}\n                </div>\n                <p className=\"text-sm text-foreground\">{step.description}</p>\n              </div>\n            </div>\n          ))}\n        </div>\n      </CardContent>\n    </Card>\n  );\n}\n","size_bytes":2028},"client/src/pages/not-found.tsx":{"content":"import { Card, CardContent } from \"@/components/ui/card\";\nimport { AlertCircle } from \"lucide-react\";\n\nexport default function NotFound() {\n  return (\n    <div className=\"min-h-screen w-full flex items-center justify-center bg-gray-50\">\n      <Card className=\"w-full max-w-md mx-4\">\n        <CardContent className=\"pt-6\">\n          <div className=\"flex mb-4 gap-2\">\n            <AlertCircle className=\"h-8 w-8 text-red-500\" />\n            <h1 className=\"text-2xl font-bold text-gray-900\">404 Page Not Found</h1>\n          </div>\n\n          <p className=\"mt-4 text-sm text-gray-600\">\n            Did you forget to add the page to the router?\n          </p>\n        </CardContent>\n      </Card>\n    </div>\n  );\n}\n","size_bytes":711},"client/src/components/diff-viewer.tsx":{"content":"import { Card, CardContent, CardHeader } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { File } from \"lucide-react\";\n\ninterface DiffLine {\n  lineNumber: number;\n  type: \"add\" | \"remove\" | \"context\";\n  content: string;\n}\n\ninterface FileDiff {\n  path: string;\n  lines: DiffLine[];\n}\n\ninterface DiffViewerProps {\n  files: FileDiff[];\n}\n\nexport function DiffViewer({ files }: DiffViewerProps) {\n  return (\n    <Card data-testid=\"card-diff-viewer\">\n      <CardHeader className=\"pb-3\">\n        <div className=\"flex items-center justify-between\">\n          <div className=\"flex items-center gap-2\">\n            <File className=\"h-4 w-4 text-muted-foreground\" />\n            <h3 className=\"text-lg font-medium\">Code Changes</h3>\n          </div>\n          <div className=\"flex gap-2\">\n            <Button variant=\"outline\" size=\"sm\" data-testid=\"button-approve-changes\">\n              Approve\n            </Button>\n            <Button variant=\"ghost\" size=\"sm\" data-testid=\"button-request-changes\">\n              Request Changes\n            </Button>\n          </div>\n        </div>\n      </CardHeader>\n      \n      <CardContent className=\"p-0\">\n        <Tabs defaultValue=\"0\" className=\"w-full\">\n          <div className=\"border-b border-border px-6\">\n            <TabsList className=\"h-auto p-0 bg-transparent\">\n              {files.map((file, index) => (\n                <TabsTrigger\n                  key={index}\n                  value={index.toString()}\n                  className=\"rounded-none border-b-2 border-transparent data-[state=active]:border-primary data-[state=active]:bg-transparent\"\n                  data-testid={`tab-file-${index}`}\n                >\n                  <span className=\"text-xs font-mono\">{file.path}</span>\n                  <Badge variant=\"secondary\" className=\"ml-2 text-xs\">\n                    {file.lines.filter(l => l.type !== 'context').length}\n                  </Badge>\n                </TabsTrigger>\n              ))}\n            </TabsList>\n          </div>\n\n          {files.map((file, fileIndex) => (\n            <TabsContent key={fileIndex} value={fileIndex.toString()} className=\"m-0\">\n              <div className=\"font-mono text-xs\" data-testid={`diff-content-${fileIndex}`}>\n                {file.lines.map((line, lineIndex) => (\n                  <div\n                    key={lineIndex}\n                    className={`flex ${\n                      line.type === \"add\"\n                        ? \"bg-chart-2/10\"\n                        : line.type === \"remove\"\n                        ? \"bg-destructive/10\"\n                        : \"\"\n                    }`}\n                    data-testid={`diff-line-${lineIndex}`}\n                  >\n                    <span className=\"text-muted-foreground w-12 flex-shrink-0 text-right px-3 py-1 select-none\">\n                      {line.lineNumber}\n                    </span>\n                    <span\n                      className={`w-4 flex-shrink-0 text-center ${\n                        line.type === \"add\"\n                          ? \"text-chart-2\"\n                          : line.type === \"remove\"\n                          ? \"text-destructive\"\n                          : \"text-muted-foreground\"\n                      }`}\n                    >\n                      {line.type === \"add\" ? \"+\" : line.type === \"remove\" ? \"-\" : \" \"}\n                    </span>\n                    <span className=\"flex-1 px-3 py-1\">{line.content}</span>\n                  </div>\n                ))}\n              </div>\n            </TabsContent>\n          ))}\n        </Tabs>\n      </CardContent>\n    </Card>\n  );\n}\n","size_bytes":3770},"client/src/components/examples/MetricsCard.tsx":{"content":"import { MetricsCard } from '../metrics-card';\nimport { Activity } from 'lucide-react';\n\nexport default function MetricsCardExample() {\n  return <MetricsCard title=\"Active Tasks\" value=\"3\" icon={Activity} trend=\"+2 from last hour\" />;\n}\n","size_bytes":237},"client/src/components/ui/badge.tsx":{"content":"import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst badgeVariants = cva(\n  // Whitespace-nowrap: Badges should never wrap.\n  \"whitespace-nowrap inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\" +\n  \" hover-elevate \" ,\n  {\n    variants: {\n      variant: {\n        default:\n          \"border-transparent bg-primary text-primary-foreground shadow-xs\",\n        secondary: \"border-transparent bg-secondary text-secondary-foreground\",\n        destructive:\n          \"border-transparent bg-destructive text-destructive-foreground shadow-xs\",\n\n        outline: \" border [border-color:var(--badge-outline)] shadow-xs\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  },\n)\n\nexport interface BadgeProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof badgeVariants> {}\n\nfunction Badge({ className, variant, ...props }: BadgeProps) {\n  return (\n    <div className={cn(badgeVariants({ variant }), className)} {...props} />\n  );\n}\n\nexport { Badge, badgeVariants }\n","size_bytes":1202},"client/src/main.tsx":{"content":"import { createRoot } from \"react-dom/client\";\nimport App from \"./App\";\nimport \"./index.css\";\n\ncreateRoot(document.getElementById(\"root\")!).render(<App />);\n","size_bytes":157},"shared/schema.ts":{"content":"import { z } from \"zod\";\n\n// Task status types\nexport const taskStatusSchema = z.enum([\"planning\", \"executing\", \"completed\", \"failed\", \"queued\"]);\nexport type TaskStatus = z.infer<typeof taskStatusSchema>;\n\n// AI Reasoning Step\nexport const reasoningStepSchema = z.object({\n  id: z.string(),\n  timestamp: z.string(),\n  description: z.string(),\n  confidence: z.number().min(0).max(100).optional(),\n  completed: z.boolean(),\n});\n\nexport type ReasoningStep = z.infer<typeof reasoningStepSchema>;\n\n// Execution Log Entry\nexport const logLevelSchema = z.enum([\"info\", \"warn\", \"error\", \"success\"]);\n\nexport const logEntrySchema = z.object({\n  id: z.string(),\n  timestamp: z.string(),\n  level: logLevelSchema,\n  message: z.string(),\n});\n\nexport type LogEntry = z.infer<typeof logEntrySchema>;\n\n// Code Diff\nexport const diffLineSchema = z.object({\n  lineNumber: z.number(),\n  type: z.enum([\"add\", \"remove\", \"context\"]),\n  content: z.string(),\n});\n\nexport const fileDiffSchema = z.object({\n  path: z.string(),\n  lines: z.array(diffLineSchema),\n});\n\nexport type DiffLine = z.infer<typeof diffLineSchema>;\nexport type FileDiff = z.infer<typeof fileDiffSchema>;\n\n// Task\nexport const taskSchema = z.object({\n  id: z.string(),\n  title: z.string(),\n  status: taskStatusSchema,\n  repository: z.string(),\n  branch: z.string().optional(),\n  summary: z.string(),\n  createdAt: z.string(),\n  updatedAt: z.string(),\n  progress: z.number().min(0).max(100).default(0),\n  logs: z.array(logEntrySchema).default([]),\n  reasoning: z.array(reasoningStepSchema).default([]),\n  diffs: z.array(fileDiffSchema).default([]),\n  eventId: z.string().optional(),\n});\n\nexport const insertTaskSchema = taskSchema.omit({\n  id: true,\n  createdAt: true,\n  updatedAt: true,\n  logs: true,\n  reasoning: true,\n  diffs: true,\n});\n\nexport type Task = z.infer<typeof taskSchema>;\nexport type InsertTask = z.infer<typeof insertTaskSchema>;\n\n// GitHub Event\nexport const eventTypeSchema = z.enum([\"pull_request\", \"push\", \"issue\", \"comment\"]);\nexport const eventStatusSchema = z.enum([\"success\", \"pending\", \"failed\"]);\n\nexport const githubEventSchema = z.object({\n  id: z.string(),\n  timestamp: z.string(),\n  type: eventTypeSchema,\n  repository: z.string(),\n  action: z.string(),\n  status: eventStatusSchema,\n  payload: z.record(z.any()).optional(),\n  taskId: z.string().optional(),\n});\n\nexport const insertGithubEventSchema = githubEventSchema.omit({\n  id: true,\n  timestamp: true,\n});\n\nexport type GithubEvent = z.infer<typeof githubEventSchema>;\nexport type InsertGithubEvent = z.infer<typeof insertGithubEventSchema>;\n\n// AI Provider Types\nexport const providerTypeSchema = z.enum([\"openai\", \"anthropic\", \"azure-openai\"]);\nexport type ProviderType = z.infer<typeof providerTypeSchema>;\n\n// Provider Configuration\nexport const providerConfigSchema = z.object({\n  name: z.string(),\n  type: providerTypeSchema,\n  apiKey: z.string(),\n  endpoint: z.string().url().optional(),\n  model: z.string(),\n  maxTokens: z.number().default(128000),\n  temperature: z.number().min(0).max(2).default(0.7),\n  enabled: z.boolean().default(true),\n  priority: z.number().default(1),\n  contextWindow: z.number().default(128000),\n  costPer1kTokens: z.object({\n    input: z.number().default(0.01),\n    output: z.number().default(0.03),\n  }).optional(),\n  azureDeploymentName: z.string().optional(),\n  azureApiVersion: z.string().optional(),\n});\n\nexport type ProviderConfig = z.infer<typeof providerConfigSchema>;\n\n// Routing Configuration\nexport const routingConfigSchema = z.object({\n  taskComplexityThreshold: z.number().min(0).max(1).default(0.7),\n  contextSizeThreshold: z.number().default(90000),\n  rateLimitThreshold: z.number().min(0).max(1).default(0.2),\n  enableFallback: z.boolean().default(true),\n  userPreference: z.string().optional(),\n});\n\nexport type RoutingConfig = z.infer<typeof routingConfigSchema>;\n\n// Provider Metrics\nexport const providerMetricsSchema = z.object({\n  providerName: z.string(),\n  totalRequests: z.number().default(0),\n  successfulRequests: z.number().default(0),\n  failedRequests: z.number().default(0),\n  totalTokensUsed: z.number().default(0),\n  totalInputTokens: z.number().default(0),\n  totalOutputTokens: z.number().default(0),\n  averageResponseTime: z.number().default(0),\n  totalCost: z.number().default(0),\n  lastUsed: z.string().optional(),\n  rateLimitRemaining: z.number().optional(),\n  rateLimitReset: z.string().optional(),\n  errorCounts: z.record(z.number()).default({}),\n});\n\nexport type ProviderMetrics = z.infer<typeof providerMetricsSchema>;\n\n// Settings\nexport const aiSettingsSchema = z.object({\n  apiEndpoint: z.string().url(),\n  apiKey: z.string(),\n  model: z.string(),\n  maxTokens: z.number().default(4096),\n  temperature: z.number().min(0).max(2).default(0.7),\n  providers: z.array(providerConfigSchema).optional(),\n  routing: routingConfigSchema.optional(),\n});\n\nexport const githubSettingsSchema = z.object({\n  token: z.string(),\n  webhookSecret: z.string().optional(),\n});\n\nexport const settingsSchema = z.object({\n  ai: aiSettingsSchema,\n  github: githubSettingsSchema,\n  autoApprove: z.boolean().default(false),\n});\n\nexport type AISettings = z.infer<typeof aiSettingsSchema>;\nexport type GithubSettings = z.infer<typeof githubSettingsSchema>;\nexport type Settings = z.infer<typeof settingsSchema>;\n\n// Repository Context\nexport const repositoryContextSchema = z.object({\n  id: z.string(),\n  repository: z.string(),\n  architecture: z.record(z.any()).optional(),\n  dependencies: z.record(z.any()).optional(),\n  fileStructure: z.array(z.string()).optional(),\n  branches: z.array(z.record(z.any())).optional(),\n  recentCommits: z.array(z.record(z.any())).optional(),\n  openIssues: z.array(z.record(z.any())).optional(),\n  semanticSummary: z.string().optional(),\n  createdAt: z.string(),\n  updatedAt: z.string(),\n});\n\nexport const insertRepositoryContextSchema = repositoryContextSchema.omit({\n  id: true,\n  createdAt: true,\n  updatedAt: true,\n});\n\nexport type RepositoryContext = z.infer<typeof repositoryContextSchema>;\nexport type InsertRepositoryContext = z.infer<typeof insertRepositoryContextSchema>;\n\n// WebSocket Message Types\nexport const wsMessageTypeSchema = z.enum([\n  \"task_update\",\n  \"log_added\",\n  \"reasoning_added\",\n  \"diff_created\",\n  \"runner_status\",\n  \"ping\",\n  \"pong\",\n]);\n\nexport type WSMessageType = z.infer<typeof wsMessageTypeSchema>;\n\nexport const wsTaskUpdateSchema = z.object({\n  type: z.literal(\"task_update\"),\n  taskId: z.string(),\n  status: taskStatusSchema.optional(),\n  progress: z.number().min(0).max(100).optional(),\n  updates: z.record(z.any()).optional(),\n});\n\nexport const wsLogAddedSchema = z.object({\n  type: z.literal(\"log_added\"),\n  taskId: z.string(),\n  log: logEntrySchema,\n});\n\nexport const wsReasoningAddedSchema = z.object({\n  type: z.literal(\"reasoning_added\"),\n  taskId: z.string(),\n  step: reasoningStepSchema,\n});\n\nexport const wsDiffCreatedSchema = z.object({\n  type: z.literal(\"diff_created\"),\n  taskId: z.string(),\n  diff: fileDiffSchema,\n});\n\nexport const wsRunnerStatusSchema = z.object({\n  type: z.literal(\"runner_status\"),\n  taskId: z.string(),\n  runnerId: z.string(),\n  status: z.string(),\n  metadata: z.record(z.any()).optional(),\n});\n\nexport const wsPingPongSchema = z.object({\n  type: z.enum([\"ping\", \"pong\"]),\n  timestamp: z.number(),\n});\n\nexport const wsMessageSchema = z.union([\n  wsTaskUpdateSchema,\n  wsLogAddedSchema,\n  wsReasoningAddedSchema,\n  wsDiffCreatedSchema,\n  wsRunnerStatusSchema,\n  wsPingPongSchema,\n]);\n\nexport type WSTaskUpdate = z.infer<typeof wsTaskUpdateSchema>;\nexport type WSLogAdded = z.infer<typeof wsLogAddedSchema>;\nexport type WSReasoningAdded = z.infer<typeof wsReasoningAddedSchema>;\nexport type WSDiffCreated = z.infer<typeof wsDiffCreatedSchema>;\nexport type WSRunnerStatus = z.infer<typeof wsRunnerStatusSchema>;\nexport type WSPingPong = z.infer<typeof wsPingPongSchema>;\nexport type WSMessage = z.infer<typeof wsMessageSchema>;\n\n// MCP (Model Context Protocol) Types\nexport const mcpServerTypeSchema = z.enum([\"github\", \"playwright\", \"custom\"]);\nexport type MCPServerType = z.infer<typeof mcpServerTypeSchema>;\n\nexport const mcpConnectionStatusSchema = z.enum([\"connected\", \"disconnected\", \"error\", \"initializing\"]);\nexport type MCPConnectionStatus = z.infer<typeof mcpConnectionStatusSchema>;\n\n// MCP Tool Definition\nexport const mcpToolSchema = z.object({\n  name: z.string(),\n  description: z.string(),\n  inputSchema: z.record(z.any()),\n});\n\nexport type MCPTool = z.infer<typeof mcpToolSchema>;\n\n// MCP Resource Definition\nexport const mcpResourceSchema = z.object({\n  uri: z.string(),\n  name: z.string(),\n  mimeType: z.string().optional(),\n  description: z.string().optional(),\n});\n\nexport type MCPResource = z.infer<typeof mcpResourceSchema>;\n\n// MCP Prompt Template\nexport const mcpPromptTemplateSchema = z.object({\n  name: z.string(),\n  description: z.string().optional(),\n  arguments: z.array(z.object({\n    name: z.string(),\n    description: z.string().optional(),\n    required: z.boolean().default(false),\n  })).optional(),\n});\n\nexport type MCPPromptTemplate = z.infer<typeof mcpPromptTemplateSchema>;\n\n// MCP Server Configuration\nexport const mcpServerConfigSchema = z.object({\n  name: z.string(),\n  type: mcpServerTypeSchema,\n  command: z.string().optional(),\n  args: z.array(z.string()).optional(),\n  env: z.record(z.string()).optional(),\n  endpoint: z.string().url().optional(),\n  apiKey: z.string().optional(),\n  config: z.record(z.any()).optional(),\n});\n\nexport type MCPServerConfig = z.infer<typeof mcpServerConfigSchema>;\n\n// MCP Connection (Database entity)\nexport const mcpConnectionSchema = z.object({\n  id: z.string(),\n  type: mcpServerTypeSchema,\n  name: z.string(),\n  config: z.record(z.any()),\n  status: mcpConnectionStatusSchema,\n  lastUsed: z.string().optional(),\n  createdAt: z.string(),\n});\n\nexport const insertMCPConnectionSchema = mcpConnectionSchema.omit({\n  id: true,\n  createdAt: true,\n});\n\nexport type MCPConnection = z.infer<typeof mcpConnectionSchema>;\nexport type InsertMCPConnection = z.infer<typeof insertMCPConnectionSchema>;\n\n// MCP Tool Execution Request\nexport const mcpToolExecutionRequestSchema = z.object({\n  toolName: z.string(),\n  params: z.record(z.any()).optional(),\n});\n\nexport type MCPToolExecutionRequest = z.infer<typeof mcpToolExecutionRequestSchema>;\n\n// MCP Tool Execution Result\nexport const mcpToolExecutionResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  executionTime: z.number().optional(),\n});\n\nexport type MCPToolExecutionResult = z.infer<typeof mcpToolExecutionResultSchema>;\n\n// Container Runner Types\nexport const containerStatusSchema = z.enum([\n  \"creating\",\n  \"pulling\",\n  \"starting\",\n  \"running\",\n  \"stopping\",\n  \"stopped\",\n  \"failed\",\n  \"timeout\",\n]);\n\nexport type ContainerStatus = z.infer<typeof containerStatusSchema>;\n\nexport const containerConfigSchema = z.object({\n  image: z.string(),\n  repository: z.string(),\n  branch: z.string(),\n  command: z.array(z.string()).optional(),\n  env: z.record(z.string()).optional(),\n  workDir: z.string().optional(),\n  memoryLimit: z.string().optional(),\n  cpuLimit: z.string().optional(),\n  networkMode: z.enum([\"none\", \"bridge\", \"host\"]).optional(),\n  timeoutMs: z.number().optional(),\n});\n\nexport type ContainerConfig = z.infer<typeof containerConfigSchema>;\n\nexport const containerLogEntrySchema = z.object({\n  timestamp: z.number(),\n  stream: z.enum([\"stdout\", \"stderr\"]),\n  message: z.string(),\n  level: z.enum([\"info\", \"warn\", \"error\", \"debug\"]).optional(),\n});\n\nexport type ContainerLogEntry = z.infer<typeof containerLogEntrySchema>;\n\nexport const containerStatsSchema = z.object({\n  containerId: z.string(),\n  cpuUsage: z.number(),\n  memoryUsage: z.number(),\n  networkRx: z.number(),\n  networkTx: z.number(),\n  timestamp: z.number(),\n});\n\nexport type ContainerStats = z.infer<typeof containerStatsSchema>;\n\nexport const containerArtifactSchema = z.object({\n  type: z.enum([\"log\", \"screenshot\", \"test-report\", \"diff\", \"build-output\"]),\n  path: z.string(),\n  content: z.union([z.string(), z.instanceof(Buffer)]).optional(),\n  metadata: z.record(z.any()).optional(),\n});\n\nexport type ContainerArtifact = z.infer<typeof containerArtifactSchema>;\n\nexport const containerRunnerSchema = z.object({\n  id: z.string(),\n  taskId: z.string(),\n  containerId: z.string().optional(),\n  config: containerConfigSchema,\n  status: containerStatusSchema,\n  startedAt: z.number().optional(),\n  stoppedAt: z.number().optional(),\n  logs: z.array(containerLogEntrySchema).default([]),\n  artifacts: z.array(containerArtifactSchema).default([]),\n  stats: z.array(containerStatsSchema).default([]),\n});\n\nexport type ContainerRunner = z.infer<typeof containerRunnerSchema>;\n\nexport * from \"./db-schema\";\n","size_bytes":12747},"server/services/ai-provider-manager.ts":{"content":"import OpenAI from \"openai\";\nimport Anthropic from \"@anthropic-ai/sdk\";\nimport type {\n  ProviderConfig,\n  ProviderType,\n  ProviderMetrics,\n  RoutingConfig,\n} from \"@shared/schema\";\n\nexport interface ChatMessage {\n  role: \"system\" | \"user\" | \"assistant\";\n  content: string;\n}\n\nexport interface ChatCompletionRequest {\n  messages: ChatMessage[];\n  temperature?: number;\n  max_tokens?: number;\n  model?: string;\n}\n\nexport interface ChatCompletionResponse {\n  content: string;\n  provider: string;\n  model: string;\n  usage?: {\n    inputTokens: number;\n    outputTokens: number;\n    totalTokens: number;\n  };\n  finishReason?: string;\n}\n\nexport interface RequestContext {\n  taskComplexity?: number;\n  contextSize?: number;\n  preferredProvider?: string;\n  timeout?: number;\n}\n\ninterface ProviderInstance {\n  config: ProviderConfig;\n  client: OpenAI | Anthropic;\n  metrics: ProviderMetrics;\n  requestQueue: Array<() => Promise<any>>;\n  isProcessingQueue: boolean;\n}\n\nexport class AIProviderManager {\n  private providers: Map<string, ProviderInstance> = new Map();\n  private routingConfig: RoutingConfig;\n  private metricsUpdateCallbacks: Array<(metrics: ProviderMetrics[]) => void> = [];\n\n  constructor(\n    providerConfigs: ProviderConfig[],\n    routingConfig?: RoutingConfig\n  ) {\n    this.routingConfig = routingConfig || {\n      taskComplexityThreshold: 0.7,\n      contextSizeThreshold: 90000,\n      rateLimitThreshold: 0.2,\n      enableFallback: true,\n      userPreference: undefined,\n    };\n\n    for (const config of providerConfigs) {\n      if (config.enabled) {\n        this.initializeProvider(config);\n      }\n    }\n  }\n\n  private initializeProvider(config: ProviderConfig): void {\n    let client: OpenAI | Anthropic;\n\n    switch (config.type) {\n      case \"openai\":\n        client = new OpenAI({\n          apiKey: config.apiKey,\n          baseURL: config.endpoint,\n        });\n        break;\n\n      case \"anthropic\":\n        client = new Anthropic({\n          apiKey: config.apiKey,\n        });\n        break;\n\n      case \"azure-openai\":\n        if (!config.azureDeploymentName || !config.azureApiVersion) {\n          throw new Error(\n            \"Azure OpenAI requires deploymentName and apiVersion\"\n          );\n        }\n        client = new OpenAI({\n          apiKey: config.apiKey,\n          baseURL: config.endpoint,\n          defaultQuery: { \"api-version\": config.azureApiVersion },\n          defaultHeaders: { \"api-key\": config.apiKey },\n        });\n        break;\n\n      default:\n        throw new Error(`Unsupported provider type: ${config.type}`);\n    }\n\n    this.providers.set(config.name, {\n      config,\n      client,\n      metrics: {\n        providerName: config.name,\n        totalRequests: 0,\n        successfulRequests: 0,\n        failedRequests: 0,\n        totalTokensUsed: 0,\n        totalInputTokens: 0,\n        totalOutputTokens: 0,\n        averageResponseTime: 0,\n        totalCost: 0,\n        lastUsed: undefined,\n        rateLimitRemaining: undefined,\n        rateLimitReset: undefined,\n        errorCounts: {},\n      },\n      requestQueue: [],\n      isProcessingQueue: false,\n    });\n  }\n\n  private estimateTokens(messages: ChatMessage[]): number {\n    const text = messages.map((m) => m.content).join(\" \");\n    return Math.ceil(text.length / 4);\n  }\n\n  private estimateTaskComplexity(messages: ChatMessage[]): number {\n    const text = messages.map((m) => m.content).join(\" \");\n    const complexity =\n      (text.length / 10000) * 0.3 +\n      (messages.length / 10) * 0.2 +\n      (text.includes(\"refactor\") ||\n      text.includes(\"architecture\") ||\n      text.includes(\"design\")\n        ? 0.3\n        : 0) +\n      (text.includes(\"bug\") || text.includes(\"debug\") || text.includes(\"fix\")\n        ? 0.2\n        : 0);\n\n    return Math.min(1, complexity);\n  }\n\n  private selectProvider(\n    request: ChatCompletionRequest,\n    context: RequestContext\n  ): string | null {\n    const estimatedTokens = this.estimateTokens(request.messages);\n    const taskComplexity =\n      context.taskComplexity ?? this.estimateTaskComplexity(request.messages);\n    const contextSize = context.contextSize ?? estimatedTokens;\n\n    if (context.preferredProvider && this.providers.has(context.preferredProvider)) {\n      const provider = this.providers.get(context.preferredProvider)!;\n      if (provider.config.enabled && contextSize <= provider.config.contextWindow) {\n        return context.preferredProvider;\n      }\n    }\n\n    const eligibleProviders = Array.from(this.providers.entries())\n      .filter(([_, provider]) => {\n        if (!provider.config.enabled) return false;\n        if (contextSize > provider.config.contextWindow) return false;\n        \n        const rateLimitUsage =\n          provider.metrics.rateLimitRemaining !== undefined\n            ? 1 - provider.metrics.rateLimitRemaining\n            : 0;\n        if (rateLimitUsage > (1 - this.routingConfig.rateLimitThreshold)) {\n          return false;\n        }\n\n        return true;\n      })\n      .sort((a, b) => {\n        const [aName, aProvider] = a;\n        const [bName, bProvider] = b;\n\n        let aScore = 0;\n        let bScore = 0;\n\n        if (taskComplexity >= this.routingConfig.taskComplexityThreshold) {\n          aScore += aProvider.config.contextWindow > 150000 ? 2 : 0;\n          bScore += bProvider.config.contextWindow > 150000 ? 2 : 0;\n        }\n\n        if (contextSize >= this.routingConfig.contextSizeThreshold) {\n          aScore += aProvider.config.contextWindow > 150000 ? 3 : 0;\n          bScore += bProvider.config.contextWindow > 150000 ? 3 : 0;\n        }\n\n        aScore += aProvider.config.priority;\n        bScore += bProvider.config.priority;\n\n        const aSuccessRate =\n          aProvider.metrics.totalRequests > 0\n            ? aProvider.metrics.successfulRequests / aProvider.metrics.totalRequests\n            : 1;\n        const bSuccessRate =\n          bProvider.metrics.totalRequests > 0\n            ? bProvider.metrics.successfulRequests / bProvider.metrics.totalRequests\n            : 1;\n\n        aScore += aSuccessRate * 2;\n        bScore += bSuccessRate * 2;\n\n        if (aProvider.metrics.averageResponseTime > 0 && bProvider.metrics.averageResponseTime > 0) {\n          aScore += (1 / aProvider.metrics.averageResponseTime) * 0.5;\n          bScore += (1 / bProvider.metrics.averageResponseTime) * 0.5;\n        }\n\n        return bScore - aScore;\n      });\n\n    return eligibleProviders.length > 0 ? eligibleProviders[0][0] : null;\n  }\n\n  private async executeWithRetry<T>(\n    providerName: string,\n    fn: () => Promise<T>,\n    maxAttempts: number = 3,\n    baseDelay: number = 1000\n  ): Promise<T> {\n    const provider = this.providers.get(providerName);\n    if (!provider) {\n      throw new Error(`Provider ${providerName} not found`);\n    }\n\n    let lastError: Error | null = null;\n\n    for (let attempt = 0; attempt < maxAttempts; attempt++) {\n      try {\n        const result = await fn();\n        return result;\n      } catch (error: any) {\n        lastError = error;\n        const errorCode = error.status || error.code || \"unknown\";\n\n        if (!provider.metrics.errorCounts[errorCode]) {\n          provider.metrics.errorCounts[errorCode] = 0;\n        }\n        provider.metrics.errorCounts[errorCode]++;\n\n        if (errorCode === 429) {\n          const retryAfter = error.headers?.[\"retry-after\"]\n            ? parseInt(error.headers[\"retry-after\"]) * 1000\n            : baseDelay * Math.pow(2, attempt);\n\n          if (attempt < maxAttempts - 1) {\n            await new Promise((resolve) => setTimeout(resolve, retryAfter));\n            continue;\n          }\n        } else if (errorCode === 504 || errorCode === \"ETIMEDOUT\") {\n          if (attempt < maxAttempts - 1) {\n            const delay = Math.min(baseDelay * Math.pow(2, attempt), 120000);\n            await new Promise((resolve) => setTimeout(resolve, delay));\n            continue;\n          }\n        } else if (errorCode === 400) {\n          throw error;\n        } else if (errorCode === 503 || errorCode === \"ECONNREFUSED\") {\n          if (attempt < maxAttempts - 1) {\n            const delay = baseDelay * Math.pow(2, attempt);\n            await new Promise((resolve) => setTimeout(resolve, delay));\n            continue;\n          }\n        }\n\n        throw error;\n      }\n    }\n\n    throw lastError || new Error(\"Max retry attempts reached\");\n  }\n\n  private async queueRequest(\n    providerName: string,\n    fn: () => Promise<any>\n  ): Promise<any> {\n    const provider = this.providers.get(providerName);\n    if (!provider) {\n      throw new Error(`Provider ${providerName} not found`);\n    }\n\n    return new Promise((resolve, reject) => {\n      provider.requestQueue.push(async () => {\n        try {\n          const result = await fn();\n          resolve(result);\n        } catch (error) {\n          reject(error);\n        }\n      });\n\n      this.processQueue(providerName);\n    });\n  }\n\n  private async processQueue(providerName: string): Promise<void> {\n    const provider = this.providers.get(providerName);\n    if (!provider || provider.isProcessingQueue) return;\n\n    provider.isProcessingQueue = true;\n\n    while (provider.requestQueue.length > 0) {\n      const request = provider.requestQueue.shift();\n      if (request) {\n        try {\n          await request();\n        } catch (error) {\n          console.error(`Queue processing error for ${providerName}:`, error);\n        }\n\n        await new Promise((resolve) => setTimeout(resolve, 100));\n      }\n    }\n\n    provider.isProcessingQueue = false;\n  }\n\n  private updateMetrics(\n    providerName: string,\n    success: boolean,\n    responseTime: number,\n    usage?: {\n      inputTokens: number;\n      outputTokens: number;\n      totalTokens: number;\n    }\n  ): void {\n    const provider = this.providers.get(providerName);\n    if (!provider) return;\n\n    provider.metrics.totalRequests++;\n    if (success) {\n      provider.metrics.successfulRequests++;\n    } else {\n      provider.metrics.failedRequests++;\n    }\n\n    if (usage) {\n      provider.metrics.totalInputTokens += usage.inputTokens;\n      provider.metrics.totalOutputTokens += usage.outputTokens;\n      provider.metrics.totalTokensUsed += usage.totalTokens;\n\n      if (provider.config.costPer1kTokens) {\n        const inputCost =\n          (usage.inputTokens / 1000) * provider.config.costPer1kTokens.input;\n        const outputCost =\n          (usage.outputTokens / 1000) * provider.config.costPer1kTokens.output;\n        provider.metrics.totalCost += inputCost + outputCost;\n      }\n    }\n\n    const totalResponseTimes =\n      provider.metrics.averageResponseTime *\n        (provider.metrics.totalRequests - 1) +\n      responseTime;\n    provider.metrics.averageResponseTime =\n      totalResponseTimes / provider.metrics.totalRequests;\n\n    provider.metrics.lastUsed = new Date().toISOString();\n\n    this.notifyMetricsUpdate();\n  }\n\n  private notifyMetricsUpdate(): void {\n    const allMetrics = Array.from(this.providers.values()).map((p) => p.metrics);\n    for (const callback of this.metricsUpdateCallbacks) {\n      callback(allMetrics);\n    }\n  }\n\n  async chat(\n    request: ChatCompletionRequest,\n    context: RequestContext = {}\n  ): Promise<ChatCompletionResponse> {\n    const selectedProviderName = this.selectProvider(request, context);\n\n    if (!selectedProviderName) {\n      throw new Error(\"No eligible provider found for this request\");\n    }\n\n    const attemptWithProvider = async (\n      providerName: string\n    ): Promise<ChatCompletionResponse> => {\n      const provider = this.providers.get(providerName);\n      if (!provider) {\n        throw new Error(`Provider ${providerName} not found`);\n      }\n\n      const startTime = Date.now();\n\n      try {\n        const result = await this.executeWithRetry(\n          providerName,\n          async () => {\n            const timeout = context.timeout || 120000;\n            const timeoutPromise = new Promise<never>((_, reject) =>\n              setTimeout(() => reject(new Error(\"Request timeout\")), timeout)\n            );\n\n            const chatPromise = this.callProviderAPI(\n              provider,\n              request,\n              context\n            );\n\n            return Promise.race([chatPromise, timeoutPromise]);\n          },\n          3,\n          1000\n        );\n\n        const responseTime = Date.now() - startTime;\n\n        this.updateMetrics(providerName, true, responseTime, result.usage);\n\n        return {\n          ...result,\n          provider: providerName,\n        };\n      } catch (error: any) {\n        const responseTime = Date.now() - startTime;\n        this.updateMetrics(providerName, false, responseTime);\n\n        if (\n          this.routingConfig.enableFallback &&\n          this.providers.size > 1\n        ) {\n          const fallbackProviders = Array.from(this.providers.keys()).filter(\n            (name) => name !== providerName && this.providers.get(name)?.config.enabled\n          );\n\n          if (fallbackProviders.length > 0) {\n            console.warn(\n              `Provider ${providerName} failed, attempting fallback to ${fallbackProviders[0]}`\n            );\n            return attemptWithProvider(fallbackProviders[0]);\n          }\n        }\n\n        throw error;\n      }\n    };\n\n    return attemptWithProvider(selectedProviderName);\n  }\n\n  private async callProviderAPI(\n    provider: ProviderInstance,\n    request: ChatCompletionRequest,\n    context: RequestContext\n  ): Promise<Omit<ChatCompletionResponse, \"provider\">> {\n    const model = request.model || provider.config.model;\n    const temperature = request.temperature ?? provider.config.temperature;\n    const maxTokens = request.max_tokens ?? provider.config.maxTokens;\n\n    if (provider.config.type === \"anthropic\") {\n      const client = provider.client as Anthropic;\n\n      const systemMessage = request.messages.find((m) => m.role === \"system\");\n      const conversationMessages = request.messages.filter(\n        (m) => m.role !== \"system\"\n      );\n\n      const anthropicMessages = conversationMessages.map((msg) => ({\n        role: msg.role === \"assistant\" ? (\"assistant\" as const) : (\"user\" as const),\n        content: msg.content,\n      }));\n\n      const response = await client.messages.create({\n        model,\n        max_tokens: maxTokens,\n        temperature,\n        system: systemMessage?.content,\n        messages: anthropicMessages,\n      });\n\n      const content =\n        response.content[0].type === \"text\" ? response.content[0].text : \"\";\n\n      return {\n        content,\n        model: response.model,\n        usage: {\n          inputTokens: response.usage.input_tokens,\n          outputTokens: response.usage.output_tokens,\n          totalTokens:\n            response.usage.input_tokens + response.usage.output_tokens,\n        },\n        finishReason: response.stop_reason || undefined,\n      };\n    } else {\n      const client = provider.client as OpenAI;\n\n      const openaiMessages = request.messages.map((msg) => ({\n        role: msg.role,\n        content: msg.content,\n      }));\n\n      const response = await client.chat.completions.create({\n        model,\n        messages: openaiMessages,\n        temperature,\n        max_tokens: maxTokens,\n      });\n\n      return {\n        content: response.choices[0].message.content || \"\",\n        model: response.model,\n        usage: response.usage\n          ? {\n              inputTokens: response.usage.prompt_tokens,\n              outputTokens: response.usage.completion_tokens,\n              totalTokens: response.usage.total_tokens,\n            }\n          : undefined,\n        finishReason: response.choices[0].finish_reason,\n      };\n    }\n  }\n\n  async testProvider(providerName: string): Promise<{\n    success: boolean;\n    responseTime: number;\n    error?: string;\n  }> {\n    const startTime = Date.now();\n\n    try {\n      await this.chat(\n        {\n          messages: [\n            {\n              role: \"user\",\n              content: \"Respond with 'OK' if you can read this message.\",\n            },\n          ],\n          max_tokens: 50,\n        },\n        { preferredProvider: providerName, timeout: 10000 }\n      );\n\n      return {\n        success: true,\n        responseTime: Date.now() - startTime,\n      };\n    } catch (error: any) {\n      return {\n        success: false,\n        responseTime: Date.now() - startTime,\n        error: error.message,\n      };\n    }\n  }\n\n  getProviders(): Array<{\n    name: string;\n    type: ProviderType;\n    model: string;\n    enabled: boolean;\n    contextWindow: number;\n  }> {\n    return Array.from(this.providers.entries()).map(([name, provider]) => ({\n      name,\n      type: provider.config.type,\n      model: provider.config.model,\n      enabled: provider.config.enabled,\n      contextWindow: provider.config.contextWindow,\n    }));\n  }\n\n  getMetrics(): ProviderMetrics[] {\n    return Array.from(this.providers.values()).map((p) => p.metrics);\n  }\n\n  getProviderMetrics(providerName: string): ProviderMetrics | null {\n    const provider = this.providers.get(providerName);\n    return provider ? provider.metrics : null;\n  }\n\n  onMetricsUpdate(callback: (metrics: ProviderMetrics[]) => void): void {\n    this.metricsUpdateCallbacks.push(callback);\n  }\n\n  updateProviderConfig(name: string, updates: Partial<ProviderConfig>): void {\n    const provider = this.providers.get(name);\n    if (provider) {\n      provider.config = { ...provider.config, ...updates };\n    }\n  }\n\n  updateRoutingConfig(updates: Partial<RoutingConfig>): void {\n    this.routingConfig = { ...this.routingConfig, ...updates };\n  }\n}\n","size_bytes":17525},"client/src/components/examples/ExecutionLogPanel.tsx":{"content":"import { ExecutionLogPanel } from '../execution-log-panel';\n\nconst mockLogs = [\n  { id: \"1\", timestamp: \"14:23:01\", level: \"info\" as const, message: \"Task initiated: Refactor authentication middleware\" },\n  { id: \"2\", timestamp: \"14:23:02\", level: \"info\" as const, message: \"Analyzing repository structure...\" },\n  { id: \"3\", timestamp: \"14:23:05\", level: \"success\" as const, message: \"Repository cloned successfully\" },\n  { id: \"4\", timestamp: \"14:23:07\", level: \"info\" as const, message: \"Reading authentication middleware files\" },\n  { id: \"5\", timestamp: \"14:23:12\", level: \"warn\" as const, message: \"Detected potential security vulnerability\" },\n  { id: \"6\", timestamp: \"14:23:15\", level: \"error\" as const, message: \"Critical: Hardcoded secrets found in codebase\" },\n];\n\nexport default function ExecutionLogPanelExample() {\n  return (\n    <div className=\"h-[400px]\">\n      <ExecutionLogPanel logs={mockLogs} />\n    </div>\n  );\n}\n","size_bytes":934},"server/services/container-runner.ts":{"content":"import { spawn, type ChildProcess } from \"child_process\";\nimport { randomUUID } from \"crypto\";\nimport { EventEmitter } from \"events\";\nimport type { Task } from \"@shared/schema\";\n\nexport interface ContainerConfig {\n  image: string;\n  repository: string;\n  branch: string;\n  command?: string[];\n  env?: Record<string, string>;\n  workDir?: string;\n  memoryLimit?: string;\n  cpuLimit?: string;\n  networkMode?: \"none\" | \"bridge\" | \"host\";\n  timeoutMs?: number;\n}\n\nexport interface ContainerStats {\n  containerId: string;\n  cpuUsage: number;\n  memoryUsage: number;\n  networkRx: number;\n  networkTx: number;\n  timestamp: number;\n}\n\nexport interface ContainerLogEntry {\n  timestamp: number;\n  stream: \"stdout\" | \"stderr\";\n  message: string;\n  level?: \"info\" | \"warn\" | \"error\" | \"debug\";\n}\n\nexport interface ContainerArtifact {\n  type: \"log\" | \"screenshot\" | \"test-report\" | \"diff\" | \"build-output\";\n  path: string;\n  content?: string | Buffer;\n  metadata?: Record<string, any>;\n}\n\nexport interface ContainerResult {\n  exitCode: number;\n  duration: number;\n  logs: ContainerLogEntry[];\n  artifacts: ContainerArtifact[];\n  stats: ContainerStats[];\n  error?: string;\n}\n\nexport type ContainerStatus = \n  | \"creating\" \n  | \"pulling\" \n  | \"starting\" \n  | \"running\" \n  | \"stopping\" \n  | \"stopped\" \n  | \"failed\" \n  | \"timeout\";\n\nexport interface ContainerRunner {\n  id: string;\n  taskId: string;\n  containerId?: string;\n  config: ContainerConfig;\n  status: ContainerStatus;\n  startedAt?: number;\n  stoppedAt?: number;\n  logs: ContainerLogEntry[];\n  artifacts: ContainerArtifact[];\n  stats: ContainerStats[];\n  process?: ChildProcess;\n}\n\nexport class ContainerRunnerService extends EventEmitter {\n  private runners: Map<string, ContainerRunner> = new Map();\n  private statsIntervals: Map<string, NodeJS.Timeout> = new Map();\n\n  constructor() {\n    super();\n  }\n\n  /**\n   * Create and start a new ephemeral container runner for a task\n   */\n  async createRunner(taskId: string, config: ContainerConfig): Promise<string> {\n    const runnerId = randomUUID();\n    \n    const runner: ContainerRunner = {\n      id: runnerId,\n      taskId,\n      config: {\n        ...config,\n        memoryLimit: config.memoryLimit || \"2g\",\n        cpuLimit: config.cpuLimit || \"2\",\n        networkMode: config.networkMode || \"bridge\",\n        timeoutMs: config.timeoutMs || 300000, // 5 minutes default\n      },\n      status: \"creating\",\n      logs: [],\n      artifacts: [],\n      stats: [],\n    };\n\n    this.runners.set(runnerId, runner);\n    this.emit(\"runner:created\", { runnerId, taskId });\n\n    // Start the container asynchronously\n    this.startContainer(runnerId).catch((error) => {\n      this.handleRunnerError(runnerId, error);\n    });\n\n    return runnerId;\n  }\n\n  /**\n   * Start the Docker container with full lifecycle management\n   */\n  private async startContainer(runnerId: string): Promise<void> {\n    const runner = this.runners.get(runnerId);\n    if (!runner) {\n      throw new Error(`Runner ${runnerId} not found`);\n    }\n\n    try {\n      // Update status to pulling\n      runner.status = \"pulling\";\n      this.emit(\"runner:status\", { runnerId, status: \"pulling\" });\n\n      // Pull the Docker image\n      await this.pullImage(runner.config.image);\n\n      // Generate unique container name\n      const containerName = `ai-agent-${runner.taskId}-${runnerId.slice(0, 8)}`;\n      \n      // Build Docker run command\n      const dockerArgs = this.buildDockerArgs(containerName, runner.config);\n\n      // Update status to starting\n      runner.status = \"starting\";\n      this.emit(\"runner:status\", { runnerId, status: \"starting\" });\n\n      // Spawn Docker container\n      const process = spawn(\"docker\", dockerArgs, {\n        stdio: [\"ignore\", \"pipe\", \"pipe\"],\n      });\n\n      runner.process = process;\n      runner.containerId = containerName;\n      runner.startedAt = Date.now();\n      runner.status = \"running\";\n      this.emit(\"runner:status\", { runnerId, status: \"running\" });\n\n      // Setup log streaming\n      this.setupLogStreaming(runnerId, process);\n\n      // Setup stats collection\n      this.startStatsCollection(runnerId);\n\n      // Setup timeout\n      if (runner.config.timeoutMs) {\n        setTimeout(() => {\n          if (runner.status === \"running\") {\n            this.stopRunner(runnerId, \"timeout\");\n          }\n        }, runner.config.timeoutMs);\n      }\n\n      // Handle process exit\n      process.on(\"exit\", (code) => {\n        this.handleProcessExit(runnerId, code || 0);\n      });\n\n      process.on(\"error\", (error) => {\n        this.handleRunnerError(runnerId, error);\n      });\n\n    } catch (error) {\n      this.handleRunnerError(runnerId, error as Error);\n    }\n  }\n\n  /**\n   * Pull Docker image if not exists locally\n   */\n  private async pullImage(image: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const pullProcess = spawn(\"docker\", [\"pull\", image], {\n        stdio: [\"ignore\", \"pipe\", \"pipe\"],\n      });\n\n      pullProcess.on(\"exit\", (code) => {\n        if (code === 0) {\n          resolve();\n        } else {\n          reject(new Error(`Failed to pull image ${image}`));\n        }\n      });\n\n      pullProcess.on(\"error\", reject);\n    });\n  }\n\n  /**\n   * Build Docker run arguments with security and resource constraints\n   */\n  private buildDockerArgs(containerName: string, config: ContainerConfig): string[] {\n    const args = [\n      \"run\",\n      \"--rm\", // Remove container on exit\n      \"--name\", containerName,\n      \n      // Resource limits\n      \"--memory\", config.memoryLimit!,\n      \"--cpus\", config.cpuLimit!,\n      \n      // Network configuration\n      \"--network\", config.networkMode!,\n      \n      // Security: Read-only root filesystem (except working directory)\n      \"--read-only\",\n      \n      // Temporary filesystem for work\n      \"--tmpfs\", \"/tmp:rw,noexec,nosuid,size=512m\",\n      \n      // No privileged mode\n      \"--security-opt\", \"no-new-privileges\",\n      \n      // Drop all capabilities\n      \"--cap-drop\", \"ALL\",\n    ];\n\n    // Add environment variables\n    if (config.env) {\n      for (const [key, value] of Object.entries(config.env)) {\n        args.push(\"-e\", `${key}=${value}`);\n      }\n    }\n\n    // Add working directory\n    if (config.workDir) {\n      args.push(\"-w\", config.workDir);\n      // Mount working directory as writable\n      args.push(\"--tmpfs\", `${config.workDir}:rw,exec,size=1g`);\n    }\n\n    // Add repository clone command\n    args.push(\n      \"--entrypoint\", \"/bin/sh\",\n      config.image,\n      \"-c\",\n      this.buildRunCommand(config)\n    );\n\n    return args;\n  }\n\n  /**\n   * Build the command to run inside the container\n   */\n  private buildRunCommand(config: ContainerConfig): string {\n    const commands: string[] = [];\n\n    // Clone repository\n    commands.push(`git clone --depth 1 --branch ${config.branch} https://github.com/${config.repository}.git /workspace`);\n    commands.push(\"cd /workspace\");\n\n    // Run custom command or default build/test\n    if (config.command && config.command.length > 0) {\n      commands.push(config.command.join(\" \"));\n    } else {\n      // Default: try to detect and run tests\n      commands.push(`\n        if [ -f package.json ]; then\n          npm install && npm test\n        elif [ -f requirements.txt ]; then\n          pip install -r requirements.txt && pytest\n        elif [ -f Cargo.toml ]; then\n          cargo build && cargo test\n        elif [ -f go.mod ]; then\n          go build && go test ./...\n        else\n          echo \"No recognized build system found\"\n        fi\n      `);\n    }\n\n    return commands.join(\" && \");\n  }\n\n  /**\n   * Setup real-time log streaming from container\n   */\n  private setupLogStreaming(runnerId: string, process: ChildProcess): void {\n    const runner = this.runners.get(runnerId);\n    if (!runner) return;\n\n    // Stream stdout\n    process.stdout?.on(\"data\", (data: Buffer) => {\n      const message = data.toString();\n      const logEntry: ContainerLogEntry = {\n        timestamp: Date.now(),\n        stream: \"stdout\",\n        message,\n        level: this.detectLogLevel(message),\n      };\n\n      runner.logs.push(logEntry);\n      this.emit(\"runner:log\", { runnerId, log: logEntry });\n    });\n\n    // Stream stderr\n    process.stderr?.on(\"data\", (data: Buffer) => {\n      const message = data.toString();\n      const logEntry: ContainerLogEntry = {\n        timestamp: Date.now(),\n        stream: \"stderr\",\n        message,\n        level: \"error\",\n      };\n\n      runner.logs.push(logEntry);\n      this.emit(\"runner:log\", { runnerId, log: logEntry });\n    });\n  }\n\n  /**\n   * Detect log level from message content\n   */\n  private detectLogLevel(message: string): \"info\" | \"warn\" | \"error\" | \"debug\" {\n    const lowerMessage = message.toLowerCase();\n    \n    if (lowerMessage.includes(\"error\") || lowerMessage.includes(\"fail\")) {\n      return \"error\";\n    } else if (lowerMessage.includes(\"warn\")) {\n      return \"warn\";\n    } else if (lowerMessage.includes(\"debug\")) {\n      return \"debug\";\n    }\n    \n    return \"info\";\n  }\n\n  /**\n   * Start collecting container stats\n   */\n  private startStatsCollection(runnerId: string): void {\n    const runner = this.runners.get(runnerId);\n    if (!runner || !runner.containerId) return;\n\n    const interval = setInterval(() => {\n      this.collectStats(runnerId);\n    }, 2000); // Collect stats every 2 seconds\n\n    this.statsIntervals.set(runnerId, interval);\n  }\n\n  /**\n   * Collect container statistics\n   */\n  private async collectStats(runnerId: string): Promise<void> {\n    const runner = this.runners.get(runnerId);\n    if (!runner || !runner.containerId || runner.status !== \"running\") return;\n\n    try {\n      const statsProcess = spawn(\"docker\", [\n        \"stats\",\n        runner.containerId,\n        \"--no-stream\",\n        \"--format\",\n        \"{{json .}}\",\n      ]);\n\n      let output = \"\";\n      statsProcess.stdout.on(\"data\", (data) => {\n        output += data.toString();\n      });\n\n      statsProcess.on(\"exit\", (code) => {\n        if (code === 0 && output) {\n          try {\n            const stats = JSON.parse(output);\n            const containerStats: ContainerStats = {\n              containerId: runner.containerId!,\n              cpuUsage: parseFloat(stats.CPUPerc?.replace(\"%\", \"\") || \"0\"),\n              memoryUsage: this.parseMemoryUsage(stats.MemUsage || \"0B / 0B\"),\n              networkRx: this.parseNetworkIO(stats.NetIO || \"0B / 0B\").rx,\n              networkTx: this.parseNetworkIO(stats.NetIO || \"0B / 0B\").tx,\n              timestamp: Date.now(),\n            };\n\n            runner.stats.push(containerStats);\n            this.emit(\"runner:stats\", { runnerId, stats: containerStats });\n          } catch (error) {\n            // Ignore parsing errors\n          }\n        }\n      });\n    } catch (error) {\n      // Ignore stats collection errors\n    }\n  }\n\n  /**\n   * Parse memory usage from Docker stats format\n   */\n  private parseMemoryUsage(memUsage: string): number {\n    const match = memUsage.match(/^([\\d.]+)([KMGT]?B)/);\n    if (!match) return 0;\n\n    const value = parseFloat(match[1]);\n    const unit = match[2];\n\n    const multipliers: Record<string, number> = {\n      \"B\": 1,\n      \"KB\": 1024,\n      \"MB\": 1024 * 1024,\n      \"GB\": 1024 * 1024 * 1024,\n      \"TB\": 1024 * 1024 * 1024 * 1024,\n    };\n\n    return value * (multipliers[unit] || 1);\n  }\n\n  /**\n   * Parse network I/O from Docker stats format\n   */\n  private parseNetworkIO(netIO: string): { rx: number; tx: number } {\n    const parts = netIO.split(\" / \");\n    return {\n      rx: this.parseMemoryUsage(parts[0] || \"0B\"),\n      tx: this.parseMemoryUsage(parts[1] || \"0B\"),\n    };\n  }\n\n  /**\n   * Handle process exit\n   */\n  private handleProcessExit(runnerId: string, exitCode: number): void {\n    const runner = this.runners.get(runnerId);\n    if (!runner) return;\n\n    runner.stoppedAt = Date.now();\n    runner.status = exitCode === 0 ? \"stopped\" : \"failed\";\n\n    // Stop stats collection\n    const statsInterval = this.statsIntervals.get(runnerId);\n    if (statsInterval) {\n      clearInterval(statsInterval);\n      this.statsIntervals.delete(runnerId);\n    }\n\n    this.emit(\"runner:exit\", {\n      runnerId,\n      exitCode,\n      duration: runner.stoppedAt - (runner.startedAt || runner.stoppedAt),\n    });\n\n    // Cleanup\n    this.cleanupRunner(runnerId);\n  }\n\n  /**\n   * Handle runner error\n   */\n  private handleRunnerError(runnerId: string, error: Error): void {\n    const runner = this.runners.get(runnerId);\n    if (!runner) return;\n\n    runner.status = \"failed\";\n    runner.stoppedAt = Date.now();\n\n    const logEntry: ContainerLogEntry = {\n      timestamp: Date.now(),\n      stream: \"stderr\",\n      message: error.message,\n      level: \"error\",\n    };\n\n    runner.logs.push(logEntry);\n    this.emit(\"runner:error\", { runnerId, error: error.message });\n\n    // Stop stats collection\n    const statsInterval = this.statsIntervals.get(runnerId);\n    if (statsInterval) {\n      clearInterval(statsInterval);\n      this.statsIntervals.delete(runnerId);\n    }\n\n    // Cleanup\n    this.cleanupRunner(runnerId);\n  }\n\n  /**\n   * Stop a running container\n   */\n  async stopRunner(runnerId: string, reason?: \"timeout\" | \"manual\" | \"error\"): Promise<void> {\n    const runner = this.runners.get(runnerId);\n    if (!runner) return;\n\n    runner.status = \"stopping\";\n    this.emit(\"runner:status\", { runnerId, status: \"stopping\", reason });\n\n    // Kill the process\n    if (runner.process && !runner.process.killed) {\n      runner.process.kill(\"SIGTERM\");\n      \n      // Force kill after 5 seconds if still running\n      setTimeout(() => {\n        if (runner.process && !runner.process.killed) {\n          runner.process.kill(\"SIGKILL\");\n        }\n      }, 5000);\n    }\n\n    // Stop container if it exists\n    if (runner.containerId) {\n      try {\n        await new Promise<void>((resolve) => {\n          const stopProcess = spawn(\"docker\", [\"stop\", runner.containerId!]);\n          stopProcess.on(\"exit\", () => resolve());\n          stopProcess.on(\"error\", () => resolve());\n        });\n      } catch (error) {\n        // Ignore errors during stop\n      }\n    }\n  }\n\n  /**\n   * Cleanup runner resources\n   */\n  private async cleanupRunner(runnerId: string): Promise<void> {\n    const runner = this.runners.get(runnerId);\n    if (!runner) return;\n\n    // Remove container if it still exists\n    if (runner.containerId) {\n      try {\n        spawn(\"docker\", [\"rm\", \"-f\", runner.containerId]);\n      } catch (error) {\n        // Ignore cleanup errors\n      }\n    }\n\n    // Keep runner for 1 hour for log retrieval\n    setTimeout(() => {\n      this.runners.delete(runnerId);\n      this.emit(\"runner:deleted\", { runnerId });\n    }, 3600000);\n  }\n\n  /**\n   * Get runner status and details\n   */\n  getRunner(runnerId: string): ContainerRunner | undefined {\n    return this.runners.get(runnerId);\n  }\n\n  /**\n   * Get all runners for a task\n   */\n  getTaskRunners(taskId: string): ContainerRunner[] {\n    return Array.from(this.runners.values()).filter(\n      (runner) => runner.taskId === taskId\n    );\n  }\n\n  /**\n   * Get runner result\n   */\n  getRunnerResult(runnerId: string): ContainerResult | undefined {\n    const runner = this.runners.get(runnerId);\n    if (!runner) return undefined;\n\n    return {\n      exitCode: runner.status === \"stopped\" ? 0 : 1,\n      duration: (runner.stoppedAt || Date.now()) - (runner.startedAt || 0),\n      logs: runner.logs,\n      artifacts: runner.artifacts,\n      stats: runner.stats,\n      error: runner.status === \"failed\" ? \"Container failed\" : undefined,\n    };\n  }\n\n  /**\n   * Add artifact to runner\n   */\n  addArtifact(runnerId: string, artifact: ContainerArtifact): void {\n    const runner = this.runners.get(runnerId);\n    if (!runner) return;\n\n    runner.artifacts.push(artifact);\n    this.emit(\"runner:artifact\", { runnerId, artifact });\n  }\n}\n","size_bytes":15804},"server/services/memory-manager.ts":{"content":"import type { IStorage } from \"../storage\";\nimport type { RepositoryContext, Task } from \"@shared/schema\";\nimport type { GitHubService } from \"./github\";\nimport type { AIService } from \"./ai\";\n\nexport interface DependencyNode {\n  id: string;\n  name: string;\n  version?: string;\n  type: \"dependency\" | \"devDependency\" | \"peerDependency\";\n  children: string[]; // IDs of dependent packages\n  dependents: string[]; // IDs of packages that depend on this\n}\n\nexport interface DependencyGraph {\n  nodes: Map<string, DependencyNode>;\n  edges: Array<{ from: string; to: string; type: string }>;\n  cycles: string[][];\n}\n\nexport interface FileNode {\n  path: string;\n  language?: string;\n  size: number;\n  lastModified: string;\n  imports: string[];\n  exports: string[];\n  dependencies: string[];\n}\n\nexport interface ArchitectureLayer {\n  name: string;\n  description: string;\n  files: string[];\n  patterns: string[];\n  responsibilities: string[];\n}\n\nexport interface CodePattern {\n  pattern: string;\n  description: string;\n  occurrences: Array<{ file: string; line: number }>;\n  category: \"design-pattern\" | \"anti-pattern\" | \"idiom\" | \"convention\";\n}\n\nexport interface SemanticContext {\n  repository: string;\n  summary: string;\n  architecture: {\n    type?: string; // monorepo, microservices, monolith, etc.\n    layers: ArchitectureLayer[];\n    patterns: CodePattern[];\n  };\n  dependencyGraph: DependencyGraph;\n  fileMap: Map<string, FileNode>;\n  technicalDebt: {\n    totalScore: number;\n    issues: Array<{\n      type: string;\n      severity: \"critical\" | \"high\" | \"medium\" | \"low\";\n      description: string;\n      files: string[];\n    }>;\n  };\n  knowledgeGraph: Map<string, {\n    concept: string;\n    related: string[];\n    confidence: number;\n  }>;\n}\n\nexport interface HistoricalAnalysis {\n  frequentlyModifiedFiles: Array<{ path: string; changeCount: number }>;\n  buggyFiles: Array<{ path: string; bugFixCount: number }>;\n  authorExpertise: Map<string, { files: string[]; domains: string[] }>;\n  changePatterns: {\n    averageCommitSize: number;\n    peakActivityHours: number[];\n    refactoringRatio: number;\n  };\n}\n\nexport class MemoryManager {\n  private storage: IStorage;\n  private githubService?: GitHubService;\n  private aiService?: AIService;\n  private contextCache: Map<string, SemanticContext> = new Map();\n  private analysisCache: Map<string, HistoricalAnalysis> = new Map();\n\n  constructor(\n    storage: IStorage,\n    githubService?: GitHubService,\n    aiService?: AIService\n  ) {\n    this.storage = storage;\n    this.githubService = githubService;\n    this.aiService = aiService;\n  }\n\n  /**\n   * Build or retrieve semantic context for a repository\n   */\n  async getSemanticContext(repository: string, forceRefresh = false): Promise<SemanticContext> {\n    // Check cache\n    if (!forceRefresh && this.contextCache.has(repository)) {\n      return this.contextCache.get(repository)!;\n    }\n\n    // Try to load from storage\n    const stored = await this.storage.getRepositoryContext(repository);\n    if (stored && !forceRefresh) {\n      return this.deserializeContext(stored);\n    }\n\n    // Build new context\n    const context = await this.buildSemanticContext(repository);\n    this.contextCache.set(repository, context);\n\n    // Save to storage\n    await this.saveSemanticContext(repository, context);\n\n    return context;\n  }\n\n  /**\n   * Build semantic context from repository analysis\n   */\n  private async buildSemanticContext(repository: string): Promise<SemanticContext> {\n    const context: SemanticContext = {\n      repository,\n      summary: \"\",\n      architecture: {\n        layers: [],\n        patterns: [],\n      },\n      dependencyGraph: {\n        nodes: new Map(),\n        edges: [],\n        cycles: [],\n      },\n      fileMap: new Map(),\n      technicalDebt: {\n        totalScore: 0,\n        issues: [],\n      },\n      knowledgeGraph: new Map(),\n    };\n\n    if (!this.githubService) {\n      return context;\n    }\n\n    try {\n      // Analyze file structure\n      const fileStructure = await this.analyzeFileStructure(repository);\n      context.fileMap = fileStructure;\n\n      // Build dependency graph\n      const depGraph = await this.buildDependencyGraph(repository, fileStructure);\n      context.dependencyGraph = depGraph;\n\n      // Detect architectural layers\n      const layers = this.detectArchitecturalLayers(fileStructure);\n      context.architecture.layers = layers;\n\n      // Identify code patterns\n      const patterns = await this.identifyCodePatterns(repository, fileStructure);\n      context.architecture.patterns = patterns;\n\n      // Analyze technical debt\n      const debt = this.analyzeTechnicalDebt(fileStructure, patterns);\n      context.technicalDebt = debt;\n\n      // Generate semantic summary using AI\n      if (this.aiService) {\n        context.summary = await this.generateSemanticSummary(context);\n      }\n\n      // Build knowledge graph\n      context.knowledgeGraph = this.buildKnowledgeGraph(context);\n\n    } catch (error) {\n      console.error(`Error building semantic context for ${repository}:`, error);\n    }\n\n    return context;\n  }\n\n  /**\n   * Analyze file structure and create file nodes\n   */\n  private async analyzeFileStructure(repository: string): Promise<Map<string, FileNode>> {\n    const fileMap = new Map<string, FileNode>();\n\n    if (!this.githubService) {\n      return fileMap;\n    }\n\n    try {\n      // Get repository file tree (this would use GitHub API)\n      const [owner, repo] = repository.split(\"/\");\n      \n      // For now, return empty map - in production would call GitHub API\n      // const files = await this.githubService.getRepositoryTree(owner, repo);\n      \n    } catch (error) {\n      console.error(`Error analyzing file structure for ${repository}:`, error);\n    }\n\n    return fileMap;\n  }\n\n  /**\n   * Build dependency graph from package files\n   */\n  private async buildDependencyGraph(\n    repository: string,\n    fileMap: Map<string, FileNode>\n  ): Promise<DependencyGraph> {\n    const graph: DependencyGraph = {\n      nodes: new Map(),\n      edges: [],\n      cycles: [],\n    };\n\n    // Parse package.json, requirements.txt, Cargo.toml, etc.\n    for (const [path, file] of fileMap) {\n      if (path.endsWith(\"package.json\")) {\n        await this.parseNpmDependencies(repository, path, graph);\n      } else if (path.endsWith(\"requirements.txt\")) {\n        await this.parsePythonDependencies(repository, path, graph);\n      } else if (path.endsWith(\"Cargo.toml\")) {\n        await this.parseRustDependencies(repository, path, graph);\n      }\n    }\n\n    // Detect circular dependencies\n    graph.cycles = this.detectDependencyCycles(graph);\n\n    return graph;\n  }\n\n  /**\n   * Parse npm dependencies from package.json\n   */\n  private async parseNpmDependencies(\n    repository: string,\n    path: string,\n    graph: DependencyGraph\n  ): Promise<void> {\n    if (!this.githubService) return;\n\n    try {\n      const content = await this.githubService.getFileContent(repository, path);\n      const packageJson = JSON.parse(content);\n\n      // Add dependencies\n      if (packageJson.dependencies) {\n        for (const [name, version] of Object.entries(packageJson.dependencies)) {\n          const node: DependencyNode = {\n            id: name,\n            name,\n            version: version as string,\n            type: \"dependency\",\n            children: [],\n            dependents: [],\n          };\n          graph.nodes.set(name, node);\n        }\n      }\n\n      // Add devDependencies\n      if (packageJson.devDependencies) {\n        for (const [name, version] of Object.entries(packageJson.devDependencies)) {\n          const node: DependencyNode = {\n            id: name,\n            name,\n            version: version as string,\n            type: \"devDependency\",\n            children: [],\n            dependents: [],\n          };\n          graph.nodes.set(name, node);\n        }\n      }\n    } catch (error) {\n      console.error(`Error parsing package.json from ${repository}:`, error);\n    }\n  }\n\n  /**\n   * Parse Python dependencies\n   */\n  private async parsePythonDependencies(\n    repository: string,\n    path: string,\n    graph: DependencyGraph\n  ): Promise<void> {\n    // Similar to parseNpmDependencies but for Python\n  }\n\n  /**\n   * Parse Rust dependencies\n   */\n  private async parseRustDependencies(\n    repository: string,\n    path: string,\n    graph: DependencyGraph\n  ): Promise<void> {\n    // Similar to parseNpmDependencies but for Rust\n  }\n\n  /**\n   * Detect circular dependencies in the graph\n   */\n  private detectDependencyCycles(graph: DependencyGraph): string[][] {\n    const cycles: string[][] = [];\n    const visited = new Set<string>();\n    const recursionStack = new Set<string>();\n\n    const dfs = (nodeId: string, path: string[]): void => {\n      visited.add(nodeId);\n      recursionStack.add(nodeId);\n      path.push(nodeId);\n\n      const node = graph.nodes.get(nodeId);\n      if (node) {\n        for (const childId of node.children) {\n          if (!visited.has(childId)) {\n            dfs(childId, path);\n          } else if (recursionStack.has(childId)) {\n            // Found cycle\n            const cycleStart = path.indexOf(childId);\n            cycles.push(path.slice(cycleStart));\n          }\n        }\n      }\n\n      recursionStack.delete(nodeId);\n      path.pop();\n    };\n\n    for (const nodeId of graph.nodes.keys()) {\n      if (!visited.has(nodeId)) {\n        dfs(nodeId, []);\n      }\n    }\n\n    return cycles;\n  }\n\n  /**\n   * Detect architectural layers from file structure\n   */\n  private detectArchitecturalLayers(fileMap: Map<string, FileNode>): ArchitectureLayer[] {\n    const layers: ArchitectureLayer[] = [];\n\n    const layerPatterns = [\n      {\n        name: \"Presentation Layer\",\n        patterns: [\"*/components/*\", \"*/pages/*\", \"*/views/*\", \"*/ client/*\"],\n        description: \"UI components and presentation logic\",\n      },\n      {\n        name: \"Business Logic Layer\",\n        patterns: [\"*/services/*\", \"*/domain/*\", \"*/business/*\", \"*/core/*\"],\n        description: \"Business rules and domain logic\",\n      },\n      {\n        name: \"Data Access Layer\",\n        patterns: [\"*/repositories/*\", \"*/database/*\", \"*/storage/*\", \"*/models/*\"],\n        description: \"Data persistence and retrieval\",\n      },\n      {\n        name: \"API Layer\",\n        patterns: [\"*/routes/*\", \"*/controllers/*\", \"*/api/*\", \"*/handlers/*\"],\n        description: \"HTTP endpoints and request handling\",\n      },\n    ];\n\n    for (const layerPattern of layerPatterns) {\n      const matchingFiles: string[] = [];\n      \n      for (const [path] of fileMap) {\n        for (const pattern of layerPattern.patterns) {\n          const regex = new RegExp(pattern.replace(\"*\", \".*\"));\n          if (regex.test(path)) {\n            matchingFiles.push(path);\n            break;\n          }\n        }\n      }\n\n      if (matchingFiles.length > 0) {\n        layers.push({\n          name: layerPattern.name,\n          description: layerPattern.description,\n          files: matchingFiles,\n          patterns: layerPattern.patterns,\n          responsibilities: [],\n        });\n      }\n    }\n\n    return layers;\n  }\n\n  /**\n   * Identify code patterns and anti-patterns\n   */\n  private async identifyCodePatterns(\n    repository: string,\n    fileMap: Map<string, FileNode>\n  ): Promise<CodePattern[]> {\n    const patterns: CodePattern[] = [];\n\n    // Identify common design patterns (singleton, factory, observer, etc.)\n    // This would use AST analysis in production\n\n    return patterns;\n  }\n\n  /**\n   * Analyze technical debt\n   */\n  private analyzeTechnicalDebt(\n    fileMap: Map<string, FileNode>,\n    patterns: CodePattern[]\n  ): SemanticContext[\"technicalDebt\"] {\n    const issues: SemanticContext[\"technicalDebt\"][\"issues\"] = [];\n    let totalScore = 0;\n\n    // Look for anti-patterns\n    for (const pattern of patterns) {\n      if (pattern.category === \"anti-pattern\") {\n        issues.push({\n          type: \"anti-pattern\",\n          severity: \"medium\",\n          description: pattern.description,\n          files: pattern.occurrences.map((o) => o.file),\n        });\n        totalScore += 5 * pattern.occurrences.length;\n      }\n    }\n\n    // Large file size (>1000 lines)\n    for (const [path, file] of fileMap) {\n      if (file.size > 1000) {\n        issues.push({\n          type: \"large-file\",\n          severity: \"low\",\n          description: `File ${path} is too large (${file.size} lines)`,\n          files: [path],\n        });\n        totalScore += 2;\n      }\n    }\n\n    return {\n      totalScore,\n      issues,\n    };\n  }\n\n  /**\n   * Generate semantic summary using AI\n   */\n  private async generateSemanticSummary(context: SemanticContext): Promise<string> {\n    if (!this.aiService) {\n      return \"No summary available\";\n    }\n\n    const prompt = `Analyze this repository structure and provide a concise semantic summary:\n\nArchitecture Layers: ${context.architecture.layers.map((l) => l.name).join(\", \")}\nTotal Files: ${context.fileMap.size}\nDependencies: ${context.dependencyGraph.nodes.size}\nTechnical Debt Score: ${context.technicalDebt.totalScore}\n\nProvide a 2-3 sentence summary of the repository's purpose, architecture, and key characteristics.`;\n\n    try {\n      // This would call the AI service\n      return \"Repository summary placeholder\";\n    } catch (error) {\n      return \"Failed to generate summary\";\n    }\n  }\n\n  /**\n   * Build knowledge graph connecting concepts\n   */\n  private buildKnowledgeGraph(context: SemanticContext): Map<string, {\n    concept: string;\n    related: string[];\n    confidence: number;\n  }> {\n    const graph = new Map();\n\n    // Extract concepts from architecture layers\n    for (const layer of context.architecture.layers) {\n      graph.set(layer.name, {\n        concept: layer.name,\n        related: layer.patterns,\n        confidence: 0.9,\n      });\n    }\n\n    return graph;\n  }\n\n  /**\n   * Perform historical analysis on repository\n   */\n  async getHistoricalAnalysis(repository: string): Promise<HistoricalAnalysis> {\n    // Check cache\n    if (this.analysisCache.has(repository)) {\n      return this.analysisCache.get(repository)!;\n    }\n\n    const analysis = await this.buildHistoricalAnalysis(repository);\n    this.analysisCache.set(repository, analysis);\n\n    return analysis;\n  }\n\n  /**\n   * Build historical analysis from commits and issues\n   */\n  private async buildHistoricalAnalysis(repository: string): Promise<HistoricalAnalysis> {\n    const analysis: HistoricalAnalysis = {\n      frequentlyModifiedFiles: [],\n      buggyFiles: [],\n      authorExpertise: new Map(),\n      changePatterns: {\n        averageCommitSize: 0,\n        peakActivityHours: [],\n        refactoringRatio: 0,\n      },\n    };\n\n    if (!this.githubService) {\n      return analysis;\n    }\n\n    // This would analyze commit history via GitHub API\n    // For now, return empty analysis\n\n    return analysis;\n  }\n\n  /**\n   * Update context with new information\n   */\n  async updateContext(\n    repository: string,\n    updates: Partial<SemanticContext>\n  ): Promise<void> {\n    const context = await this.getSemanticContext(repository);\n    Object.assign(context, updates);\n    \n    this.contextCache.set(repository, context);\n    await this.saveSemanticContext(repository, context);\n  }\n\n  /**\n   * Save semantic context to storage\n   */\n  private async saveSemanticContext(\n    repository: string,\n    context: SemanticContext\n  ): Promise<void> {\n    const serialized = this.serializeContext(context);\n    \n    const existing = await this.storage.getRepositoryContext(repository);\n    if (existing) {\n      await this.storage.updateRepositoryContext(repository, serialized);\n    } else {\n      await this.storage.createRepositoryContext({\n        repository,\n        ...serialized,\n      });\n    }\n  }\n\n  /**\n   * Serialize context for storage\n   */\n  private serializeContext(context: SemanticContext): Partial<RepositoryContext> {\n    return {\n      repository: context.repository,\n      semanticSummary: context.summary,\n      architecture: {\n        type: context.architecture.type,\n        layers: context.architecture.layers,\n        patterns: context.architecture.patterns,\n      },\n      dependencies: {\n        graph: Object.fromEntries(context.dependencyGraph.nodes),\n        cycles: context.dependencyGraph.cycles,\n      },\n      fileStructure: Array.from(context.fileMap.keys()),\n    };\n  }\n\n  /**\n   * Deserialize context from storage\n   */\n  private deserializeContext(stored: RepositoryContext): SemanticContext {\n    return {\n      repository: stored.repository,\n      summary: stored.semanticSummary || \"\",\n      architecture: (stored.architecture as any) || {\n        layers: [],\n        patterns: [],\n      },\n      dependencyGraph: {\n        nodes: new Map(Object.entries((stored.dependencies as any)?.graph || {})),\n        edges: [],\n        cycles: (stored.dependencies as any)?.cycles || [],\n      },\n      fileMap: new Map(),\n      technicalDebt: {\n        totalScore: 0,\n        issues: [],\n      },\n      knowledgeGraph: new Map(),\n    };\n  }\n\n  /**\n   * Clear caches\n   */\n  clearCache(repository?: string): void {\n    if (repository) {\n      this.contextCache.delete(repository);\n      this.analysisCache.delete(repository);\n    } else {\n      this.contextCache.clear();\n      this.analysisCache.clear();\n    }\n  }\n}\n","size_bytes":17282},"server/services/advanced-prompt-engineering.ts":{"content":"import type { Task, ReasoningStep, FileDiff, AISettings } from \"@shared/schema\";\nimport type { AIService, TaskType } from \"./ai\";\nimport type { MemoryManager, SemanticContext } from \"./memory-manager\";\nimport type { MCPClientManager } from \"./mcp-client\";\nimport type { ChatMessage } from \"./ai-provider-manager\";\n\nexport interface EnhancedPromptContext {\n  taskId: string;\n  taskType: TaskType;\n  complexity: number; // 0-1 scale\n  repository: string;\n  branch?: string;\n  summary: string;\n  code?: string;\n  filePath?: string;\n  semanticContext?: SemanticContext;\n  historicalReasoning: ReasoningStep[];\n  relatedTasks: Task[];\n  mcpTools?: string[];\n  constraints?: string[];\n  userPreferences?: Record<string, any>;\n}\n\nexport interface PromptGenerationStrategy {\n  includeArchitecture: boolean;\n  includeDependencies: boolean;\n  includeHistoricalContext: boolean;\n  includeCodeContext: boolean;\n  includeMCPTools: boolean;\n  reasoningDepth: \"shallow\" | \"medium\" | \"deep\";\n  temperature: number;\n  maxTokens: number;\n}\n\nexport class AdvancedPromptEngineer {\n  private memoryManager?: MemoryManager;\n  private mcpClientManager?: MCPClientManager;\n\n  constructor(\n    memoryManager?: MemoryManager,\n    mcpClientManager?: MCPClientManager\n  ) {\n    this.memoryManager = memoryManager;\n    this.mcpClientManager = mcpClientManager;\n  }\n\n  /**\n   * Generate enhanced prompt with full context awareness\n   */\n  async generateEnhancedPrompt(\n    context: EnhancedPromptContext\n  ): Promise<{\n    messages: ChatMessage[];\n    strategy: PromptGenerationStrategy;\n  }> {\n    // Determine optimal strategy based on task complexity\n    const strategy = this.determineStrategy(context);\n\n    // Build system message with role and capabilities\n    const systemMessage = this.buildSystemMessage(context, strategy);\n\n    // Build context-aware user message\n    const userMessage = await this.buildUserMessage(context, strategy);\n\n    // Add historical reasoning if available\n    const conversationHistory = this.buildConversationHistory(context, strategy);\n\n    const messages: ChatMessage[] = [\n      { role: \"system\", content: systemMessage },\n      ...conversationHistory,\n      { role: \"user\", content: userMessage },\n    ];\n\n    return { messages, strategy };\n  }\n\n  /**\n   * Determine optimal generation strategy based on complexity and context\n   */\n  private determineStrategy(context: EnhancedPromptContext): PromptGenerationStrategy {\n    const baseStrategy: PromptGenerationStrategy = {\n      includeArchitecture: false,\n      includeDependencies: false,\n      includeHistoricalContext: false,\n      includeCodeContext: false,\n      includeMCPTools: false,\n      reasoningDepth: \"medium\",\n      temperature: 0.7,\n      maxTokens: 4096,\n    };\n\n    // High complexity tasks need more context\n    if (context.complexity > 0.7) {\n      baseStrategy.includeArchitecture = true;\n      baseStrategy.includeDependencies = true;\n      baseStrategy.includeHistoricalContext = true;\n      baseStrategy.reasoningDepth = \"deep\";\n      baseStrategy.maxTokens = 8192;\n    }\n\n    // Task-specific adjustments\n    switch (context.taskType) {\n      case \"architecture_design\":\n        baseStrategy.includeArchitecture = true;\n        baseStrategy.includeDependencies = true;\n        baseStrategy.temperature = 0.8;\n        baseStrategy.reasoningDepth = \"deep\";\n        baseStrategy.maxTokens = 10240;\n        break;\n\n      case \"debugging\":\n        baseStrategy.includeCodeContext = true;\n        baseStrategy.includeHistoricalContext = true;\n        baseStrategy.temperature = 0.2;\n        baseStrategy.reasoningDepth = \"deep\";\n        break;\n\n      case \"refactoring\":\n        baseStrategy.includeArchitecture = true;\n        baseStrategy.includeCodeContext = true;\n        baseStrategy.temperature = 0.3;\n        baseStrategy.reasoningDepth = \"medium\";\n        break;\n\n      case \"feature_creation\":\n        baseStrategy.includeArchitecture = true;\n        baseStrategy.includeDependencies = true;\n        baseStrategy.includeCodeContext = true;\n        baseStrategy.temperature = 0.7;\n        baseStrategy.reasoningDepth = \"deep\";\n        baseStrategy.maxTokens = 8192;\n        break;\n\n      case \"test_generation\":\n        baseStrategy.includeCodeContext = true;\n        baseStrategy.temperature = 0.4;\n        baseStrategy.reasoningDepth = \"medium\";\n        break;\n\n      case \"code_review\":\n        baseStrategy.includeArchitecture = true;\n        baseStrategy.includeCodeContext = true;\n        baseStrategy.temperature = 0.4;\n        baseStrategy.reasoningDepth = \"medium\";\n        break;\n\n      case \"security_fix\":\n        baseStrategy.includeCodeContext = true;\n        baseStrategy.includeDependencies = true;\n        baseStrategy.temperature = 0.2;\n        baseStrategy.reasoningDepth = \"deep\";\n        break;\n    }\n\n    // Include MCP tools if available\n    if (this.mcpClientManager && context.mcpTools && context.mcpTools.length > 0) {\n      baseStrategy.includeMCPTools = true;\n    }\n\n    return baseStrategy;\n  }\n\n  /**\n   * Build comprehensive system message\n   */\n  private buildSystemMessage(\n    context: EnhancedPromptContext,\n    strategy: PromptGenerationStrategy\n  ): string {\n    const sections: string[] = [];\n\n    // Core role definition\n    sections.push(this.getRoleDefinition(context.taskType));\n\n    // Reasoning instructions\n    sections.push(this.getReasoningInstructions(strategy.reasoningDepth));\n\n    // MCP tools availability\n    if (strategy.includeMCPTools && context.mcpTools) {\n      sections.push(this.getMCPToolsSection(context.mcpTools));\n    }\n\n    // Constraints\n    if (context.constraints && context.constraints.length > 0) {\n      sections.push(\"\\nConstraints:\");\n      context.constraints.forEach(constraint => {\n        sections.push(`- ${constraint}`);\n      });\n    }\n\n    // Output format instructions\n    sections.push(this.getOutputFormatInstructions(context.taskType));\n\n    return sections.join(\"\\n\\n\");\n  }\n\n  /**\n   * Get role definition based on task type\n   */\n  private getRoleDefinition(taskType: TaskType): string {\n    const roles: Record<TaskType, string> = {\n      refactoring: \"You are a senior software engineer specializing in code refactoring, clean code principles, and design patterns. You have deep expertise in improving code quality while maintaining functionality.\",\n      \n      feature_creation: \"You are an expert full-stack developer with strong architectural skills. You excel at designing and implementing new features that are scalable, maintainable, and align with existing codebase patterns.\",\n      \n      debugging: \"You are a master debugger with exceptional analytical skills. You can quickly identify root causes of issues by analyzing code, logs, and error patterns. You think systematically and verify your solutions.\",\n      \n      test_generation: \"You are a test automation expert who writes comprehensive, maintainable tests. You understand testing pyramids, coverage strategies, and how to write tests that catch real bugs without being brittle.\",\n      \n      ux_validation: \"You are a UX/UI expert with deep knowledge of accessibility, usability principles, and modern design patterns. You can identify friction points and suggest improvements that enhance user experience.\",\n      \n      code_review: \"You are a senior code reviewer with expertise in software quality, security, and best practices. You provide constructive feedback that helps developers grow while maintaining high code standards.\",\n      \n      architecture_design: \"You are a software architect with extensive experience in system design, scalability, and technical decision-making. You create architectures that balance current needs with future flexibility.\",\n      \n      dependency_update: \"You are a dependency management expert who understands version compatibility, breaking changes, and migration strategies. You can safely update dependencies while minimizing risk.\",\n      \n      security_fix: \"You are a security expert specializing in vulnerability analysis and secure coding practices. You can identify security issues and implement fixes that don't compromise functionality or introduce new vulnerabilities.\",\n    };\n\n    return roles[taskType] || \"You are an expert software development assistant.\";\n  }\n\n  /**\n   * Get reasoning instructions based on depth\n   */\n  private getReasoningInstructions(depth: \"shallow\" | \"medium\" | \"deep\"): string {\n    const instructions = {\n      shallow: `Think through the problem step-by-step before providing a solution.`,\n      \n      medium: `Use systematic reasoning:\n1. Analyze the current state and requirements\n2. Consider multiple approaches\n3. Evaluate trade-offs\n4. Choose the best solution\n5. Explain your reasoning`,\n      \n      deep: `Use deep chain-of-thought reasoning:\n1. Break down the problem into components\n2. Analyze each component thoroughly\n3. Consider edge cases and potential issues\n4. Evaluate multiple solution paths\n5. Reason about long-term implications\n6. Synthesize insights into a comprehensive solution\n7. Provide confidence levels for key decisions\n8. Identify areas of uncertainty\n\nFor each major decision, explain:\n- Why this approach over alternatives\n- What assumptions you're making\n- What risks or trade-offs exist\n- How confident you are (0-100%)`,\n    };\n\n    return instructions[depth];\n  }\n\n  /**\n   * Get MCP tools section\n   */\n  private getMCPToolsSection(tools: string[]): string {\n    return `Available MCP Tools:\nYou have access to the following tools to help accomplish this task:\n${tools.map(tool => `- ${tool}`).join('\\n')}\n\nUse these tools when appropriate to gather information, perform actions, or validate your solutions.`;\n  }\n\n  /**\n   * Get output format instructions\n   */\n  private getOutputFormatInstructions(taskType: TaskType): string {\n    const formats: Record<TaskType, string> = {\n      refactoring: `Output Format:\n1. Analysis: Identify code smells and improvement opportunities\n2. Refactoring Plan: List specific changes with reasoning\n3. Implementation: Provide refactored code\n4. Validation: Explain how the refactoring maintains or improves functionality`,\n      \n      feature_creation: `Output Format:\n1. Requirements Analysis: Confirm understanding of the feature\n2. Architecture Design: Explain how the feature integrates\n3. Implementation Plan: Break down into steps\n4. Code Implementation: Provide working code\n5. Testing Strategy: Outline how to test the feature`,\n      \n      debugging: `Output Format:\n1. Problem Analysis: What's happening and why\n2. Root Cause: The underlying issue\n3. Solution: Fix with detailed explanation\n4. Verification: How to confirm the fix works\n5. Prevention: How to avoid similar issues`,\n      \n      test_generation: `Output Format:\n1. Test Strategy: What to test and why\n2. Test Cases: Comprehensive list of scenarios\n3. Implementation: Complete test code\n4. Coverage Analysis: What's covered and what isn't`,\n      \n      code_review: `Output Format:\n1. Summary: Overall assessment\n2. Critical Issues: Security, bugs, breaking changes\n3. Suggestions: Improvements for quality and maintainability\n4. Praise: What's done well\n5. Priority: Critical  High  Medium  Low`,\n      \n      architecture_design: `Output Format:\n1. Requirements: Key constraints and goals\n2. Architecture Overview: High-level design\n3. Component Design: Detailed specifications\n4. Data Flow: How information moves through the system\n5. Trade-offs: Design decisions and rationale\n6. Implementation Roadmap: Phases and milestones`,\n      \n      ux_validation: `Output Format:\n1. UX Assessment: Current state analysis\n2. Issues: Friction points and accessibility concerns\n3. Recommendations: Prioritized improvements\n4. Rationale: Why each recommendation matters\n5. Implementation: How to apply suggestions`,\n      \n      dependency_update: `Output Format:\n1. Update Analysis: What's changing\n2. Breaking Changes: Incompatibilities to address\n3. Migration Plan: Step-by-step update process\n4. Risk Assessment: Potential issues\n5. Testing Strategy: How to verify the update`,\n      \n      security_fix: `Output Format:\n1. Vulnerability Analysis: Nature and severity\n2. Impact Assessment: What's at risk\n3. Fix Implementation: Secure code\n4. Verification: How to confirm the fix\n5. Additional Recommendations: Related security improvements`,\n    };\n\n    return formats[taskType] || \"Provide clear, structured output with reasoning.\";\n  }\n\n  /**\n   * Build context-aware user message\n   */\n  private async buildUserMessage(\n    context: EnhancedPromptContext,\n    strategy: PromptGenerationStrategy\n  ): Promise<string> {\n    const sections: string[] = [];\n\n    // Task header\n    sections.push(`Task: ${context.summary}`);\n    sections.push(`Repository: ${context.repository}`);\n    if (context.branch) {\n      sections.push(`Branch: ${context.branch}`);\n    }\n\n    // Semantic context from Memory Manager\n    if (strategy.includeArchitecture && context.semanticContext) {\n      sections.push(this.buildArchitectureSection(context.semanticContext));\n    }\n\n    if (strategy.includeDependencies && context.semanticContext) {\n      sections.push(this.buildDependenciesSection(context.semanticContext));\n    }\n\n    // Code context\n    if (strategy.includeCodeContext && context.code) {\n      sections.push(this.buildCodeSection(context));\n    }\n\n    // Historical context\n    if (strategy.includeHistoricalContext && context.historicalReasoning.length > 0) {\n      sections.push(this.buildHistoricalSection(context.historicalReasoning));\n    }\n\n    // Related tasks\n    if (context.relatedTasks.length > 0) {\n      sections.push(this.buildRelatedTasksSection(context.relatedTasks));\n    }\n\n    return sections.join(\"\\n\\n---\\n\\n\");\n  }\n\n  /**\n   * Build architecture section from semantic context\n   */\n  private buildArchitectureSection(semanticContext: SemanticContext): string {\n    const sections: string[] = [\"## Repository Architecture\"];\n\n    if (semanticContext.summary) {\n      sections.push(`Summary: ${semanticContext.summary}`);\n    }\n\n    if (semanticContext.architecture.type) {\n      sections.push(`Type: ${semanticContext.architecture.type}`);\n    }\n\n    if (semanticContext.architecture.layers.length > 0) {\n      sections.push(\"\\nLayers:\");\n      semanticContext.architecture.layers.forEach(layer => {\n        sections.push(`- ${layer.name}: ${layer.description}`);\n        sections.push(`  Files: ${layer.files.length}`);\n      });\n    }\n\n    if (semanticContext.architecture.patterns.length > 0) {\n      sections.push(\"\\nDesign Patterns:\");\n      semanticContext.architecture.patterns.forEach(pattern => {\n        sections.push(`- ${pattern.pattern}: ${pattern.description} (${pattern.occurrences.length} occurrences)`);\n      });\n    }\n\n    if (semanticContext.technicalDebt.totalScore > 0) {\n      sections.push(`\\nTechnical Debt Score: ${semanticContext.technicalDebt.totalScore}`);\n      if (semanticContext.technicalDebt.issues.length > 0) {\n        sections.push(\"Top Issues:\");\n        semanticContext.technicalDebt.issues.slice(0, 5).forEach(issue => {\n          sections.push(`- [${issue.severity}] ${issue.description}`);\n        });\n      }\n    }\n\n    return sections.join(\"\\n\");\n  }\n\n  /**\n   * Build dependencies section\n   */\n  private buildDependenciesSection(semanticContext: SemanticContext): string {\n    const sections: string[] = [\"## Dependencies\"];\n\n    sections.push(`Total Dependencies: ${semanticContext.dependencyGraph.nodes.size}`);\n\n    if (semanticContext.dependencyGraph.cycles.length > 0) {\n      sections.push(`\\n Circular Dependencies Detected: ${semanticContext.dependencyGraph.cycles.length}`);\n    }\n\n    // List top dependencies\n    const topDeps = Array.from(semanticContext.dependencyGraph.nodes.values())\n      .sort((a, b) => b.dependents.length - a.dependents.length)\n      .slice(0, 10);\n\n    if (topDeps.length > 0) {\n      sections.push(\"\\nMost Used Dependencies:\");\n      topDeps.forEach(dep => {\n        sections.push(`- ${dep.name}${dep.version ? `@${dep.version}` : ''} (${dep.dependents.length} dependents)`);\n      });\n    }\n\n    return sections.join(\"\\n\");\n  }\n\n  /**\n   * Build code section\n   */\n  private buildCodeSection(context: EnhancedPromptContext): string {\n    const sections: string[] = [\"## Code Context\"];\n\n    if (context.filePath) {\n      sections.push(`File: ${context.filePath}`);\n    }\n\n    if (context.code) {\n      const lineCount = context.code.split(\"\\n\").length;\n      sections.push(`Lines: ${lineCount}`);\n      sections.push(\"\\n```\");\n      sections.push(context.code);\n      sections.push(\"```\");\n    }\n\n    return sections.join(\"\\n\");\n  }\n\n  /**\n   * Build historical reasoning section\n   */\n  private buildHistoricalSection(reasoning: ReasoningStep[]): string {\n    const sections: string[] = [\"## Historical Context\"];\n\n    sections.push(\"Previous reasoning and decisions:\");\n\n    const recentReasoning = reasoning.slice(-5); // Last 5 steps\n    recentReasoning.forEach((step, index) => {\n      const status = step.completed ? \"\" : \"\";\n      const confidence = step.confidence ? ` (${step.confidence}% confidence)` : \"\";\n      sections.push(`${status} ${step.description}${confidence}`);\n    });\n\n    return sections.join(\"\\n\");\n  }\n\n  /**\n   * Build related tasks section\n   */\n  private buildRelatedTasksSection(tasks: Task[]): string {\n    const sections: string[] = [\"## Related Tasks\"];\n\n    const relevantTasks = tasks.slice(0, 3);\n    relevantTasks.forEach(task => {\n      sections.push(`- [${task.status}] ${task.title}`);\n      if (task.summary) {\n        sections.push(`  ${task.summary.substring(0, 100)}...`);\n      }\n    });\n\n    return sections.join(\"\\n\");\n  }\n\n  /**\n   * Build conversation history from prior reasoning\n   */\n  private buildConversationHistory(\n    context: EnhancedPromptContext,\n    strategy: PromptGenerationStrategy\n  ): ChatMessage[] {\n    if (!strategy.includeHistoricalContext) {\n      return [];\n    }\n\n    const messages: ChatMessage[] = [];\n\n    // Include significant reasoning steps as conversation\n    const significantSteps = context.historicalReasoning\n      .filter(step => step.confidence && step.confidence > 70)\n      .slice(-3); // Last 3 significant steps\n\n    significantSteps.forEach(step => {\n      messages.push({\n        role: \"assistant\",\n        content: step.description,\n      });\n    });\n\n    return messages;\n  }\n\n  /**\n   * Calculate task complexity score\n   */\n  calculateComplexity(context: {\n    codeSize?: number;\n    fileCount?: number;\n    dependencyCount?: number;\n    issueCount?: number;\n    taskType: TaskType;\n  }): number {\n    let complexity = 0.5; // Base complexity\n\n    // Code size factor\n    if (context.codeSize) {\n      if (context.codeSize > 1000) complexity += 0.2;\n      else if (context.codeSize > 500) complexity += 0.1;\n    }\n\n    // File count factor\n    if (context.fileCount) {\n      if (context.fileCount > 10) complexity += 0.1;\n      else if (context.fileCount > 5) complexity += 0.05;\n    }\n\n    // Dependency factor\n    if (context.dependencyCount) {\n      if (context.dependencyCount > 50) complexity += 0.1;\n      else if (context.dependencyCount > 20) complexity += 0.05;\n    }\n\n    // Task type factor\n    const taskComplexity: Record<TaskType, number> = {\n      architecture_design: 0.9,\n      feature_creation: 0.7,\n      debugging: 0.6,\n      refactoring: 0.5,\n      code_review: 0.5,\n      test_generation: 0.4,\n      security_fix: 0.7,\n      ux_validation: 0.5,\n      dependency_update: 0.6,\n    };\n\n    complexity = Math.max(complexity, taskComplexity[context.taskType] || 0.5);\n\n    return Math.min(complexity, 1.0); // Cap at 1.0\n  }\n\n  /**\n   * Optimize prompt for token limits\n   */\n  optimizePromptForTokens(\n    prompt: string,\n    maxTokens: number,\n    preserveSections: string[] = []\n  ): string {\n    // Rough estimate: 1 token  4 characters\n    const estimatedTokens = prompt.length / 4;\n\n    if (estimatedTokens <= maxTokens * 0.8) {\n      return prompt; // Within limits\n    }\n\n    // Need to truncate - preserve important sections\n    const sections = prompt.split(\"---\");\n    const preserved: string[] = [];\n    const optional: string[] = [];\n\n    sections.forEach(section => {\n      const shouldPreserve = preserveSections.some(ps => section.includes(ps));\n      if (shouldPreserve) {\n        preserved.push(section);\n      } else {\n        optional.push(section);\n      }\n    });\n\n    // Start with preserved sections\n    let optimized = preserved.join(\"\\n---\\n\");\n    let currentTokens = optimized.length / 4;\n\n    // Add optional sections if space allows\n    for (const section of optional) {\n      const sectionTokens = section.length / 4;\n      if (currentTokens + sectionTokens < maxTokens * 0.8) {\n        optimized += \"\\n---\\n\" + section;\n        currentTokens += sectionTokens;\n      }\n    }\n\n    return optimized;\n  }\n}\n","size_bytes":20868}},"version":2}